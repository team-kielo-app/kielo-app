src/pagination/actions.ts
```typescript
import { AppDispatch, RootState } from '@store/store'
import { makeQueryString } from '@utils/url'
import { assertInvariant } from '@utils/assert'
import { DEFAULT_PAGINATION_STATE } from './constants'
import type { PaginationMeta, EntityMeta, PaginationStateType } from './types'
import { ThunkAction } from '@reduxjs/toolkit'

/**
 * Describes a thunk creator that is configured for a specific API request (endpoint, verb, schema).
 * It takes parameters relevant to the request execution (like query string, body, and metadata for Redux actions)
 * and returns a ThunkAction.
 */
type ApiRequestThunkCreator = (params: {
  queryString?: string
  body?: Record<string, unknown> | unknown[] | undefined
  meta: PaginationMeta | EntityMeta
}) => ThunkAction<Promise<any>, RootState, unknown, any>

/**
 * Higher-order function to wrap API calls with pagination logic for LISTING data.
 */
export function withPaginationList<S extends RootState>({
  apiRequestFunction,
  getStatePaginationData,
  paginationKey,
  pageSize = 20,
  fetchPolicy = 'fetchIfNeeded',
  additionalQueryParams = {}
}: {
  apiRequestFunction: ApiRequestThunkCreator
  getStatePaginationData: (state: S) => Record<string, PaginationStateType>
  paginationKey: string
  pageSize?: number
  fetchPolicy?: 'fetchIfNeeded' | 'forceFetch'
  additionalQueryParams?: Record<string, any>
}) {
  return (
      options: {
        reset?: boolean
        fetchNext?: boolean
        fetchPrevious?: boolean
      } = {}
    ) =>
    (dispatch: AppDispatch, getState: () => S) => {
      const {
        reset = false,
        fetchNext = false,
        fetchPrevious = false
      } = options

      const state = getState()
      const paginationStateMap = getStatePaginationData(state)
      const currentPagination =
        paginationStateMap[paginationKey] || DEFAULT_PAGINATION_STATE

      const { isLoading, nextPageKey, prevPageKey, ids, currentPage } =
        currentPagination

      let pageToFetch: 'first' | 'next' | 'prev' = 'first'
      let cursor: string | null = null

      if (!reset) {
        if (fetchNext && nextPageKey) {
          pageToFetch = 'next'
          cursor = nextPageKey
        } else if (fetchPrevious && prevPageKey) {
          pageToFetch = 'prev'
          cursor = prevPageKey
        } else if (fetchNext && !nextPageKey && !isLoading) {
          console.log(
            `Pagination [${paginationKey}]: Already at end or fetching.`
          )
          return Promise.resolve()
        } else if (
          !fetchNext &&
          !fetchPrevious &&
          currentPage > 0 &&
          fetchPolicy === 'fetchIfNeeded'
        ) {
          console.log(
            `Pagination [${paginationKey}]: Already fetched, use fetchPolicy='forceFetch' or reset=true to refetch.`
          )
          return Promise.resolve()
        }
      }

      if (isLoading && !(reset && fetchPolicy === 'forceFetch')) {
        console.log(`Pagination [${paginationKey}]: Fetch already in progress.`)
        return Promise.resolve()
      }

      const queryParams: Record<string, any> = {
        page_size: pageSize,
        ...additionalQueryParams
      }
      if (cursor) {
        if (pageToFetch === 'next') queryParams.next_page_key = cursor
        if (pageToFetch === 'prev') queryParams.next_page_key = cursor
      }
      const queryString = makeQueryString(queryParams)

      const meta: PaginationMeta = {
        paginationKey,
        pageFetched: reset ? 'first' : pageToFetch,
        pageSize,
        reset
      }

      return dispatch(
        apiRequestFunction({
          queryString,
          meta
        })
      )
    }
}

/**
 * Higher-order function to wrap API calls for single entity actions (DELETE, PATCH)
 * that might affect pagination lists.
 */
export function withPaginationEntityAction<S extends RootState>({
  apiRequestFunction,
  getStatePaginationData,
  paginationKey,
  entityName,
  itemId,
  verb
}: {
  apiRequestFunction: ApiRequestThunkCreator
  getStatePaginationData?: (state: S) => Record<string, PaginationStateType>
  paginationKey?: string
  entityName: string
  itemId: string | string[]
  verb: 'DELETE' | 'PUT' | 'PATCH'
}) {
  assertInvariant(apiRequestFunction, 'apiRequestFunction is required')
  assertInvariant(entityName, 'entityName is required')
  assertInvariant(itemId, 'itemId is required')

  return (body?: any) => (dispatch: AppDispatch, getState: () => S) => {
    const meta: EntityMeta = {
      entityName,
      itemId,
      ...(paginationKey && { paginationKey })
    }

    return dispatch(
      apiRequestFunction({
        body,
        meta
      })
    )
  }
}

```
src/pagination/apiRequestThunkFactory.ts
```typescript
import { seq } from 'transducers.js'
import { apiClient } from '@lib/api'
import { normalize, Schema } from 'normalizr'
import type { AppDispatch, RootState } from '@store/store'
import type { ThunkAction } from 'redux-thunk'
import type { PaginationMeta, EntityMeta } from './types'

type ApiVerb = 'GET' | 'POST' | 'PUT' | 'DELETE'

// Type for the parameters passed INTO the generated thunk
interface ApiRequestParams {
  queryString?: string
  body?: Record<string, unknown> | unknown[] | undefined
  meta: PaginationMeta | EntityMeta
}

// Generic types for transform functions
type TransformFunction<Input = any, Output = any> = (data: Input) => Output
type BeforeTransform = TransformFunction
type XfTransform = any
type AfterTransform = TransformFunction

// Type for the configuration of the factory itself
interface ApiThunkConfig {
  types: [string, string, string] // Request, Success, Failure
  endpoint: string
  verb: ApiVerb
  schema?: Schema
  transform?: [
    before?: BeforeTransform,
    xf?: XfTransform,
    after?: AfterTransform
  ]
  cb?: (err: Error | null, res?: any) => void
}

// Extracted Factory Function (~80 lines)
export function createApiRequestThunk({
  types,
  endpoint,
  verb,
  schema,
  transform: [before, xf, after] = [null, null, null],
  cb
}: ApiThunkConfig): (
  params: ApiRequestParams
) => ThunkAction<Promise<any>, RootState, unknown, any> {
  const [requestType, successType, failureType] = types

  // Return the actual thunk action creator
  return ({ queryString = '', body, meta }) =>
    async (dispatch: AppDispatch) => {
      const finalEndpoint = `${endpoint}${queryString}`

      // Dispatch request action immediately
      dispatch({ type: requestType, meta })

      try {
        // Perform API call using apiClient
        let response: any
        switch (verb) {
          case 'POST':
            response = await apiClient.post(finalEndpoint, body, dispatch) // Pass dispatch if needed
            break
          case 'PUT':
            response = await apiClient.put(finalEndpoint, body, dispatch)
            break
          case 'DELETE':
            response = await apiClient.delete(finalEndpoint, dispatch)
            break
          case 'GET':
          default:
            response = await apiClient.get(finalEndpoint, dispatch)
            break
        }

        // --- Data Processing ---
        // 1. Transform Raw Response (if transform function provided)
        let dataToProcess = before ? before(response) : response
        dataToProcess = xf ? seq(dataToProcess, xf) : dataToProcess
        dataToProcess = after ? after(dataToProcess) : dataToProcess

        // 2. Normalize Data (if schema provided)
        let normalizedData: {
          result?: any
          entities?: Record<string, Record<string, any>> // More specific type
          [key: string]: any
        } = {}
        if (schema && dataToProcess) {
          // Add _lastFetchedAt to items before normalization if dataToProcess is an array
          // If dataToProcess is a single object (for single entity fetch), add it there.
          const now = Date.now()
          let processableDataWithTimestamp = dataToProcess
          if (Array.isArray(dataToProcess)) {
            processableDataWithTimestamp = dataToProcess.map(item =>
              item && typeof item === 'object'
                ? { ...item, _lastFetchedAt: now }
                : item
            )
          } else if (dataToProcess && typeof dataToProcess === 'object') {
            processableDataWithTimestamp = {
              ...dataToProcess,
              _lastFetchedAt: now
            }
          }

          normalizedData = normalize(processableDataWithTimestamp, schema)
          // normalizedData.entities will now have items with _lastFetchedAt
        } else {
          // If no schema, pass dataToProcess through, primarily for non-entity responses
          // The `result` field will be based on dataToProcess itself.
          // Ensure entities is an empty object if no schema.
          normalizedData.result = dataToProcess // Or handle as needed if dataToProcess is not the "result"
          normalizedData.entities = {}
        }

        // Ensure pagination fields exist on the final response object for the reducer
        const finalResponse = {
          ...normalizedData, // Includes result, entities from normalization
          nextPageKey:
            response?.next_page_key ?? normalizedData.nextPageKey ?? null, // Prioritize raw response keys
          prevPageKey:
            response?.prev_page_key ?? normalizedData.prevPageKey ?? null,
          totalCount: response?.total_count ?? normalizedData.totalCount ?? 0
        }

        // Dispatch success action
        dispatch({ type: successType, response: finalResponse, meta })
        if (cb) cb(null, finalResponse) // Callback with processed data
        return finalResponse // Resolve promise with processed data
      } catch (error: any) {
        console.error(
          `API Request Thunk Failed [${verb} ${finalEndpoint}]:`,
          error
        )
        const errorMessage = error.message || 'API request failed'
        // Dispatch failure action
        dispatch({ type: failureType, error: errorMessage, meta })
        if (cb) cb(error) // Callback with error
        throw error // Reject promise
      }
    }
}

```
src/pagination/constants.ts
```typescript
export const DEFAULT_PAGINATION_STATE = {
  ids: [] as (string | Record<string, any>)[], // Combined IDs from all fetched pages for this key
  currentPage: 0, // The last successfully fetched page number (1-based)
  pageSize: 20, // Default page size, updated on first successful fetch
  nextPageKey: null as string | null, // Token/cursor/ID for the next page from API
  prevPageKey: null as string | null, // Token/cursor/ID for the previous page (if supported by API)
  totalCount: 0, // Total number of items if known
  hasReachedEnd: false, // Flag if the API indicated no more next pages
  isLoading: false, // Is a request currently in progress?
  // hasFetched: false, // Redundant - can be inferred from currentPage > 0 or ids.length > 0
  // pageDirection: 'idle', // Overly complex - isLoading + pageFetched meta is enough
  error: null as string | null, // Store specific pagination errors
  lastSuccessfulFetchAt: null
}

```
src/pagination/reducer.ts
```typescript
import { DEFAULT_PAGINATION_STATE } from './constants'
import type { PaginationStateType, PaginationMeta } from './types'
import { uniqueStringsConcatOrder, uniqueObjectsConcatOrder } from './utils'

// Define a more specific action type for the pagination reducer
interface PaginationReducerAction {
  type: string
  // For success actions
  response?: {
    [key: string]: any // Allows for dynamic resultField
    nextPageKey?: string | null
    prevPageKey?: string | null
    totalCount?: number
    // entities?: Record<string, Record<string, any>>; // If entities are also passed here
  }
  // For all actions with pagination meta
  meta?: PaginationMeta & {
    forceRequest?: boolean /* other meta flags if needed */
  }
  // For failure actions
  error?: string
}

function updateSinglePaginationState(
  state: PaginationStateType = DEFAULT_PAGINATION_STATE,
  action: PaginationReducerAction,
  config: {
    // Pass config down
    requestTypes: string[]
    successTypes: string[]
    failureTypes: string[]
    idField: string
    resultField: string
  }
): PaginationStateType {
  // Return type annotation
  const { requestTypes, successTypes, failureTypes, idField, resultField } =
    config

  // --- Request ---
  if (requestTypes.includes(action.type)) {
    // Only update if not already fetching to avoid redundant state changes
    // unless the action explicitly forces it (e.g., via meta flag)
    if (state.isLoading && !action.meta?.forceRequest) {
      return state
    }
    return {
      ...state,
      isLoading: true,
      error: null
    }
  }

  // --- Failure ---
  if (failureTypes.includes(action.type)) {
    // Only update if it was actually fetching
    if (!state.isLoading) {
      return state
    }
    return {
      ...state,
      isLoading: false,
      error: action.error || 'An unexpected error occurred. Please try again.' // Store the error message
    }
  }

  // --- Success ---
  if (successTypes.includes(action.type)) {
    // Guard clause: Ensure response and meta are present
    if (!action.response || !action.meta) {
      console.warn(
        `Pagination reducer received success action ${action.type} without response or meta.`
      )
      // Return current state but mark as not loading if it was, maybe set an error
      return {
        ...state,
        isLoading: false,
        error: state.isLoading
          ? 'Invalid success response received'
          : state.error
      }
    }

    const newItems = action.response?.[resultField] || []
    const paginationMeta = action.meta // Contains PaginationMeta
    const shouldReset = paginationMeta?.reset ?? false

    // Defensive check for idField existence if items are objects
    const newIds = newItems
      .map(item => {
        if (typeof item === 'object' && item !== null) {
          const id = item[idField] ?? item.key // Allow fallback to 'key'
          if (id === undefined || id === null) {
            console.warn(
              `Pagination reducer: Item missing identifier ('${idField}' or 'key')`,
              item
            )
            return null // Represent invalid item as null
          }
          return id
        }
        return item // Assume string or number ID otherwise
      })
      .filter(id => id !== null) // Filter out items that couldn't be identified

    // Determine how to combine IDs
    let combinedIds = state.ids
    if (shouldReset) {
      combinedIds = newIds
    } else if (newIds.length > 0) {
      // Only concat if there are new IDs
      const areNewIdsStrings = newIds.every(id => typeof id === 'string')
      const areCurrentIdsStrings = state.ids.every(id => typeof id === 'string')

      // Choose concat strategy based on page fetched and ID types
      if (paginationMeta?.pageFetched === 'next') {
        // Append new unique items
        combinedIds =
          areNewIdsStrings && areCurrentIdsStrings
            ? uniqueStringsConcatOrder(state.ids, newIds)
            : uniqueObjectsConcatOrder(state.ids, newIds, idField)
      } else if (paginationMeta?.pageFetched === 'prev') {
        // Prepend new unique items
        combinedIds =
          areNewIdsStrings && areCurrentIdsStrings
            ? uniqueStringsConcatOrder(newIds, state.ids) // Swapped order for prepend effect
            : uniqueObjectsConcatOrder(newIds, state.ids, idField) // Swapped order for prepend effect
      } else {
        // Default for 'first' or unspecified non-reset fetch: Usually replace, but could merge if needed.
        // Let's stick to replacing for simplicity unless merging 'first' page is required.
        combinedIds = newIds
      }
    }
    // else: No new IDs, keep existing combinedIds

    // Calculate next page number
    let nextPageNumber = state.currentPage
    if (shouldReset || paginationMeta?.pageFetched === 'first') {
      nextPageNumber = newIds.length > 0 ? 1 : 0
    } else if (
      paginationMeta?.pageFetched === 'next' &&
      newIds.length > 0 &&
      state.isLoading
    ) {
      // Ensure it was loading this page
      nextPageNumber += 1
    }
    // Note: 'prev' fetch doesn't reliably map to decrementing page *number*

    // Extract pagination details from response, fallback to state or defaults
    const totalCount =
      action.response?.totalCount ?? (shouldReset ? 0 : state.totalCount)
    const nextPageKey =
      action.response?.nextPageKey !== undefined
        ? action.response.nextPageKey
        : null // Default to null
    const prevPageKey = action.response?.prevPageKey ?? null // Default to null
    const hasReachedEnd = nextPageKey === null || nextPageKey === '' // Determine end state

    return {
      ...state,
      ids: combinedIds,
      currentPage: nextPageNumber,
      pageSize: paginationMeta?.pageSize ?? state.pageSize,
      nextPageKey: nextPageKey,
      prevPageKey: prevPageKey,
      totalCount: totalCount,
      hasReachedEnd: hasReachedEnd,
      isLoading: false, // Mark as not loading
      error: null,
      lastSuccessfulFetchAt: Date.now()
    }
  }

  // --- Handle implicit removal on success actions (e.g., after DELETE) ---
  // This requires meta flags indicating successful deletion and item ID
  // Example check:
  // if (action.meta?.isDeletionSuccess && action.meta?.itemId && successTypes.includes(action.type)) {
  //    const itemsToRemove = Array.isArray(action.meta.itemId) ? action.meta.itemId : [action.meta.itemId];
  //    const filteredIds = state.ids.filter(id => {
  //       const identifier = (typeof id === 'object' && id !== null) ? (id[idField] ?? id.key) : id;
  //       return !itemsToRemove.includes(identifier);
  //    });
  //    // Only update if IDs actually changed
  //    if (filteredIds.length !== state.ids.length) {
  //        return {
  //           ...state,
  //           ids: filteredIds,
  //           totalCount: Math.max(0, state.totalCount - itemsToRemove.length),
  //        }
  //    }
  // }

  // Default: return current state if action type is not handled
  return state
}

export function paginate(config: {
  requestTypes: string[]
  successTypes: string[]
  failureTypes: string[]
  idField?: string
  mapActionToKey: (action: any) => string | null
  resultField?: string
}) {
  // Validate config at the start
  const {
    requestTypes,
    successTypes,
    failureTypes,
    mapActionToKey,
    idField = 'id',
    resultField = 'result'
  } = config

  if (!requestTypes || !successTypes || !failureTypes || !mapActionToKey) {
    throw new Error(
      'paginate HOC requires requestTypes, successTypes, failureTypes, and mapActionToKey.'
    )
  }
  if (
    !Array.isArray(requestTypes) ||
    !Array.isArray(successTypes) ||
    !Array.isArray(failureTypes)
  ) {
    throw new Error('Action types must be arrays of strings.')
  }
  if (typeof mapActionToKey !== 'function') {
    throw new Error('mapActionToKey must be a function.')
  }

  const allRelevantTypes = new Set([
    ...requestTypes,
    ...successTypes,
    ...failureTypes
  ])
  const internalConfig = {
    requestTypes,
    successTypes,
    failureTypes,
    idField,
    resultField
  }

  const initialState = {}

  // Reducer that manages multiple pagination instances by key
  return function updatePaginationByKey(state = initialState, action) {
    // Global reset action
    if (action.type === 'RESET_ALL_PAGINATION') {
      return initialState
    }

    // Check if action type is relevant
    if (!allRelevantTypes.has(action.type)) {
      // Optional: Handle implicit removal based on meta here if preferred over updateSinglePaginationState
      // if (action.meta?.isDeletionSuccess && action.meta?.paginationKey ...) { ... }
      return state
    }

    // Get the dynamic key for this pagination instance
    const key = mapActionToKey(action)

    // Guard clause: If no key is derived, this action isn't for keyed pagination
    if (!key || typeof key !== 'string') {
      // console.warn(`Pagination key function returned invalid key for action: ${action.type}`);
      return state
    }

    // Delegate state update to the single instance handler
    const previousInstanceState = state[key]
    const nextInstanceState = updateSinglePaginationState(
      previousInstanceState,
      action,
      internalConfig
    )

    // Only update the state object if the instance state actually changed
    if (nextInstanceState === previousInstanceState) {
      return state
    }

    // Return the updated state map
    return {
      ...state,
      [key]: nextInstanceState
    }
  }
}

```
src/pagination/selectors.ts
```typescript
// src/features/articles/articles.selectors.ts
import { createSelector } from '@reduxjs/toolkit' // Or import from 'reselect'
import type { RootState } from '@store/store' // Your root state type
import { DEFAULT_PAGINATION_STATE } from './constants' // Import default state
import type { PaginationStateType, PaginatedData } from './types'
import type { EntitiesType } from '@entities/types' // Import the core Article type

// Base selectors
const selectEntitiesSlice = (state: RootState) => state.entities
const selectPaginationSlice = (state: RootState) => state.pagination

/**
 * Selects a specific entity type from the entities state
 */
export const selectEntityCollection = (entityName: string) =>
  createSelector(
    [selectEntitiesSlice],
    (entities: { [entityName]: EntitiesType }) => entities[entityName] || {}
  )

/**
 * Selects a specific pagination type from the pagination state
 */
export const selectPaginationType = (paginationType: string) =>
  createSelector(
    [selectPaginationSlice],
    (pagination: { [paginationType]: object }) =>
      pagination[paginationType] || {}
  )

/**
 * Converts an array of entity IDs to their corresponding entity objects
 */
export const mapIdsToEntities = <T>(
  ids: string[],
  entities: Record<string, T>
): T[] => {
  return ids.map(id => entities[id]).filter(Boolean)
}

/**
 * Determines if there are more pages based on page tokens
 */
export const hasMorePages = (
  nextPageToken: string | null,
  isAccumulated: boolean,
  prevPageToken?: string | null
): boolean => {
  if (isAccumulated) {
    return Boolean(nextPageToken)
  }
  return Boolean(nextPageToken) || Boolean(prevPageToken)
}

/**
 * Creates a paginated data object from pagination state and entities
 */
export const createPaginatedData = <T>(
  paginationState: Partial<PaginationStateType>,
  entities: Record<string, T>,
  isAccumulated: boolean
): PaginatedData => {
  // Apply defaults for missing values
  const {
    ids = [],
    currentIds = [],
    currentPage = 1,
    pageSize = DEFAULT_PAGINATION_STATE.pageSize,
    totalCount = 0,
    isLoading = false,
    hasFetched = false,
    nextPageToken = null,
    prevPageToken = null,
    error = null,
    lastSuccessfulFetchAt = null
  } = paginationState

  let data: T[] = []

  if (isAccumulated && ids.length > 0 && currentPage >= 1) {
    // Calculate current page slice for accumulated data
    const startIndex = (currentPage - 1) * pageSize
    const endIndex = startIndex + pageSize
    const pageIds = ids.slice(startIndex, endIndex)
    data = mapIdsToEntities(pageIds, entities)
  } else {
    // Use all relevant IDs for non-accumulated data
    data = mapIdsToEntities(ids, entities)
  }

  // Calculate pagination metadata
  const totalPages = pageSize > 0 ? Math.ceil(totalCount / pageSize) : 0
  const hasMore = hasMorePages(nextPageToken, isAccumulated, prevPageToken)

  return {
    data,
    pagination: {
      currentPage,
      pageSize,
      totalCount,
      totalPages,
      isLoading,
      hasMore,
      hasFetched,
      error,
      lastSuccessfulFetchAt
    }
  }
}

/**
 * Error response for invalid selector parameters
 */
const createErrorResponse = (errorMessage: string): PaginatedData => ({
  data: [],
  pagination: {
    currentPage: 0,
    pageSize: DEFAULT_PAGINATION_STATE.pageSize,
    totalCount: 0,
    totalPages: 0,
    isLoading: false,
    hasMore: false,
    hasFetched: false,
    error: errorMessage
  }
})

/**
 * Selects paginated data for a collection of entities
 */
export const selectPaginatedData = <T extends { _lastFetchedAt?: number }>( // T now has _lastFetchedAt
  entityName: string, // e.g., 'articles'
  paginationType: string, // e.g., 'articlePagination'
  paginationKey: string,
  isAccumulated: boolean = false // Keep this for flexibility
) =>
  createSelector(
    [
      (state: RootState) => state.entities[entityName as string] || {}, // Entity collection
      (state: RootState) =>
        state.pagination[paginationType]?.[paginationKey] ||
        DEFAULT_PAGINATION_STATE
    ],
    (
      entityCollection: Record<string, T>,
      paginationState: PaginationStateType
    ): PaginatedData<T> => {
      // Ensure return type matches generic
      // console.log(`Selector for ${entityName} - ${paginationKey} recomputing. PS LastFetch: ${paginationState.lastSuccessfulFetchAt}`);

      const {
        ids = [],
        currentPage = 1,
        pageSize = DEFAULT_PAGINATION_STATE.pageSize,
        totalCount = 0,
        isLoading = false,
        // hasFetched removed, will derive
        nextPageKey = null, // Renamed from nextPageToken for consistency with pagination state
        prevPageKey = null, // Renamed from prevPageToken
        error = null,
        lastSuccessfulFetchAt = null
      } = paginationState

      let resolvedData: T[] = []
      const idArrayToProcess = ids || [] // Ensure ids is an array

      if (isAccumulated && idArrayToProcess.length > 0 && currentPage >= 1) {
        const startIndex = (currentPage - 1) * pageSize
        const endIndex = startIndex + pageSize
        const pageIds = idArrayToProcess.slice(startIndex, endIndex)
        resolvedData = pageIds
          .map(
            id => entityCollection[typeof id === 'object' ? (id as any).id : id]
          ) // Handle if IDs are objects
          .filter(Boolean) as T[]
      } else {
        resolvedData = idArrayToProcess
          .map(
            id => entityCollection[typeof id === 'object' ? (id as any).id : id]
          )
          .filter(Boolean) as T[]
      }

      const totalPages = pageSize > 0 ? Math.ceil(totalCount / pageSize) : 0
      // hasMorePages function might need to use nextPageKey/prevPageKey from paginationState
      const hasMore = !!nextPageKey // Simpler, based on next cursor
      const hasFetched = currentPage > 0 || idArrayToProcess.length > 0

      return {
        data: resolvedData,
        pagination: {
          currentPage,
          pageSize,
          totalCount,
          totalPages,
          isLoading,
          hasMore,
          hasFetched,
          error,
          lastSuccessfulFetchAt // Include this
          // prevPageKey, // Optionally include if UI needs it
          // nextPageKey, // Optionally include if UI needs it
        }
      }
    }
  )

/**
 * Selects a single entity by ID
 */
export const selectEntityById = <T>(entityName: string, entityId: string) =>
  createSelector(
    [selectEntityCollection(entityName)],
    (entityCollection): T | object => {
      if (!entityName || !entityId) {
        return {}
      }

      return (entityCollection[entityId] as T) || {}
    }
  )

```
src/pagination/types.d.ts
```typescript
export interface PaginatedData<DataType = any> {
  data: DataType[]
  pagination: {
    currentPage: number
    pageSize: number
    totalCount: number
    totalPages: number
    isLoading: boolean
    hasFetched: boolean
    hasMore: boolean
    error: string | null
    lastSuccessfulFetchAt?: number | null
  }
}

export interface PaginationMeta {
  paginationKey: string
  pageFetched: 'first' | 'next' | 'prev'
  pageSize: number
  reset?: boolean
  fetchPolicy?: FetchPolicy
}

export interface EntityMeta {
  itemId?: string | string[]
  entityName?: string
}

import { DEFAULT_PAGINATION_STATE } from './constants'
export type PaginationStateType = typeof DEFAULT_PAGINATION_STATE & {
  lastSuccessfulFetchAt?: number | null
}

// Define Fetch Policies
export type FetchPolicy =
  | 'cache-first'
  | 'cache-and-network'
  | 'network-only'
  | 'cache-only'

```
src/pagination/utils.js
```javascript
/**
 * Merges two arrays of strings, ensuring uniqueness.
 * New items from arr2 are appended to arr1. Order of existing items in arr1 is preserved.
 * Order of new items from arr2 (relative to each other) is preserved.
 *
 * @param {string[]} arr1 - The base array.
 * @param {string[]} arr2 - The array to merge.
 * @returns {string[]} The merged array with unique strings.
 */
export const uniqueStringsConcatOrder = (arr1 = [], arr2 = []) => {
  if (!Array.isArray(arr1)) arr1 = []
  if (!Array.isArray(arr2)) arr2 = []

  if (!arr1.length) return [...new Set(arr2)] // Ensure arr2 is unique if arr1 is empty
  if (!arr2.length) return [...arr1]

  // Create a Set from arr1 for efficient `has` checks
  const set1 = new Set(arr1)
  // Filter items from arr2 that are not already in arr1
  const newUniqueItems = arr2.filter(item => !set1.has(item))

  return [...arr1, ...newUniqueItems]
}

/**
 * Merges two arrays of objects, ensuring uniqueness based on an identifier key.
 * New items from arr2 are appended to arr1. Order of existing items in arr1 is preserved.
 * Order of new items from arr2 (relative to each other) is preserved.
 *
 * @param {object[]} arr1 - The base array of objects.
 * @param {object[]} arr2 - The array of objects to merge.
 * @param {string} identifier - The key to use for identifying unique objects (e.g., "id", "key").
 * @returns {object[]} The merged array with unique objects.
 */
export const uniqueObjectsConcatOrder = (
  arr1 = [],
  arr2 = [],
  identifier = 'id' // Default to "id"
) => {
  if (!Array.isArray(arr1)) arr1 = []
  if (!Array.isArray(arr2)) arr2 = []

  if (!arr1.length) {
    // If arr1 is empty, ensure arr2 is unique before returning
    const uniqueArr2 = []
    const seenIds = new Set()
    for (const item of arr2) {
      const itemId = item?.[identifier]
      if (itemId !== undefined && !seenIds.has(itemId)) {
        uniqueArr2.push(item)
        seenIds.add(itemId)
      }
    }
    return uniqueArr2
  }
  if (!arr2.length) return [...arr1]

  const arr1Ids = new Set(
    arr1.map(item => item?.[identifier]).filter(id => id !== undefined)
  )

  const newUniqueItems = arr2.filter(item2 => {
    const item2Id = item2?.[identifier]
    return item2Id !== undefined && !arr1Ids.has(item2Id)
  })

  return [...arr1, ...newUniqueItems]
}

```
src/pagination/withPaginationList.ts
```typescript
// src/pagination/withPaginationList.ts
// --- NEW FILE: Extracted HOC ---
import { AppDispatch, RootState } from '@store/store'
import { makeQueryString } from '@utils/url'
import { assertInvariant } from '@utils/assert'
import { DEFAULT_PAGINATION_STATE } from './constants'
import type { PaginationMeta, PaginationStateType, FetchPolicy } from './types'
import { ThunkAction } from 'redux-thunk'

const LIST_STALE_THRESHOLD_MS = 5 * 60 * 1000

type ApiRequestThunkCreator = (params: {
  queryString?: string
  body?: Record<string, unknown> | unknown[] | undefined
  meta: PaginationMeta
}) => ThunkAction<Promise<any>, RootState, unknown, any>

interface WithPaginationListConfig<S extends RootState> {
  apiRequestFunction: ApiRequestThunkCreator // From previous refactor
  getStatePaginationData: (state: S) => Record<string, PaginationStateType>
  paginationKey: string
  pageSize?: number
  // fetchPolicy is now part of options passed to the returned thunk creator
  // fetchPolicy?: FetchPolicy; // REMOVE from HOC config if passed in options
  additionalQueryParams?: Record<string, any>
}

interface FetchListOptions {
  reset?: boolean
  fetchNext?: boolean
  fetchPrevious?: boolean
  fetchPolicy?: FetchPolicy // Add fetchPolicy here
  forceRefresh?: boolean // To explicitly bypass cache checks for this call
}

// Extracted HOC (~90 lines)
export function withPaginationList<S extends RootState>({
  apiRequestFunction,
  getStatePaginationData,
  paginationKey,
  pageSize = 20,
  additionalQueryParams = {}
}: WithPaginationListConfig<S>) {
  // --- Initial validation of HOC configuration ---
  assertInvariant(
    typeof apiRequestFunction === 'function',
    'apiRequestFunction must be a function.'
  )
  assertInvariant(
    typeof getStatePaginationData === 'function',
    'getStatePaginationData must be a function.'
  )
  assertInvariant(
    typeof paginationKey === 'string' && paginationKey.length > 0,
    'paginationKey must be a non-empty string.'
  )

  // Return the thunk action creator that takes fetch options
  return (
      options: FetchListOptions = {} // Options now include fetchPolicy
    ) =>
    (dispatch: AppDispatch, getState: () => S): Promise<any> => {
      const {
        reset = false,
        fetchNext = false,
        fetchPrevious = false,
        fetchPolicy = 'cache-first', // Default fetch policy for this specific call
        forceRefresh = false
      } = options

      const state = getState()
      const paginationStateMap = getStatePaginationData(state)
      const currentPagination =
        paginationStateMap[paginationKey] || DEFAULT_PAGINATION_STATE

      const {
        isLoading,
        nextPageKey,
        prevPageKey,
        currentPage,
        ids,
        lastSuccessfulFetchAt
      } = currentPagination

      let pageToFetch: 'first' | 'next' | 'prev' = 'first'
      let cursor: string | null = null
      let shouldProceedWithApiCall = true // Renamed from canFetch for clarity

      const isListStale =
        !lastSuccessfulFetchAt ||
        Date.now() - lastSuccessfulFetchAt > LIST_STALE_THRESHOLD_MS
      const listHasData = ids && ids.length > 0

      if (forceRefresh) {
        console.log(`Pagination [${paginationKey}]: Force refresh requested.`)
        // Proceed with API call, reset will handle 'first' page logic
      } else if (!reset) {
        // Not a reset, consider existing state and policy
        if (fetchNext) {
          if (nextPageKey) {
            pageToFetch = 'next'
            cursor = nextPageKey
          } else {
            // No next page key
            if (!isLoading)
              console.log(
                `Pagination [${paginationKey}]: Cannot fetch next, no nextPageKey.`
              )
            shouldProceedWithApiCall = false
          }
        } else if (fetchPrevious) {
          if (prevPageKey) {
            pageToFetch = 'prev'
            cursor = prevPageKey
          } else {
            // No prev page key
            if (!isLoading)
              console.log(
                `Pagination [${paginationKey}]: Cannot fetch previous, no prevPageKey.`
              )
            shouldProceedWithApiCall = false
          }
        } else {
          // Initial fetch for this key, or re-fetch current view (not next/prev)
          if (fetchPolicy === 'cache-only') {
            if (!listHasData || isListStale) {
              // Or just !listHasData if cache-only means "must exist"
              console.log(
                `Pagination [${paginationKey}]: Cache-only, but no fresh data. Not fetching.`
              )
              shouldProceedWithApiCall = false
            } else {
              console.log(
                `Pagination [${paginationKey}]: Cache-only, using existing data.`
              )
              shouldProceedWithApiCall = false // Data exists and is fresh enough, or policy is cache-only
            }
          } else if (fetchPolicy === 'cache-first') {
            if (listHasData && !isListStale) {
              console.log(
                `Pagination [${paginationKey}]: Cache-first, fresh data exists. Not fetching.`
              )
              shouldProceedWithApiCall = false
            } else {
              console.log(
                `Pagination [${paginationKey}]: Cache-first, data missing or stale. Fetching.`
              )
            }
          } else if (fetchPolicy === 'cache-and-network') {
            console.log(
              `Pagination [${paginationKey}]: Cache-and-network. Will use cache (if any) and fetch.`
            )
            // UI shows cached data, API call proceeds to update.
          } else if (fetchPolicy === 'network-only') {
            console.log(
              `Pagination [${paginationKey}]: Network-only. Fetching.`
            )
          }
        }
      } // End of !reset block. If reset=true, we generally proceed unless loading.

      // Guard Clauses
      if (isLoading && !forceRefresh) {
        // Allow forceRefresh to bypass isLoading if desired (e.g. to cancel and restart)
        // Though generally, you might want to prevent multiple fetches.
        // The original code had: !(reset && fetchPolicy === 'forceFetch')
        // Let's stick to a simpler: if loading and not forcing, don't start new.
        console.log(
          `Pagination [${paginationKey}]: Fetch blocked, already in progress.`
        )
        return Promise.resolve()
      }
      if (!shouldProceedWithApiCall && !forceRefresh) {
        // Added !forceRefresh here
        console.log(
          `Pagination [${paginationKey}]: Fetch conditions not met. Policy: ${fetchPolicy}, Reset: ${reset}`
        )
        return Promise.resolve()
      }

      // --- Prepare API Call ---
      const queryParams: Record<string, any> = {
        page_size: pageSize,
        ...additionalQueryParams
      }
      if (cursor) {
        if (pageToFetch === 'next') queryParams.next = cursor
        if (pageToFetch === 'prev') queryParams.prev = cursor
      }
      const queryString = makeQueryString(queryParams)

      const meta: PaginationMeta = {
        paginationKey,
        pageFetched: reset || forceRefresh ? 'first' : pageToFetch, // If forceRefresh, treat as fetching 'first' page of a new set
        pageSize,
        reset: reset || forceRefresh, // forceRefresh implies a reset of the current list view
        fetchPolicy: fetchPolicy // Pass policy for potential use in reducers/meta
      }

      console.log(
        `Pagination [${paginationKey}]: Dispatching API request. Query: ${queryString}, Meta:`,
        meta
      )
      return dispatch(apiRequestFunction({ queryString, meta }))
    }
}

```
src/app/+not-found.tsx
```
import { Link, Stack } from 'expo-router'
import { StyleSheet } from 'react-native'

import { ThemedText } from '@components/ThemedText'
import { ThemedView } from '@components/ThemedView'
import { Colors } from '@constants/Colors'

export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options={{ title: 'Oops!' }} />
      <ThemedView style={styles.container}>
        <ThemedText type="title">This screen doesn't exist.</ThemedText>
        <Link href="/(main)/(tabs)/" style={styles.link}>
          <ThemedText type="link">Go to home screen!</ThemedText>
        </Link>
      </ThemedView>
    </>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
    backgroundColor: Colors.light.background
  },
  link: {
    marginTop: 15,
    paddingVertical: 15
  },
  titleText: {
    fontSize: 20,
    fontWeight: 'bold',
    color: Colors.light.text
  },
  linkText: {
    fontSize: 16,
    color: Colors.light.primary
  }
})

```
src/app/_layout.tsx
```
import React, { useEffect } from 'react'
import { Slot, SplashScreen } from 'expo-router'
import { Provider, useSelector } from 'react-redux'
import { View, StyleSheet, Text } from 'react-native'
import { PersistGate } from 'redux-persist/integration/react'
import Toast from 'react-native-toast-message'
import {
  useFonts,
  Inter_400Regular,
  Inter_500Medium,
  Inter_600SemiBold,
  Inter_700Bold
} from '@expo-google-fonts/inter'

import { store, persistor } from '@store/store'
import {
  selectIsAuthenticated,
  selectAuthStatus
} from '@features/auth/authSelectors'
import { Colors } from '@constants/Colors'

import { DashboardSkeletonDesktop } from '@components/skeletons/DashboardSkeletonDesktop'
import { DashboardSkeletonMobile } from '@components/skeletons/DashboardSkeletonMobile'
import ErrorBoundary from '@/components/common/ErrorBoundary'

import { useResponsiveDimensions } from '@hooks/useResponsiveDimensions'
import useDeviceOrientation from './_hooks/useDeviceOrientation'
import useAppInitialization from './_hooks/useAppInitialization'
import useAuthRedirect from './_hooks/useAuthRedirect'

SplashScreen.preventAutoHideAsync()

const CustomSplashScreen = React.memo(() => {
  const { isDesktop } = useResponsiveDimensions()
  return isDesktop ? <DashboardSkeletonDesktop /> : <DashboardSkeletonMobile />
})

function RootLayoutNav() {
  const isAuthenticated = useSelector(selectIsAuthenticated)
  const authStatus = useSelector(selectAuthStatus)
  const isLoadingAuth = authStatus === 'idle' || authStatus === 'loading'

  useDeviceOrientation()
  useAppInitialization(authStatus)
  useAuthRedirect(isAuthenticated)

  useEffect(() => {
    if (!isLoadingAuth) {
      SplashScreen.hideAsync()
    }
  }, [isLoadingAuth])

  if (isLoadingAuth) {
    return <CustomSplashScreen />
  }

  return (
    <View style={styles.container}>
      <Slot />
    </View>
  )
}

export default function RootLayout() {
  const [fontsLoaded, fontError] = useFonts({
    'Inter-Regular': Inter_400Regular,
    'Inter-Medium': Inter_500Medium,
    'Inter-SemiBold': Inter_600SemiBold,
    'Inter-Bold': Inter_700Bold
  })

  if (!fontsLoaded && !fontError) {
    return null
  }

  if (fontError) {
    console.error('Font Loading Error:', fontError)
    return (
      <View style={styles.errorContainer}>
        <Text>Error loading fonts. Please restart the app.</Text>
      </View>
    )
  }

  return (
    <ErrorBoundary>
      <Provider store={store}>
        <PersistGate loading={<CustomSplashScreen />} persistor={persistor}>
          <RootLayoutNav />
          <Toast />
        </PersistGate>
      </Provider>
    </ErrorBoundary>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1
  },
  splashOverlay: {
    zIndex: 10,
    backgroundColor: Colors.light.background
  },
  splashContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: Colors.light.background
  },
  splashText: {
    marginTop: 15,
    fontSize: 16,
    color: Colors.light.text,
    fontFamily: 'Inter-Regular'
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20
  }
})

```
src/app/index.tsx
```
import { View, ActivityIndicator } from 'react-native'
import { Colors } from '@constants/Colors'

export default function AppEntry() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: Colors.light.background
      }}
    >
      <ActivityIndicator size="large" color={Colors.light.primary} />
    </View>
  )
}

```
src/app/_hooks/useAppInitialization.ts
```typescript
import { useEffect } from 'react'
import { useDispatch } from 'react-redux'
import { AppDispatch } from '@store/store'
import { initializeAuthThunk } from '@features/auth/authActions'
import type { ApiStatusType } from '@lib/api.d'
import { initializeDeviceToken, getDeviceToken } from '@lib/api'

export const useAppInitialization = (
  authStatus: ApiStatusType | 'sessionInvalid'
): void => {
  const dispatch = useDispatch<AppDispatch>()

  useEffect(() => {
    let isMounted = true

    const initApp = async () => {
      try {
        const token = await initializeDeviceToken()
        if (!isMounted) return
        console.log(
          'Device token initialization completed from useAppInitialization. Token:',
          token
        )

        if (authStatus === 'idle') {
          dispatch(initializeAuthThunk())
        }
      } catch (err) {
        console.error('Error during app initialization sequence:', err)
      }
    }

    if (!getDeviceToken() || authStatus === 'idle') {
      initApp()
    }

    return () => {
      isMounted = false
    }
  }, [dispatch, authStatus])
}

export default useAppInitialization

```
src/app/_hooks/useAuthRedirect.ts
```typescript
import { useEffect } from 'react'
import { useRouter, useSegments } from 'expo-router'
import {
  selectAuthStatus,
  selectInitialAuthChecked
} from '@features/auth/authSelectors'
import { useSelector } from 'react-redux'

const useAuthRedirect = (isAuthenticated: boolean) => {
  // isLoadingAuth could be !initialAuthChecked || authStatus === 'loading'
  const router = useRouter()
  const segments = useSegments()
  const initialAuthChecked = useSelector(selectInitialAuthChecked) // Get this
  const authStatus = useSelector(selectAuthStatus)

  useEffect(() => {
    // Wait for the initial check to complete and not be in an intermediate loading state
    if (!initialAuthChecked || authStatus === 'loading') {
      return
    }

    const isAuthRoute = segments[0] === '(auth)'
    const isEffectivelyRoot = segments.filter(Boolean).length === 0

    if (isAuthenticated) {
      // User is properly authenticated and session is valid
      if (isAuthRoute || isEffectivelyRoot) {
        router.replace('/(main)/(tabs)/')
      }
    } else {
      if (isEffectivelyRoot) {
        // If truly at root and not due to a failed session revalidation, go to login
        router.replace('/(auth)/login')
      }
    }
  }, [isAuthenticated, authStatus, initialAuthChecked, segments, router])
}

export default useAuthRedirect

```
src/app/_hooks/useDeviceOrientation.ts
```typescript
import { useEffect } from 'react'
import { Platform } from 'react-native'
import { getDeviceTypeAsync, DeviceType } from 'expo-device'
import { lockAsync, OrientationLock } from 'expo-screen-orientation'

/**
 * Locks the screen orientation based on the device type (Tablet: Landscape, Phone: Portrait).
 * Runs only once on component mount.
 */
const useDeviceOrientation = () => {
  useEffect(() => {
    const lockOrientation = async () => {
      if (Platform.OS !== 'ios' && Platform.OS !== 'android') return

      try {
        const deviceType = await getDeviceTypeAsync()
        if (deviceType === DeviceType.TABLET) {
          await lockAsync(OrientationLock.LANDSCAPE)
        } else {
          await lockAsync(OrientationLock.PORTRAIT_UP)
        }
      } catch (error) {
        console.error('Failed to set screen orientation:', error)
      }
    }

    lockOrientation()
  }, [])
}

export default useDeviceOrientation

```
src/app/(main)/+not-found.tsx
```
import { Link, Stack } from 'expo-router'
import { StyleSheet, View, Text } from 'react-native'
import { Colors } from '@constants/Colors'

export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options={{ title: 'Oops!' }} />
      <View style={styles.container}>
        <Text style={styles.title}>Screen Not Found</Text>
        <Text style={styles.message}>
          This screen doesn't exist within the main app section.
        </Text>
        <Link href="/(main)/(tabs)/" style={styles.link}>
          <Text style={styles.linkText}>Go to Home Screen</Text>
        </Link>
      </View>
    </>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
    backgroundColor: Colors.light.background // Use your background color
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    color: Colors.light.text, // Use your text color
    marginBottom: 15
  },
  message: {
    fontSize: 16,
    color: Colors.light.textSecondary, // Use your secondary text color
    textAlign: 'center',
    marginBottom: 20
  },
  link: {
    marginTop: 15,
    paddingVertical: 15
  },
  linkText: {
    fontSize: 14,
    color: Colors.light.primary // Use your primary/link color
  }
})

```
src/app/(main)/_layout.tsx
```
import React from 'react'
import { Stack, Slot } from 'expo-router'
import { StatusBar } from 'expo-status-bar'
import { View, StyleSheet } from 'react-native'

import { SideNavBar } from '@/components/navigation/SideNavBar'
import { Colors } from '@/constants/Colors'
import { useResponsiveDimensions } from '@/hooks/useResponsiveDimensions'

export default function MainAppLayout() {
  const { isDesktop } = useResponsiveDimensions()

  if (isDesktop) {
    return (
      <>
        <View style={styles.desktopContainer}>
          <SideNavBar />
          <View style={styles.desktopContentContainer}>
            <Slot />
          </View>
        </View>
        <StatusBar style="auto" />
      </>
    )
  }

  return (
    <>
      <Stack screenOptions={{ headerShown: false }}>
        <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
        <Stack.Screen name="article/[id]" options={{ headerShown: false }} />

        {/* Settings Screens */}
        <Stack.Screen name="settings/index" options={{ headerShown: false }} />
        <Stack.Screen
          name="settings/profile-info"
          options={{ headerShown: false }}
        />
        <Stack.Screen
          name="settings/change-password"
          options={{ headerShown: false }}
        />

        {/* Other Screens */}
        <Stack.Screen
          name="progress-details"
          options={{ headerShown: false }}
        />
        <Stack.Screen name="saved-articles" options={{ headerShown: false }} />
        <Stack.Screen name="vocabulary" options={{ headerShown: false }} />
        <Stack.Screen name="achievements" options={{ headerShown: false }} />

        {/* Exercise Screens */}
        <Stack.Screen
          name="exercises/player"
          options={{ headerShown: false }}
        />
        <Stack.Screen
          name="exercises/review-session"
          options={{ headerShown: false }}
        />
        <Stack.Screen
          name="challenges/daily"
          options={{ headerShown: false }}
        />
        {/* Add other specific exercise screens here if needed, e.g., */}
        {/* <Stack.Screen name="exercises/grammar-explorer" options={{ headerShown: false }} /> */}

        <Stack.Screen name="+not-found" />
      </Stack>
      <StatusBar style="auto" />
    </>
  )
}

const styles = StyleSheet.create({
  desktopContainer: {
    flex: 1,
    flexDirection: 'row',
    backgroundColor: Colors.light.background
  },
  desktopContentContainer: { flex: 1, height: '100%', overflow: 'hidden' }
})

```
src/app/(main)/achievements.tsx
```
import React, { useEffect, useCallback } from 'react'
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  ActivityIndicator,
  RefreshControl,
  TouchableOpacity
} from 'react-native'
import { useSafeAreaInsets } from 'react-native-safe-area-context'
import { useProtectedRoute } from '@hooks/useProtectedRoute'
import { Colors } from '@constants/Colors'
import { ScreenHeader } from '@components/common/ScreenHeader'
import { AchievementCard } from '@/components/profile/AchievementCard'
import { useResponsiveDimensions } from '@/hooks/useResponsiveDimensions'
import { useSelector, useDispatch } from 'react-redux'
import { AppDispatch, RootState } from '@/store/store'
import {
  selectEarnedAchievements,
  selectAchievementsStatus
} from '@features/achievements/achievementsSlice'
import { useRefresh } from '@hooks/useRefresh'
import { fetchEarnedAchievementsThunk } from '@/features/achievements/achievementsActions'

export default function AchievementsScreen(): React.ReactElement | null {
  const { isLoading: isAuthLoading, isAuthenticated } = useProtectedRoute()
  const dispatch = useDispatch<AppDispatch>()
  const { isDesktop } = useResponsiveDimensions()
  const insets = useSafeAreaInsets()

  const earnedAchievements = useSelector(selectEarnedAchievements)
  const achievementsStatus = useSelector(selectAchievementsStatus)

  const fetchData = useCallback(() => {
    if (
      isAuthenticated &&
      (achievementsStatus === 'idle' || achievementsStatus === 'failed')
    ) {
      dispatch(fetchEarnedAchievementsThunk())
    }
  }, [dispatch, isAuthenticated, achievementsStatus])

  useEffect(() => {
    fetchData()
  }, [fetchData])

  const [isPullRefreshing, handlePullRefresh] = useRefresh(async () => {
    if (isAuthenticated) {
      await dispatch(fetchEarnedAchievementsThunk())
    }
  })

  if (isAuthLoading || !isAuthenticated) {
    return (
      <View style={styles.fullScreenLoader}>
        <ScreenHeader
          title="Achievements"
          fallbackPath="/(main)/(tabs)/profile"
        />
        <View style={styles.loaderContainer}>
          <ActivityIndicator size="large" color={Colors.light.primary} />
        </View>
      </View>
    )
  }

  const renderEmptyList = () => {
    if (achievementsStatus === 'loading') {
      return (
        <View style={styles.centeredMessageContainer}>
          <ActivityIndicator size="large" color={Colors.light.primary} />
          <Text style={styles.infoText}>Loading achievements...</Text>
        </View>
      )
    }
    if (achievementsStatus === 'failed') {
      return (
        <View style={styles.centeredMessageContainer}>
          <Text style={styles.errorText}>Could not load achievements.</Text>
          <TouchableOpacity style={styles.retryButton} onPress={fetchData}>
            <Text style={styles.retryButtonText}>Retry</Text>
          </TouchableOpacity>
        </View>
      )
    }
    if (achievementsStatus === 'succeeded' && earnedAchievements.length === 0) {
      return (
        <View style={styles.centeredMessageContainer}>
          <Text style={styles.emptyText}>
            No achievements earned yet. Keep learning!
          </Text>
        </View>
      )
    }
    return null
  }

  const numColumns = isDesktop ? 3 : 2

  return (
    <View style={styles.container}>
      <ScreenHeader
        title="Achievements"
        fallbackPath="/(main)/(tabs)/profile"
      />
      <FlatList
        data={earnedAchievements}
        keyExtractor={item => item.achievement_id}
        renderItem={({ item }) => (
          <View style={styles.cardWrapper}>
            <AchievementCard achievement={item} />
          </View>
        )}
        contentContainerStyle={[
          styles.listContent,
          { paddingBottom: insets.bottom + 20 }
        ]}
        numColumns={numColumns}
        ListEmptyComponent={renderEmptyList}
        refreshControl={
          <RefreshControl
            refreshing={isPullRefreshing}
            onRefresh={handlePullRefresh}
            tintColor={Colors.light.primary}
          />
        }
        showsVerticalScrollIndicator={false}
      />
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.backgroundSecondary
  },
  fullScreenLoader: { flex: 1, backgroundColor: Colors.light.background },
  loaderContainer: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  listContent: {
    padding: 16
  },
  cardWrapper: {
    flex: 1 / (useResponsiveDimensions().isDesktop ? 3 : 2),
    maxWidth: '48.5%',
    margin: '0.75%'
  },
  centeredMessageContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingTop: 50,
    minHeight: 200
  },
  infoText: {
    marginTop: 10,
    fontSize: 15,
    color: Colors.light.textSecondary,
    fontFamily: 'Inter-Regular'
  },
  emptyText: {
    textAlign: 'center',
    fontSize: 15,
    color: Colors.light.textSecondary,
    fontFamily: 'Inter-Regular'
  },
  errorText: {
    textAlign: 'center',
    fontSize: 15,
    color: Colors.light.error,
    fontFamily: 'Inter-Medium',
    marginBottom: 10
  },
  retryButton: {
    marginTop: 10,
    backgroundColor: Colors.light.primary,
    paddingVertical: 8,
    paddingHorizontal: 20,
    borderRadius: 20
  },
  retryButtonText: {
    color: Colors.light.primaryContent,
    fontFamily: 'Inter-SemiBold',
    fontSize: 14
  }
})

```
src/app/(main)/index.tsx
```
import { Redirect } from 'expo-router'

// This screen acts as the entry point for the (main) group.
// It immediately redirects to the primary content area, typically the tabs.
export default function MainIndex() {
  return <Redirect href="/(main)/(tabs)/" />
}

```
src/app/(main)/progress-details.tsx
```
// src/app/(main)/progress-details.tsx
import React, { useEffect, useCallback } from 'react' // Added useEffect, useCallback
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  ActivityIndicator,
  RefreshControl // For pull-to-refresh
} from 'react-native'
import { useSafeAreaInsets } from 'react-native-safe-area-context' // For padding
import { useProtectedRoute } from '@hooks/useProtectedRoute'
import { Colors } from '@constants/Colors'
import { ScreenHeader } from '@components/common/ScreenHeader'
import { useSelector, useDispatch } from 'react-redux' // For fetching real data
import { AppDispatch, RootState } from '@/store/store'
import {
  selectProgressSummary,
  selectProgressStatus
} from '@features/progress/progressSlice'
import { ProgressSummary } from '@features/progress/types' // Import type
import { useRefresh } from '@hooks/useRefresh'
import { BarChart3, Clock4 } from 'lucide-react-native' // Example icons
import { fetchProgressThunk } from '@/features/progress/progressActions'

// Placeholder until you have a chart library.
// This function now takes actual weekly activity data.
function WeeklyActivityChartPlaceholder({
  weeklyActivity
}: {
  weeklyActivity: ProgressSummary['weekly_activity']
}): React.ReactElement {
  const maxMinutes = Math.max(...weeklyActivity.map(item => item.minutes), 0, 1) // Ensure maxMinutes is at least 1 to avoid division by zero

  return (
    <View style={styles.manualChartContainer}>
      {weeklyActivity.map(item => (
        <View key={item.day} style={styles.barContainer}>
          <View
            style={[
              styles.bar,
              {
                height: (item.minutes / maxMinutes) * 100,
                backgroundColor: Colors.light.secondaryLight
              }
            ]}
          />
          <Text style={styles.barLabel}>{item.day}</Text>
        </View>
      ))}
    </View>
  )
}

export default function ProgressDetailsScreen(): React.ReactElement | null {
  const { isLoading: isAuthLoading, isAuthenticated } = useProtectedRoute()
  const dispatch = useDispatch<AppDispatch>()
  const insets = useSafeAreaInsets()

  const progressData = useSelector(selectProgressSummary)
  const progressStatus = useSelector(selectProgressStatus)

  const fetchData = useCallback(() => {
    if (
      isAuthenticated &&
      (progressStatus === 'idle' || progressStatus === 'failed')
    ) {
      dispatch(fetchProgressThunk())
    }
  }, [dispatch, isAuthenticated, progressStatus])

  useEffect(() => {
    fetchData()
  }, [fetchData])

  const [isPullRefreshing, handlePullRefresh] = useRefresh(async () => {
    if (isAuthenticated) {
      await dispatch(fetchProgressThunk())
    }
  })

  if (isAuthLoading || !isAuthenticated) {
    return (
      <View style={styles.fullScreenLoader}>
        <ScreenHeader title="Your Progress" fallbackPath="/(main)/(tabs)/" />
        <View style={styles.loaderContainer}>
          <ActivityIndicator size="large" color={Colors.light.primary} />
        </View>
      </View>
    )
  }

  if (progressStatus === 'loading' && !progressData) {
    return (
      <View style={styles.fullScreenLoader}>
        <ScreenHeader title="Your Progress" fallbackPath="/(main)/(tabs)/" />
        <View style={styles.loaderContainer}>
          <ActivityIndicator size="large" color={Colors.light.primary} />
          <Text style={styles.infoText}>Loading progress...</Text>
        </View>
      </View>
    )
  }

  if (progressStatus === 'failed' && !progressData) {
    return (
      <View style={styles.container}>
        <ScreenHeader title="Your Progress" fallbackPath="/(main)/(tabs)/" />
        <View style={styles.centeredMessageContainer}>
          <Text style={styles.errorText}>Could not load your progress.</Text>
          <TouchableOpacity style={styles.retryButton} onPress={fetchData}>
            <Text style={styles.retryButtonText}>Retry</Text>
          </TouchableOpacity>
        </View>
      </View>
    )
  }

  if (!progressData) {
    return (
      <View style={styles.container}>
        <ScreenHeader title="Your Progress" fallbackPath="/(main)/(tabs)/" />
        <View style={styles.centeredMessageContainer}>
          <Text style={styles.infoText}>
            No progress data available yet. Start learning!
          </Text>
        </View>
      </View>
    )
  }

  return (
    <View style={styles.container}>
      <ScreenHeader title="Your Progress" fallbackPath="/(main)/(tabs)/" />
      <ScrollView
        contentContainerStyle={[
          styles.scrollContent,
          { paddingBottom: insets.bottom + 20 }
        ]}
        showsVerticalScrollIndicator={false}
        refreshControl={
          <RefreshControl
            refreshing={isPullRefreshing}
            onRefresh={handlePullRefresh}
            tintColor={Colors.light.primary}
          />
        }
      >
        {/* Overview Section */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>Overview</Text>
          <View style={styles.statRow}>
            <Text style={styles.statLabel}>Current Level:</Text>
            <Text style={styles.statValue}>
              {progressData.level} (
              {Math.round(progressData.progress_to_next_level * 100)}% to Lvl{' '}
              {progressData.level + 1})
            </Text>
          </View>
          <View style={styles.statRow}>
            <Text style={styles.statLabel}>Total Study Time:</Text>
            <Text style={styles.statValue}>
              {Math.round(progressData.total_study_time_minutes / 60)} hours (
              {progressData.total_study_time_minutes} min)
            </Text>
          </View>
          <View style={styles.statRow}>
            <Text style={styles.statLabel}>Words Learned:</Text>
            <Text style={styles.statValue}>
              {progressData.learned_words_count}
            </Text>
          </View>
          <View style={styles.statRow}>
            <Text style={styles.statLabel}>Articles Read:</Text>
            <Text style={styles.statValue}>
              {progressData.articles_read_count}
            </Text>
          </View>
          <View style={styles.statRow}>
            <Text style={styles.statLabel}>Exercises Completed:</Text>
            <Text style={styles.statValue}>
              {progressData.exercises_completed_count}
            </Text>
          </View>
          <View style={styles.statRow}>
            <Text style={styles.statLabel}>Longest Streak:</Text>
            <Text style={styles.statValue}>
              {progressData.streak.longest_streak_days} days
            </Text>
          </View>
          <View style={styles.statRow}>
            <Text style={styles.statLabel}>Current Streak:</Text>
            <Text style={styles.statValue}>
              {progressData.streak.current_streak_days} days
            </Text>
          </View>
        </View>

        {/* Weekly Activity Section */}
        {progressData.weekly_activity &&
          progressData.weekly_activity.length > 0 && (
            <View style={styles.card}>
              <View style={styles.sectionHeaderRow}>
                <Text style={styles.sectionTitle}>Weekly Activity</Text>
                <BarChart3 size={20} color={Colors.light.primary} />
              </View>
              <WeeklyActivityChartPlaceholder
                weeklyActivity={progressData.weekly_activity}
              />
            </View>
          )}

        {/* Category Progress Section */}
        {progressData.category_progress &&
          progressData.category_progress.length > 0 && (
            <View style={styles.card}>
              <Text style={styles.sectionTitle}>Category Focus</Text>
              {progressData.category_progress.map(cat => (
                <View key={cat.category} style={styles.categoryItem}>
                  <Text style={styles.categoryName}>{cat.category}</Text>
                  <View style={styles.progressBarBackground}>
                    <View
                      style={[
                        styles.progressBarFill,
                        {
                          width: `${Math.min(
                            100,
                            (cat.time_spent_minutes /
                              (progressData.total_study_time_minutes || 1)) *
                              100
                          )}%`,
                          backgroundColor: Colors.light.primary // Use a consistent color or map category to color
                        }
                      ]}
                    />
                  </View>
                  <Text style={styles.categoryPercentage}>
                    {cat.time_spent_minutes} min
                  </Text>
                </View>
              ))}
              <View style={styles.totalTimeContainer}>
                <Clock4 size={16} color={Colors.light.textSecondary} />
                <Text style={styles.totalTimeText}>
                  Total Study Time: {progressData.total_study_time_minutes}{' '}
                  minutes
                </Text>
              </View>
            </View>
          )}
      </ScrollView>
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.backgroundSecondary
  },
  fullScreenLoader: { flex: 1, backgroundColor: Colors.light.background },
  loaderContainer: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  scrollContent: {
    padding: 16 // Consistent padding
  },
  card: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 16,
    padding: 16,
    marginBottom: 20, // Spacing between cards
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3
  },
  sectionHeaderRow: {
    // For section title + icon
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12
  },
  sectionTitle: {
    fontSize: 18,
    fontFamily: 'Inter-SemiBold',
    color: Colors.light.text,
    marginBottom: 12 // If no icon in row
  },
  statRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingVertical: 6, // Spacing for each stat
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: Colors.light.borderSubtle
  },
  statRowLast: {
    // To remove border from last stat
    borderBottomWidth: 0
  },
  statLabel: {
    fontFamily: 'Inter-Regular',
    fontSize: 14,
    color: Colors.light.textSecondary
  },
  statValue: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 14,
    color: Colors.light.text
  },
  // Chart Placeholder Styles
  manualChartContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'flex-end',
    height: 130, // Adjusted height
    marginTop: 10,
    paddingHorizontal: 5
  },
  barContainer: { alignItems: 'center', flex: 1 }, // flex:1 for equal spacing
  bar: {
    width: 12, // Thinner bars
    // backgroundColor: Colors.light.secondaryLight, // Use secondary light for bars
    borderRadius: 4,
    maxHeight: 100 // Relative to container height
  },
  barLabel: {
    fontSize: 11,
    color: Colors.light.textTertiary,
    marginTop: 6,
    fontFamily: 'Inter-Regular'
  },
  // Category Progress Styles
  categoryItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
    paddingBottom: 12,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: Colors.light.borderSubtle
  },
  categoryItemLast: {
    borderBottomWidth: 0,
    marginBottom: 0,
    paddingBottom: 0
  },
  categoryName: {
    flexBasis: 100, // Give fixed basis for names
    flexShrink: 0,
    fontSize: 14,
    fontFamily: 'Inter-Medium',
    color: Colors.light.text,
    marginRight: 8
  },
  progressBarBackground: {
    flexGrow: 1, // Take remaining space
    height: 10, // Slightly thicker progress bar
    backgroundColor: Colors.light.backgroundSecondary,
    borderRadius: 5,
    overflow: 'hidden',
    marginHorizontal: 8
  },
  progressBarFill: { height: '100%', borderRadius: 5 },
  categoryPercentage: {
    // Now shows time
    fontSize: 13,
    fontFamily: 'Inter-Medium',
    color: Colors.light.textSecondary,
    textAlign: 'right',
    minWidth: 60 // Ensure space for "XX min"
  },
  totalTimeContainer: {
    // Copied from ProfileScreen for consistency
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 15,
    paddingTop: 10,
    borderTopWidth: 1,
    borderTopColor: Colors.light.borderSubtle,
    justifyContent: 'center'
  },
  totalTimeText: {
    fontFamily: 'Inter-Regular',
    fontSize: 13,
    color: Colors.light.textSecondary,
    marginLeft: 6
  },
  centeredMessageContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20
  },
  infoText: {
    marginTop: 10,
    fontSize: 15,
    color: Colors.light.textSecondary,
    fontFamily: 'Inter-Regular'
  },
  errorText: {
    textAlign: 'center',
    fontSize: 15,
    color: Colors.light.error,
    fontFamily: 'Inter-Medium',
    marginBottom: 10
  },
  retryButton: {
    marginTop: 10,
    backgroundColor: Colors.light.primary,
    paddingVertical: 8,
    paddingHorizontal: 20,
    borderRadius: 20
  },
  retryButtonText: {
    color: Colors.light.primaryContent,
    fontFamily: 'Inter-SemiBold',
    fontSize: 14
  }
})

```
src/app/(main)/saved-articles.tsx
```
import React, { useEffect, useCallback } from 'react'
import {
  View,
  Text,
  StyleSheet,
  ActivityIndicator,
  TouchableOpacity,
  RefreshControl,
  Platform,
  Alert
} from 'react-native'
import { Stack, useRouter } from 'expo-router'
import { useDispatch, useSelector } from 'react-redux'
import { useSafeAreaInsets } from 'react-native-safe-area-context'

import { AppDispatch, RootState } from '@store/store'
import {
  fetchSavedItemsThunk,
  unsaveItemThunk
} from '@features/savedItems/savedItemsActions'
import {
  selectSavedItemsStatus,
  selectHydratedSavedArticles
} from '@features/savedItems/savedItemsSlice'
import { useRefresh } from '@hooks/useRefresh'
import { Colors } from '@constants/Colors'
import { ArticleCardWithThumbnail } from '@components/reader/ArticleCardWithThumbnail'
import { XCircle, ArrowLeft, BookOpen } from 'lucide-react-native'
import { useResponsiveDimensions } from '@/hooks/useResponsiveDimensions'
import type { Article } from '@/features/articles/types'
import { CustomFlatList } from '@/components/common/CustomFlatList'

export default function LibraryScreen(): React.ReactElement {
  const dispatch = useDispatch<AppDispatch>()
  const { isDesktop } = useResponsiveDimensions()
  const savedArticles = useSelector(selectHydratedSavedArticles)
  const router = useRouter()
  const insets = useSafeAreaInsets()
  const status = useSelector(selectSavedItemsStatus)
  const error = useSelector((state: RootState) => state.savedItems.error)

  const fetchData = useCallback(() => {
    return dispatch(fetchSavedItemsThunk())
  }, [dispatch])

  useEffect(() => {
    if (status === 'idle' || status === 'failed') {
      fetchData()
    }
  }, [dispatch, status, fetchData])

  const [isRefreshing, handleRefresh] = useRefresh(fetchData)

  const handleGoBack = useCallback(() => {
    if (router.canGoBack()) {
      router.back()
    } else {
      router.replace('/(main)/(tabs)/')
    }
  }, [router])

  const handleUnsave = useCallback(
    async (itemType: string, itemId: string, itemTitle?: string) => {
      Alert.alert(
        'Confirm Unsave',
        `Are you sure you want to remove "${
          itemTitle || 'this item'
        }" from your library?`,
        [
          { text: 'Cancel', style: 'cancel' },
          {
            text: 'Unsave',
            style: 'destructive',
            onPress: async () => {
              try {
                await dispatch(
                  unsaveItemThunk({ item_type: itemType, item_id: itemId })
                )
              } catch (err: any) {
                console.error('Unsave failed:', err)
                Alert.alert(
                  'Error',
                  err?.message || 'Could not remove item. Please try again.'
                )
              }
            }
          }
        ]
      )
    },
    [dispatch]
  )

  const renderSavedArticle = ({
    item
  }: {
    item: Article
  }): React.ReactElement => {
    return (
      <View
        style={
          isDesktop ? styles.itemContainerDesktop : styles.itemContainerMobile
        }
      >
        <ArticleCardWithThumbnail
          article={item}
          size={isDesktop ? 'medium' : 'small'}
        />
        <TouchableOpacity
          style={styles.unsaveButton}
          onPress={() => handleUnsave('ArticleVersion', item.id, item.title)}
          accessibilityLabel={`Unsave article ${item.title}`}
        >
          <XCircle size={isDesktop ? 24 : 22} color={Colors.light.error} />
        </TouchableOpacity>
      </View>
    )
  }

  const ListEmptyComponentContent = () => (
    <View style={styles.centeredMessageContainer}>
      <BookOpen
        size={48}
        color={Colors.light.textTertiary}
        style={{ marginBottom: 16 }}
      />
      <Text style={styles.emptyText}>No saved items yet.</Text>
      <Text style={styles.emptySubText}>
        Articles you save will appear here.
      </Text>
      <TouchableOpacity
        style={styles.browseButton}
        onPress={() => router.push('/(main)/(tabs)/reader')}
      >
        <Text style={styles.browseButtonText}>Browse Articles</Text>
      </TouchableOpacity>
    </View>
  )

  const renderContent = () => {
    if (status === 'loading' && savedArticles.length === 0) {
      return (
        <View style={styles.centeredMessageContainer}>
          <ActivityIndicator size="large" color={Colors.light.primary} />
        </View>
      )
    }
    if (status === 'failed' && savedArticles.length === 0 && error) {
      return (
        <View style={styles.centeredMessageContainer}>
          <Text style={styles.errorText}>Error loading saved items.</Text>
          <Text style={styles.errorSubText}>{error}</Text>
          <TouchableOpacity style={styles.retryButton} onPress={fetchData}>
            <Text style={styles.retryButtonText}>Retry</Text>
          </TouchableOpacity>
        </View>
      )
    }

    const numColumns = isDesktop ? (Platform.OS === 'web' ? 4 : 3) : 1

    return (
      <CustomFlatList
        data={savedArticles}
        renderItem={renderSavedArticle}
        keyExtractor={item => item.id}
        containerStyle={styles.flatListContainer}
        contentContainerStyle={[
          styles.listContent,
          { paddingBottom: insets.bottom + 20 },
          isDesktop && styles.listContentDesktop
        ]}
        numColumns={numColumns}
        refreshControl={
          <RefreshControl
            refreshing={isRefreshing}
            onRefresh={handleRefresh}
            colors={[Colors.light.primary]}
            tintColor={Colors.light.primary}
          />
        }
        ListEmptyComponent={ListEmptyComponentContent}
      />
    )
  }

  return (
    <>
      <Stack.Screen options={{ title: 'My Library' }} />
      <View style={styles.container}>
        {renderContent()}
        <TouchableOpacity
          style={[
            styles.floatingBackButton,
            { top: insets.top + (Platform.OS === 'ios' ? 10 : 15) }
          ]}
          onPress={handleGoBack}
          accessibilityLabel="Go back"
          accessibilityRole="button"
        >
          <ArrowLeft size={22} color={Colors.light.text} />
        </TouchableOpacity>
      </View>
    </>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.backgroundSecondary
  },
  centeredMessageContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20
  },
  flatListContainer: {
    flex: 1
  },
  listContent: {
    paddingHorizontal: Platform.OS === 'web' ? 0 : 12,
    paddingTop: Platform.OS === 'ios' ? 55 : 65
  },
  listContentDesktop: {
    maxWidth: 1200,
    alignSelf: 'center',
    paddingHorizontal: 20
  },
  itemContainerMobile: {
    position: 'relative',
    marginBottom: 16,
    alignItems: 'center'
  },
  itemContainerDesktop: {
    position: 'relative',
    flex: 1,
    margin: 8,
    maxWidth: '100%'
  },
  unsaveButton: {
    position: 'absolute',
    top: 10,
    right: 10,
    backgroundColor: Colors.light.cardBackground + 'CC',
    padding: 8,
    borderRadius: 20,
    zIndex: 1,
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 2
  },
  errorText: {
    fontFamily: 'Inter-SemiBold',
    color: Colors.light.error,
    marginBottom: 5,
    textAlign: 'center',
    fontSize: 17
  },
  errorSubText: {
    fontFamily: 'Inter-Regular',
    color: Colors.light.textSecondary,
    marginBottom: 15,
    textAlign: 'center',
    fontSize: 14
  },
  retryButton: {
    backgroundColor: Colors.light.primary,
    paddingVertical: 10,
    paddingHorizontal: 25,
    borderRadius: 25
  },
  retryButtonText: {
    color: Colors.light.primaryContent,
    fontSize: 15,
    fontFamily: 'Inter-SemiBold'
  },
  emptyText: {
    fontSize: 18,
    fontFamily: 'Inter-SemiBold',
    color: Colors.light.textSecondary,
    marginBottom: 8,
    textAlign: 'center'
  },
  emptySubText: {
    fontSize: 14,
    fontFamily: 'Inter-Regular',
    color: Colors.light.textTertiary,
    textAlign: 'center',
    marginBottom: 20
  },
  browseButton: {
    backgroundColor: Colors.light.primary,
    paddingVertical: 10,
    paddingHorizontal: 25,
    borderRadius: 25
  },
  browseButtonText: {
    color: Colors.light.primaryContent,
    fontFamily: 'Inter-SemiBold',
    fontSize: 15
  },
  floatingBackButton: {
    position: 'absolute',
    left: 15,
    zIndex: 10,
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: Colors.light.cardBackground + 'E6',
    alignItems: 'center',
    justifyContent: 'center',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 3,
    elevation: 3
  }
})

```
src/app/(main)/vocabulary.tsx
```
import React, { useEffect, useCallback } from 'react'
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  ActivityIndicator,
  TouchableOpacity,
  RefreshControl,
  Alert
} from 'react-native'
import { useSafeAreaInsets } from 'react-native-safe-area-context'
import { useProtectedRoute } from '@hooks/useProtectedRoute'
import { Colors } from '@constants/Colors'
import { ScreenHeader } from '@components/common/ScreenHeader'
import { Volume2, BookHeart } from 'lucide-react-native'
import { useSelector, useDispatch } from 'react-redux'
import { AppDispatch, RootState } from '@/store/store'
import { fetchVocabularyThunk } from '@features/vocabulary/vocabularyActions'
import { UserVocabularyEntry } from '@features/vocabulary/types'
import { useRefresh } from '@hooks/useRefresh'
import {
  selectAllVocabulary,
  selectVocabularyListStatus
} from '@/features/vocabulary/vocabularySlice'

export default function VocabularyScreen(): React.ReactElement | null {
  const { isLoading: isAuthLoading, isAuthenticated } = useProtectedRoute()
  const dispatch = useDispatch<AppDispatch>()
  const insets = useSafeAreaInsets()

  const vocabularyEntries = useSelector(selectAllVocabulary)
  const vocabularyStatus = useSelector(selectVocabularyListStatus)
  const vocabularyError = useSelector(
    (state: RootState) => state.vocabulary.error
  )

  const fetchData = useCallback(() => {
    if (
      isAuthenticated &&
      (vocabularyStatus === 'idle' || vocabularyStatus === 'failed')
    ) {
      dispatch(fetchVocabularyThunk())
    }
  }, [dispatch, isAuthenticated, vocabularyStatus])

  useEffect(() => {
    fetchData()
  }, [fetchData])

  const [isPullRefreshing, handlePullRefresh] = useRefresh(async () => {
    if (isAuthenticated) {
      await dispatch(fetchVocabularyThunk())
    }
  })

  if (isAuthLoading || !isAuthenticated) {
    return (
      <View style={styles.fullScreenLoader}>
        <ScreenHeader
          title="My Vocabulary"
          fallbackPath="/(main)/(tabs)/profile"
        />
        <View style={styles.loaderContainer}>
          <ActivityIndicator size="large" color={Colors.light.primary} />
        </View>
      </View>
    )
  }

  const playPronunciation = (word: string) => {
    Alert.alert(
      'Play Audio',
      `Playing pronunciation for: ${word} (Not Implemented)`
    )
  }

  const renderItem = ({
    item
  }: {
    item: UserVocabularyEntry
  }): React.ReactElement => (
    <View style={styles.itemContainer}>
      <View style={styles.wordRow}>
        <View style={styles.wordTextContainer}>
          <Text style={styles.finnishWord}>
            {item.base_word?.word_fi || item.base_word_id}
          </Text>
          {item.base_word?.pronunciation_ipa && (
            <Text style={styles.pronunciation}>
              {item.base_word.pronunciation_ipa}
            </Text>
          )}
        </View>
        <TouchableOpacity
          onPress={() =>
            playPronunciation(item.base_word?.word_fi || item.base_word_id)
          }
          style={styles.audioButton}
          accessibilityLabel={`Play audio for ${item.base_word?.word_fi}`}
        >
          <Volume2 size={20} color={Colors.light.primary} />
        </TouchableOpacity>
      </View>
      <Text style={styles.englishWord}>
        {item.base_word?.basic_definition_en || 'No translation available.'}
      </Text>
    </View>
  )

  const renderEmptyList = () => {
    if (vocabularyStatus === 'loading') {
      return (
        <View style={styles.centeredMessageContainer}>
          <ActivityIndicator size="large" color={Colors.light.primary} />
          <Text style={styles.infoText}>Loading vocabulary...</Text>
        </View>
      )
    }
    if (vocabularyStatus === 'failed') {
      return (
        <View style={styles.centeredMessageContainer}>
          <Text style={styles.errorText}>Could not load your vocabulary.</Text>
          {vocabularyError && (
            <Text style={styles.errorSubText}>{vocabularyError}</Text>
          )}
          <TouchableOpacity style={styles.retryButton} onPress={fetchData}>
            <Text style={styles.retryButtonText}>Retry</Text>
          </TouchableOpacity>
        </View>
      )
    }
    if (vocabularyStatus === 'succeeded' && vocabularyEntries.length === 0) {
      return (
        <View style={styles.centeredMessageContainer}>
          <BookHeart
            size={48}
            color={Colors.light.textTertiary}
            style={{ marginBottom: 16 }}
          />
          <Text style={styles.emptyText}>
            You haven't saved any vocabulary yet.
          </Text>
          <Text style={styles.emptySubText}>
            Words you save or mark for learning will appear here.
          </Text>
        </View>
      )
    }
    return null
  }

  return (
    <View style={styles.container}>
      <ScreenHeader
        title="My Vocabulary"
        fallbackPath="/(main)/(tabs)/profile"
      />
      <FlatList
        data={vocabularyEntries}
        keyExtractor={item => item.base_word_id}
        renderItem={renderItem}
        contentContainerStyle={[
          styles.listContent,
          { paddingBottom: insets.bottom + 20 }
        ]}
        ListEmptyComponent={renderEmptyList}
        showsVerticalScrollIndicator={false}
        refreshControl={
          <RefreshControl
            refreshing={isPullRefreshing}
            onRefresh={handlePullRefresh}
            tintColor={Colors.light.primary}
          />
        }
      />
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.backgroundSecondary
  },
  fullScreenLoader: { flex: 1, backgroundColor: Colors.light.background },
  loaderContainer: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  listContent: {
    padding: 16 // Consistent padding
  },
  itemContainer: {
    backgroundColor: Colors.light.cardBackground,
    padding: 16,
    borderRadius: 12, // More rounded
    marginBottom: 12,
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.08,
    shadowRadius: 4,
    elevation: 2,
    borderWidth: 1,
    borderColor: Colors.light.borderSubtle
  },
  wordRow: {
    flexDirection: 'row',
    alignItems: 'flex-start', // Align start for potentially multi-line words
    justifyContent: 'space-between',
    marginBottom: 6
  },
  wordTextContainer: {
    flex: 1, // Allow text to take space
    marginRight: 8
  },
  finnishWord: {
    fontSize: 18,
    fontFamily: 'Inter-SemiBold',
    color: Colors.light.text,
    flexShrink: 1 // Allow shrinking if too long
  },
  englishWord: {
    fontSize: 15,
    fontFamily: 'Inter-Medium',
    color: Colors.light.primary, // Use primary color for translation
    lineHeight: 20
  },
  pronunciation: {
    fontSize: 13,
    fontFamily: 'Inter-Regular',
    color: Colors.light.textSecondary,
    fontStyle: 'italic',
    marginTop: 2
  },
  audioButton: {
    padding: 6, // Good tap area
    marginTop: -4 // Align nicely with potentially taller Finnish word
  },
  centeredMessageContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
    minHeight: 250
  },
  infoText: {
    marginTop: 10,
    fontSize: 15,
    color: Colors.light.textSecondary,
    fontFamily: 'Inter-Regular'
  },
  emptyText: {
    textAlign: 'center',
    fontSize: 17,
    fontFamily: 'Inter-SemiBold',
    color: Colors.light.textSecondary,
    marginBottom: 8
  },
  emptySubText: {
    textAlign: 'center',
    fontSize: 14,
    fontFamily: 'Inter-Regular',
    color: Colors.light.textTertiary,
    paddingHorizontal: 20,
    lineHeight: 20
  },
  errorText: {
    textAlign: 'center',
    fontSize: 16,
    color: Colors.light.error,
    fontFamily: 'Inter-Medium',
    marginBottom: 5
  },
  errorSubText: {
    textAlign: 'center',
    fontSize: 13,
    color: Colors.light.textSecondary,
    fontFamily: 'Inter-Regular',
    marginBottom: 15
  },
  retryButton: {
    marginTop: 10,
    backgroundColor: Colors.light.primary,
    paddingVertical: 8,
    paddingHorizontal: 20,
    borderRadius: 20
  },
  retryButtonText: {
    color: Colors.light.primaryContent,
    fontFamily: 'Inter-SemiBold',
    fontSize: 14
  }
})

```
src/app/(main)/reader/[id].tsx
```
import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react'
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Pressable,
  StatusBar,
  RefreshControl,
  Platform,
  Alert
} from 'react-native'
import { useLocalSearchParams, Stack, useRouter } from 'expo-router'
import { SafeAreaView, useSafeAreaInsets } from 'react-native-safe-area-context'
import { LinearGradient } from 'expo-linear-gradient'
import { useSelector, useDispatch } from 'react-redux'

import { Colors } from '@constants/Colors'
import { useResponsiveDimensions } from '@hooks/useResponsiveDimensions'
import { AppDispatch, RootState } from '@store/store'
import { useRequireAuthAction } from '@hooks/useRequireAuthAction'
import { format } from 'date-fns'
import { selectIsItemSaved } from '@features/savedItems/savedItemsSlice'
import {
  saveItemThunk,
  unsaveItemThunk
} from '@features/savedItems/savedItemsActions'
import { showAuthDebugToast } from '@lib/debugToast'
import { ArticleHeaderControls } from '@/components/reader/ArticleHeaderControls'
import { ArticleMetadataDisplay } from '@/components/reader/ArticleMetadataDisplay'
import { ArticleAudioPlayer } from '@/components/reader/ArticleAudioPlayer'
import { ArticleParagraphsList } from '@/components/reader/ArticleParagraphsList'
import { ArticleVocabularySection } from '@/components/reader/ArticleVocabularySection'
import {
  InteractiveDetailPopup,
  PopupContentMode
} from '@/components/reader/InteractiveDetailPopup'
import {
  ArticleParagraph,
  WordOccurrence,
  GrammarOccurrence,
  BaseWordDetail,
  GrammarDetail,
  Article
} from '@features/articles/types'
import { useRefresh } from '@hooks/useRefresh'
import { useEntity } from '@/hooks/useEntity'
import { ARTICLE_SCHEMA_SINGLE } from '@entities/schemas'
import { fetchEntityByIdIfNeededThunk } from '@/features/entities/entityActions'
import { ArrowLeft } from 'lucide-react-native'
import { FeaturedArticles } from '@/components/home/FeaturedArticles'
import { fetchArticles } from '@/features/articles/articlesActions'
import { selectPaginatedData } from '@/pagination/selectors'

const ARTICLE_SCREEN_FEATURED_ARTICLES_KEY = 'article-screen-featured'

export default function ArticleScreen(): React.ReactElement {
  const { id } = useLocalSearchParams<{ id: string }>()
  const router = useRouter()
  const dispatch = useDispatch<AppDispatch>()
  const { isDesktop } = useResponsiveDimensions()
  const insets = useSafeAreaInsets()

  const [hasAttemptedFullFetch, setHasAttemptedFullFetch] = useState(false)

  const {
    data: article,
    isLoading: isLoadingArticleEntity,
    error: articleEntityError
  } = useEntity<Article>(
    'articles',
    id,
    ARTICLE_SCHEMA_SINGLE,
    articleId => `/news/articles/${articleId}`,
    {
      fetchPolicy: 'cache-first'
    }
  )

  useEffect(() => {
    if (!id || !dispatch) return

    if (
      article &&
      (!article.paragraphs || article.paragraphs.length === 0) &&
      !hasAttemptedFullFetch &&
      !isLoadingArticleEntity
    ) {
      console.log(
        `Article ${id} is in cache but seems incomplete (no paragraphs). Forcing full fetch.`
      )
      setHasAttemptedFullFetch(true)
      dispatch(
        fetchEntityByIdIfNeededThunk({
          entityType: 'articles',
          id,
          endpoint: `/news/articles/${id}`,
          schema: ARTICLE_SCHEMA_SINGLE,
          forceRefresh: true
        })
      )
    } else if (
      !article &&
      !isLoadingArticleEntity &&
      !articleEntityError &&
      !hasAttemptedFullFetch
    ) {
      console.log(
        `Article ${id} not in cache. Triggering initial fetch via useEntity (or forced if needed).`
      )
      setHasAttemptedFullFetch(true)
      dispatch(
        fetchEntityByIdIfNeededThunk({
          entityType: 'articles',
          id,
          endpoint: `/news/articles/${id}`,
          schema: ARTICLE_SCHEMA_SINGLE,
          forceRefresh: true
        })
      )
    }
  }, [
    id,
    article,
    dispatch,
    hasAttemptedFullFetch,
    isLoadingArticleEntity,
    articleEntityError
  ])

  const { data: allFeaturedArticles, pagination: featuredArticlesPagination } =
    useSelector((state: RootState) =>
      selectPaginatedData(
        'articles',
        'articlePagination',
        ARTICLE_SCREEN_FEATURED_ARTICLES_KEY,
        false
      )(state)
    )

  const featuredArticles = useMemo(
    () => allFeaturedArticles.filter(a => a.id !== id),
    [allFeaturedArticles, id]
  )

  const handleLoadMoreFeaturedArticles = useCallback(() => {
    if (
      !featuredArticlesPagination.isLoading &&
      featuredArticlesPagination.hasMore
    ) {
      dispatch(
        fetchArticles(ARTICLE_SCREEN_FEATURED_ARTICLES_KEY, { fetchNext: true })
      )
    }
  }, [dispatch, featuredArticlesPagination])

  useEffect(() => {
    if (
      !featuredArticlesPagination.isLoading &&
      !featuredArticlesPagination.hasFetched
    ) {
      dispatch(
        fetchArticles(ARTICLE_SCREEN_FEATURED_ARTICLES_KEY, { reset: true })
      )
    }
  }, [dispatch, featuredArticlesPagination])

  const handleRefreshAction = useCallback(() => {
    const promises: Promise<any>[] = []
    if (id) {
      setHasAttemptedFullFetch(true)
      promises.push(
        dispatch(
          fetchEntityByIdIfNeededThunk({
            entityType: 'articles',
            id,
            endpoint: `/news/articles/${id}`,
            schema: ARTICLE_SCHEMA_SINGLE,
            forceRefresh: true
          })
        )
      )
    }
    promises.push(
      dispatch(
        fetchArticles(ARTICLE_SCREEN_FEATURED_ARTICLES_KEY, {
          reset: true,
          forceRefresh: true
        })
      )
    )
    return Promise.all(promises)
  }, [dispatch, id])

  const [isPullRefreshing, handlePullRefresh] = useRefresh(handleRefreshAction)

  const publicationDateFormatted = useMemo(() => {
    if (!article?.publication_date) return ''
    return format(new Date(article.publication_date), 'MMMM dd, yyyy')
  }, [article?.publication_date])

  const [popupVisible, setPopupVisible] = useState(false)
  const [popupContentMode, setPopupContentMode] =
    useState<PopupContentMode>(null)
  const [currentWordOccForPopup, setCurrentWordOccForPopup] =
    useState<WordOccurrence | null>(null)
  const [currentGrammarOccForPopup, setCurrentGrammarOccForPopup] =
    useState<GrammarOccurrence | null>(null)
  const [focusedOccurrenceId, setFocusedOccurrenceId] = useState<string | null>(
    null
  )
  const [popupPositionInternal, setPopupPositionInternal] = useState<{
    screenX: number
    screenY: number
    width: number
    height: number
  } | null>(null)
  const scrollViewRef = useRef<ScrollView>(null)

  const handleGoBack = () => {
    if (router.canGoBack()) router.back()
    else router.replace('/(main)/(tabs)/reader')
  }
  const itemType = 'ArticleVersion'
  const itemId = id || ''
  const isSavedInStore = useSelector((state: RootState) =>
    selectIsItemSaved(state, itemType, itemId)
  )
  const [isOptimisticallySaved, setIsOptimisticallySaved] =
    useState(isSavedInStore)
  const [isSaveLoading, setIsSaveLoading] = useState(false)
  useEffect(() => {
    setIsOptimisticallySaved(isSavedInStore)
  }, [isSavedInStore])
  const handleSave = async () => {
    if (!itemId) return
    setIsSaveLoading(true)
    setIsOptimisticallySaved(true)
    showAuthDebugToast('info', 'Saving article...')
    try {
      await dispatch(saveItemThunk({ item_type: itemType, item_id: itemId }))
      showAuthDebugToast('success', 'Article Saved')
    } catch (err: any) {
      console.error('Save failed:', err)
      showAuthDebugToast(
        'error',
        'Save Failed',
        err?.message || 'Could not save article.'
      )
      setIsOptimisticallySaved(false)
    } finally {
      setIsSaveLoading(false)
    }
  }

  const handleUnsave = async () => {
    if (!itemId) return
    setIsSaveLoading(true)
    setIsOptimisticallySaved(false)
    showAuthDebugToast('info', 'Unsacing article...')
    try {
      await dispatch(unsaveItemThunk({ item_type: itemType, item_id: itemId }))
      showAuthDebugToast('success', 'Article Unsaved')
    } catch (err: any) {
      console.error('Unsave failed:', err)
      showAuthDebugToast(
        'error',
        'Unsave Failed',
        err?.message || 'Could not unsave article.'
      )
      setIsOptimisticallySaved(true)
    } finally {
      setIsSaveLoading(false)
    }
  }
  const handleToggleSave = useRequireAuthAction(() => {
    if (isOptimisticallySaved) {
      handleUnsave()
    } else {
      handleSave()
    }
  }, 'Login to save this article?.')

  const showPopupForOccurrence = useCallback(
    (
      layout: {
        pageX: number
        pageY: number
        width: number
        height: number
      } | null,
      mode: 'word' | 'grammar',
      occurrenceId: string
    ) => {
      if (layout && (layout.width > 0 || layout.height > 0)) {
        console.log(
          `Showing popup for ${mode} occurrence ${occurrenceId} at position:`,
          layout
        )
        const statusBarHeight = StatusBar.currentHeight || 0

        setPopupPositionInternal({
          screenX: layout.pageX,
          screenY: layout.pageY + statusBarHeight,
          width: layout.width,
          height: layout.height
        })
        setPopupContentMode(mode)
        setFocusedOccurrenceId(occurrenceId)
        setPopupVisible(true)
      } else {
        console.warn('Could not get layout for popup from TappableTextSegment.')
      }
    },
    []
  )

  const handleWordSelect = useCallback(
    (occurrence: WordOccurrence, paragraph: ArticleParagraph, layout) => {
      setCurrentWordOccForPopup(occurrence)
      setCurrentGrammarOccForPopup(null)
      showPopupForOccurrence(layout, 'word', occurrence.occurrence_id)
    },
    [showPopupForOccurrence]
  )

  const handleGrammarSelect = useCallback(
    (occurrence: GrammarOccurrence, paragraph: ArticleParagraph, layout) => {
      setCurrentWordOccForPopup(null)
      setCurrentGrammarOccForPopup(occurrence)
      showPopupForOccurrence(layout, 'grammar', occurrence.occurrence_id)
    },
    [showPopupForOccurrence]
  )

  const handleClosePopup = useCallback(() => {
    setPopupVisible(false)
    setFocusedOccurrenceId(null)
  }, [])

  const saveWordAction = useCallback(
    (baseWord: BaseWordDetail) => {
      console.log(
        'Save Word action triggered for:',
        baseWord.word_fi,
        baseWord.base_word_id
      )
      showAuthDebugToast('info', 'Save Word', `Word: ${baseWord.word_fi}`)
    },
    [handleClosePopup]
  )

  const handleSaveWord = useRequireAuthAction(
    saveWordAction,
    'Login to save vocabulary.'
  )
  const saveGrammarAction = useCallback(
    (grammarItem: GrammarDetail) => {
      console.log(
        'Save Grammar action triggered for:',
        grammarItem.name_en,
        grammarItem.grammar_id
      )
      showAuthDebugToast(
        'info',
        'Save Grammar Note',
        `Note: ${grammarItem.name_en}`
      )
    },
    [handleClosePopup]
  )
  const handleSaveGrammar = useRequireAuthAction(
    saveGrammarAction,
    'Login to save grammar notes.'
  )

  const handleBrandPress = () => {
    Alert.alert(`Brand: ${article?.brand?.display_name} (Not Implemented)`)
  }
  const handleShare = () => {
    Alert.alert('Share action not implemented')
  }
  const handlePlayArticleAudio = () => {
    Alert.alert('Full article audio playback not implemented yet.')
  }

  const isLoading =
    isLoadingArticleEntity ||
    (hasAttemptedFullFetch && !article?.paragraphs && !articleEntityError)
  const displayError = articleEntityError

  if (isLoading && !article && !displayError) {
    return (
      <SafeAreaView style={styles.container} edges={['top', 'bottom']}>
        <View style={styles.centered}>
          <ActivityIndicator size="large" color={Colors.light.primary} />
        </View>
      </SafeAreaView>
    )
  }

  if (displayError && !article) {
    return (
      <SafeAreaView style={styles.container} edges={['top', 'bottom']}>
        <View
          style={[
            styles.customHeaderMinimal,
            { paddingTop: Platform.OS === 'android' ? insets.top : 0 }
          ]}
        >
          <TouchableOpacity
            onPress={handleGoBack}
            style={styles.headerBackButtonMinimal}
          >
            <ArrowLeft size={22} color={Colors.common.white} />
          </TouchableOpacity>
        </View>
        <View style={styles.centered}>
          <Text style={styles.errorText}>
            Failed to load article: {displayError}
          </Text>
          <TouchableOpacity
            onPress={handleRefreshAction}
            style={styles.retryButton}
          >
            <Text style={styles.retryButtonText}>Retry</Text>
          </TouchableOpacity>
        </View>
      </SafeAreaView>
    )
  }

  if (
    article &&
    (!article.paragraphs || article.paragraphs.length === 0) &&
    isLoading
  ) {
    return (
      <SafeAreaView style={styles.container} edges={['top', 'bottom']}>
        <View
          style={[
            styles.customHeaderMinimal,
            { paddingTop: Platform.OS === 'android' ? insets.top : 0 }
          ]}
        >
          <TouchableOpacity
            onPress={handleGoBack}
            style={styles.headerBackButtonMinimal}
          >
            <ArrowLeft size={22} color={Colors.common.white} />
          </TouchableOpacity>
          <View style={{ width: 30 }} />
        </View>
        <View style={styles.centered}>
          <ActivityIndicator size="large" color={Colors.light.primary} />
          <Text style={{ marginTop: 10, color: Colors.light.textSecondary }}>
            Loading full article content...
          </Text>
        </View>
      </SafeAreaView>
    )
  }

  if (!article) {
    return (
      <SafeAreaView style={styles.container} edges={['top', 'bottom']}>
        <View
          style={[
            styles.customHeaderMinimal,
            { paddingTop: Platform.OS === 'android' ? insets.top : 0 }
          ]}
        >
          <TouchableOpacity
            onPress={handleGoBack}
            style={styles.headerBackButtonMinimal}
          >
            <ArrowLeft size={22} color={Colors.common.white} />
          </TouchableOpacity>
        </View>
        <View style={styles.centered}>
          <Text style={styles.errorText}>Article not found.</Text>
        </View>
      </SafeAreaView>
    )
  }

  return (
    <>
      <Stack.Screen options={{ headerShown: false }} />
      <SafeAreaView style={styles.container} edges={['top']}>
        <View
          style={[styles.articleHeaderControlsContainer, { top: insets.top }]}
        >
          <ArticleHeaderControls
            onGoBack={handleGoBack}
            onToggleSave={handleToggleSave}
            onShare={handleShare}
            isSaveLoading={isSaveLoading}
            isArticleSaved={isOptimisticallySaved}
            isDesktop={isDesktop}
          />
        </View>

        <ScrollView
          ref={scrollViewRef}
          contentContainerStyle={[
            styles.scrollContent,
            isDesktop && styles.wideScreenContent,
            { paddingBottom: insets.bottom + 20 }
          ]}
          showsVerticalScrollIndicator={false}
          refreshControl={
            <RefreshControl
              refreshing={isPullRefreshing}
              onRefresh={handlePullRefresh}
              tintColor={Colors.light.primary}
              colors={[Colors.light.primary]}
            />
          }
        >
          <LinearGradient
            colors={['rgba(0,0,0,0.2)', Colors.common.transparent]}
            style={styles.headerGradient}
          />

          <View
            style={[
              styles.articleContentContainer,
              isDesktop && styles.wideScreenArticleContainer
            ]}
          >
            <ArticleMetadataDisplay
              article={article}
              publicationDateFormatted={publicationDateFormatted}
              onBrandPress={handleBrandPress}
              isDesktop={isDesktop}
            />
            {(!article.paragraphs || article.paragraphs.length === 0) &&
              !isLoading && (
                <View style={styles.centered}>
                  <Text style={styles.errorText}>
                    Article content (paragraphs) could not be loaded.
                  </Text>
                </View>
              )}
            {article.id &&
              article.paragraphs &&
              article.paragraphs.length > 0 && (
                <>
                  <ArticleAudioPlayer
                    articleId={article.id}
                    onPlayPress={handlePlayArticleAudio}
                  />
                  <ArticleParagraphsList
                    paragraphs={article.paragraphs}
                    onWordSelect={handleWordSelect}
                    onGrammarSelect={handleGrammarSelect}
                    focusedOccurrenceId={focusedOccurrenceId}
                  />
                </>
              )}
            {article.brand?.display_name && (
              <View style={styles.sourceContainer}>
                <Text style={styles.sourceText}>
                  Source: {article.brand.display_name}
                </Text>
              </View>
            )}
          </View>

          {article.vocabulary && article.vocabulary.length > 0 && (
            <ArticleVocabularySection
              vocabulary={article.vocabulary}
              isDesktop={isDesktop}
            />
          )}

          <FeaturedArticles
            articles={featuredArticles}
            pagination={featuredArticlesPagination}
            onLoadMore={handleLoadMoreFeaturedArticles}
            marginHorizontal={20}
            title="You Might Also Like"
          />
        </ScrollView>

        {popupVisible && popupPositionInternal && (
          <>
            <Pressable
              style={StyleSheet.absoluteFill}
              onPress={handleClosePopup}
              accessibilityLabel="Close popup"
              accessibilityRole="button"
            />
            <InteractiveDetailPopup
              isVisible={popupVisible}
              contentMode={popupContentMode}
              wordOccurrenceData={currentWordOccForPopup}
              grammarOccurrenceData={currentGrammarOccForPopup}
              popupPosition={popupPositionInternal}
              onClose={handleClosePopup}
              onSaveWord={handleSaveWord}
              onSaveGrammar={handleSaveGrammar}
              onLearnMoreWord={baseWord =>
                Alert.alert('Learn More', baseWord.word_fi)
              }
              onLearnMoreGrammar={grammar =>
                Alert.alert('Learn More', grammar.name_en)
              }
              isDesktop={isDesktop}
            />
          </>
        )}
      </SafeAreaView>
    </>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background
  },
  centered: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20
  },
  customHeaderMinimal: {
    flexDirection: 'row',
    paddingHorizontal: 16,
    paddingVertical: 10,
    alignItems: 'center'
  },
  headerBackButtonMinimal: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(0, 0, 0, 0.55)',
    alignItems: 'center',
    justifyContent: 'center'
  },
  errorText: {
    fontFamily: 'Inter-Medium',
    fontSize: 16,
    color: Colors.light.error,
    textAlign: 'center',
    marginBottom: 16
  },
  retryButton: {
    backgroundColor: Colors.common.white,
    borderWidth: 1,
    borderColor: Colors.common.black,
    paddingVertical: 10,
    paddingHorizontal: 25,
    borderRadius: 25
  },
  retryButtonText: {
    color: Colors.common.black,
    fontFamily: 'Inter-SemiBold',
    fontSize: 15
  },

  scrollContent: {
    flexGrow: 1,
    paddingTop: 60
  },
  wideScreenContent: {},
  headerGradient: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    height: 80,
    zIndex: 1
  },
  articleHeaderControlsContainer: {
    position: 'absolute',
    left: 0,
    right: 0,
    zIndex: 10
  },
  articleContentContainer: {
    paddingHorizontal: 20,
    paddingTop: 20,
    paddingBottom: 10,
    backgroundColor: Colors.common.transparent,
    zIndex: 2
  },
  wideScreenArticleContainer: {
    maxWidth: 768,
    width: '100%',
    alignSelf: 'center'
  },
  sourceContainer: {
    borderTopWidth: 2,
    borderTopColor: Colors.light.border,
    paddingVertical: 16
  },
  sourceText: {
    fontFamily: 'Inter-Regular',
    fontSize: 13,
    color: Colors.light.textSecondary,
    fontStyle: 'italic'
  }
})

```
src/app/(main)/settings/change-password.tsx
```
// src/app/(main)/settings/change-password.tsx
import React, { useState, useEffect, useRef } from 'react' // Added useEffect, useRef
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  ScrollView,
  Pressable,
  ActivityIndicator,
  Alert, // For feedback
  TouchableOpacity, // For password visibility toggle
  Platform
} from 'react-native'
import { useProtectedRoute } from '@hooks/useProtectedRoute'
import { Colors } from '@constants/Colors'
import { ScreenHeader } from '@components/common/ScreenHeader'
import { showPlatformAlert } from '@lib/platformAlert'
import { Eye, EyeOff } from 'lucide-react-native' // Icons for password visibility
// import { changePasswordThunk } from '@features/auth/authActions'; // Assuming this thunk exists or will be created
// import { useDispatch } from 'react-redux';
// import { AppDispatch } from '@store/store';

// Mock update action (replace with actual thunk)
const mockChangePassword = (data: any): Promise<{ message: string }> => {
  console.log(
    'Mock changing password with:',
    data.currentPassword,
    data.newPassword
  )
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (data.currentPassword === 'password123') {
        resolve({ message: 'Password updated successfully.' })
      } else {
        reject(new Error('Incorrect current password.'))
      }
    }, 1000)
  })
}

export default function ChangePasswordScreen(): React.ReactElement | null {
  const { isLoading: isAuthLoading, isAuthenticated } = useProtectedRoute()
  // const dispatch = useDispatch<AppDispatch>();

  const [currentPassword, setCurrentPassword] = useState('')
  const [newPassword, setNewPassword] = useState('')
  const [confirmNewPassword, setConfirmNewPassword] = useState('')

  const [isCurrentPasswordVisible, setIsCurrentPasswordVisible] =
    useState(false)
  const [isNewPasswordVisible, setIsNewPasswordVisible] = useState(false)
  const [isConfirmNewPasswordVisible, setIsConfirmNewPasswordVisible] =
    useState(false)

  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [successMessage, setSuccessMessage] = useState<string | null>(null)

  const newPasswordInputRef = useRef<TextInput>(null)
  const confirmNewPasswordInputRef = useRef<TextInput>(null)

  // Clear messages after a timeout
  useEffect(() => {
    let timer: NodeJS.Timeout | null = null
    if (error || successMessage) {
      timer = setTimeout(() => {
        setError(null)
        setSuccessMessage(null)
      }, 4000)
    }
    return () => {
      if (timer) clearTimeout(timer)
    }
  }, [error, successMessage])

  const handleUpdatePassword = async () => {
    setError(null)
    setSuccessMessage(null)

    if (
      !currentPassword.trim() ||
      !newPassword.trim() ||
      !confirmNewPassword.trim()
    ) {
      setError('Please fill in all password fields.')
      return
    }
    if (newPassword.length < 6) {
      // Example password policy
      setError('New password must be at least 6 characters long.')
      return
    }
    if (newPassword !== confirmNewPassword) {
      setError('New passwords do not match.')
      return
    }
    if (newPassword === currentPassword) {
      setError('New password cannot be the same as the current password.')
      return
    }

    setIsLoading(true)
    try {
      // Replace with actual thunk:
      // await dispatch(changePasswordThunk({ current_password: currentPassword, new_password: newPassword })).unwrap();
      const result = await mockChangePassword({ currentPassword, newPassword })
      setSuccessMessage(result.message)
      setCurrentPassword('')
      setNewPassword('')
      setConfirmNewPassword('')
    } catch (err: any) {
      setError(err.message || 'Failed to update password. Please try again.')
    } finally {
      setIsLoading(false)
    }
  }

  if (isAuthLoading || !isAuthenticated) {
    return (
      <View style={styles.fullScreenLoader}>
        <ScreenHeader
          title="Change Password"
          fallbackPath="/(main)/settings/"
        />
        <View style={styles.loaderContainer}>
          <ActivityIndicator size="large" color={Colors.light.primary} />
        </View>
      </View>
    )
  }

  const renderPasswordInput = (
    label: string,
    value: string,
    onChangeText: (text: string) => void,
    isVisible: boolean,
    toggleVisibility: () => void,
    onSubmitEditing?: () => void,
    inputRef?: React.RefObject<TextInput>
  ) => (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <View
        style={[
          styles.passwordInputWrapper,
          isLoading && styles.inputDisabledWrapper
        ]}
      >
        <TextInput
          ref={inputRef}
          style={[
            styles.input,
            styles.passwordInputOnly,
            isLoading && styles.inputDisabled
          ]}
          value={value}
          onChangeText={onChangeText}
          secureTextEntry={!isVisible}
          editable={!isLoading}
          placeholder={`Enter ${label.toLowerCase()}`}
          placeholderTextColor={Colors.light.textPlaceholder}
          autoCapitalize="none"
          returnKeyType={onSubmitEditing ? 'next' : 'done'}
          onSubmitEditing={onSubmitEditing}
          blurOnSubmit={!onSubmitEditing} // Only blur if it's the last input
        />
        <TouchableOpacity
          onPress={toggleVisibility}
          style={styles.passwordVisibilityButton}
          disabled={isLoading}
        >
          {isVisible ? (
            <EyeOff size={20} color={Colors.light.textSecondary} />
          ) : (
            <Eye size={20} color={Colors.light.textSecondary} />
          )}
        </TouchableOpacity>
      </View>
    </View>
  )

  return (
    <View style={styles.container}>
      <ScreenHeader title="Change Password" fallbackPath="/(main)/settings/" />
      <ScrollView
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
      >
        {error && <Text style={styles.errorText}>{error}</Text>}
        {successMessage && (
          <Text style={styles.successText}>{successMessage}</Text>
        )}

        {renderPasswordInput(
          'Current Password',
          currentPassword,
          setCurrentPassword,
          isCurrentPasswordVisible,
          () => setIsCurrentPasswordVisible(v => !v),
          () => newPasswordInputRef.current?.focus()
        )}

        {renderPasswordInput(
          'New Password',
          newPassword,
          setNewPassword,
          isNewPasswordVisible,
          () => setIsNewPasswordVisible(v => !v),
          () => confirmNewPasswordInputRef.current?.focus(),
          newPasswordInputRef
        )}

        {renderPasswordInput(
          'Confirm New Password',
          confirmNewPassword,
          setConfirmNewPassword,
          isConfirmNewPasswordVisible,
          () => setIsConfirmNewPasswordVisible(v => !v),
          handleUpdatePassword, // Submit on final input
          confirmNewPasswordInputRef
        )}

        <Pressable
          style={({ pressed }) => [
            styles.button,
            isLoading && styles.buttonDisabled,
            pressed && !isLoading && styles.buttonPressed
          ]}
          onPress={handleUpdatePassword}
          disabled={isLoading}
        >
          {isLoading ? (
            <ActivityIndicator color={Colors.light.primaryContent} />
          ) : (
            <Text style={styles.buttonText}>Update Password</Text>
          )}
        </Pressable>
      </ScrollView>
    </View>
  )
}

// Using similar styles to profile-info.tsx for consistency
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.backgroundSecondary
  },
  fullScreenLoader: { flex: 1, backgroundColor: Colors.light.background },
  loaderContainer: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  scrollContent: {
    padding: 20,
    paddingBottom: 40
  },
  fieldContainer: {
    marginBottom: 20
  },
  label: {
    fontSize: 14,
    fontFamily: 'Inter-Medium',
    color: Colors.light.textSecondary,
    marginBottom: 8
  },
  input: {
    // Base style for text input part
    flex: 1, // Take available space within wrapper
    minHeight: 50,
    paddingHorizontal: 16,
    paddingVertical: Platform.OS === 'ios' ? 14 : 10,
    fontSize: 16,
    fontFamily: 'Inter-Regular',
    color: Colors.light.text
  },
  passwordInputWrapper: {
    // Wrapper for password input + icon
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.light.inputBackground,
    borderColor: Colors.light.inputBorder,
    borderWidth: 1,
    borderRadius: 10,
    width: '100%'
  },
  passwordInputOnly: {
    // Style for the TextInput itself when inside a wrapper
    borderWidth: 0, // No border on the TextInput as wrapper has it
    paddingRight: 0 // Avoid double padding with icon button
  },
  passwordVisibilityButton: {
    padding: 14 // Make icon tappable
  },
  inputDisabled: {
    // For the TextInput when disabled
    color: Colors.light.textTertiary
  },
  inputDisabledWrapper: {
    // For the wrapper when disabled
    backgroundColor: Colors.light.backgroundSecondary,
    borderColor: Colors.light.borderSubtle
  },
  button: {
    width: '100%',
    height: 52,
    backgroundColor: Colors.light.primary,
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: 10,
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 2
  },
  buttonPressed: {
    backgroundColor: Colors.light.primaryLight
  },
  buttonDisabled: {
    backgroundColor: Colors.light.buttonDisabledBackground,
    shadowOpacity: 0,
    elevation: 0
  },
  buttonText: {
    color: Colors.light.primaryContent,
    fontSize: 16,
    fontFamily: 'Inter-SemiBold'
  },
  errorText: {
    color: Colors.light.error,
    backgroundColor: Colors.light.errorBackground,
    padding: 10,
    borderRadius: 8,
    marginBottom: 15,
    textAlign: 'center',
    fontFamily: 'Inter-Medium',
    fontSize: 14,
    borderWidth: 1,
    borderColor: Colors.light.error
  },
  successText: {
    color: Colors.light.success,
    backgroundColor: Colors.light.successBackground,
    padding: 10,
    borderRadius: 8,
    marginBottom: 15,
    textAlign: 'center',
    fontFamily: 'Inter-Medium',
    fontSize: 14,
    borderWidth: 1,
    borderColor: Colors.light.success
  }
})

```
src/app/(main)/settings/index.tsx
```
import React, { useState } from 'react'
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  Switch,
  Platform,
  ActivityIndicator,
  Alert
} from 'react-native'
import { SafeAreaView, useSafeAreaInsets } from 'react-native-safe-area-context'
import {
  User,
  ShieldCheck,
  LogOut,
  Bell,
  Moon,
  Volume2,
  Globe2,
  Eye,
  HelpCircle,
  ChevronRight,
  Lock
} from 'lucide-react-native'
import { Colors } from '@constants/Colors'
import { useResponsiveDimensions } from '@/hooks/useResponsiveDimensions'
import { useRouter } from 'expo-router'
import { AppDispatch, RootState } from '@store/store'
import { useDispatch, useSelector } from 'react-redux'
import { logoutUser } from '@features/auth/authActions'
import Constants from 'expo-constants'
import { useProtectedRoute } from '@hooks/useProtectedRoute'
import { ScreenHeader } from '@components/common/ScreenHeader'

interface SettingSectionProps {
  title: string
  children: React.ReactNode
}
const SettingSection: React.FC<SettingSectionProps> = ({ title, children }) => (
  <View style={styles.section}>
    <Text style={styles.sectionTitle}>{title}</Text>
    <View style={styles.sectionContent}>{children}</View>
  </View>
)

interface SettingItemProps {
  icon: React.ReactNode
  title: string
  description?: string
  rightElement?: React.ReactNode
  showChevron?: boolean
  onPress?: () => void
  itemTextColor?: string
}
const SettingItem: React.FC<SettingItemProps> = ({
  icon,
  title,
  description,
  rightElement,
  showChevron = false,
  onPress,
  itemTextColor
}) => (
  <TouchableOpacity
    style={styles.settingItem}
    onPress={onPress}
    disabled={!onPress}
    activeOpacity={onPress ? 0.7 : 1}
  >
    <View style={styles.settingItemLeft}>
      <View style={styles.iconContainer}>{icon}</View>
      <View style={styles.settingTextContainer}>
        <Text
          style={[
            styles.settingTitle,
            itemTextColor ? { color: itemTextColor } : {}
          ]}
          numberOfLines={1}
        >
          {title}
        </Text>
        {description && (
          <Text style={styles.settingDescription} numberOfLines={2}>
            {description}
          </Text>
        )}
      </View>
    </View>
    {(rightElement || showChevron) && (
      <View style={styles.settingItemRight}>
        {rightElement}
        {showChevron && !rightElement && (
          <ChevronRight size={18} color={Colors.light.textTertiary} />
        )}
      </View>
    )}
  </TouchableOpacity>
)

export default function SettingsScreen(): React.ReactElement | null {
  const { isLoading: isAuthLoading, isAuthenticated } = useProtectedRoute()
  const { isDesktop } = useResponsiveDimensions()
  const dispatch = useDispatch<AppDispatch>()
  const router = useRouter()
  const insets = useSafeAreaInsets()

  const [notifications, setNotifications] = useState(true)
  const [darkMode, setDarkMode] = useState(false)
  const [soundEffects, setSoundEffects] = useState(true)

  const fontSizes = ['Small', 'Medium', 'Large']
  const [fontSizeIndex, setFontSizeIndex] = useState(1)

  const languages = [
    { id: 'fi', name: 'Finnish' },
    { id: 'en', name: 'English' }
  ]
  const [selectedLanguage, setSelectedLanguage] = useState(languages[0])

  const handleLogout = () => {
    Alert.alert('Confirm Logout', 'Are you sure you want to sign out?', [
      { text: 'Cancel', style: 'cancel' },
      {
        text: 'Sign Out',
        style: 'destructive',
        onPress: () => dispatch(logoutUser())
      }
    ])
  }

  if (isAuthLoading) {
    return (
      <View style={styles.fullScreenLoader}>
        <ScreenHeader title="Settings" fallbackPath="/(main)/(tabs)/profile" />
        <View style={styles.loaderContainer}>
          <ActivityIndicator size="large" color={Colors.light.primary} />
        </View>
      </View>
    )
  }
  if (!isAuthenticated) return null

  return (
    <View style={styles.container}>
      <ScreenHeader title="Settings" fallbackPath="/(main)/(tabs)/profile" />
      <ScrollView
        contentContainerStyle={[
          styles.contentContainer,
          isDesktop && styles.wideScreenContent,
          { paddingBottom: insets.bottom + 20 }
        ]}
        showsVerticalScrollIndicator={false}
      >
        <SettingSection title="Account">
          <SettingItem
            icon={<User size={20} color={Colors.light.primary} />}
            title="Profile Information"
            description="Edit your personal details"
            showChevron
            onPress={() => router.push('/(main)/settings/profile-info')}
          />
          <SettingItem
            icon={<ShieldCheck size={20} color={Colors.light.accentGreen} />}
            title="Change Password"
            description="Update your account password"
            showChevron
            onPress={() => router.push('/(main)/settings/change-password')}
          />
          <SettingItem
            icon={<Lock size={20} color={Colors.light.textSecondary} />}
            title="Privacy Settings"
            description="Manage your data preferences"
            showChevron
            onPress={() => {
              Alert.alert('Navigate', 'Privacy Settings (Not Implemented)')
            }}
          />
        </SettingSection>

        <SettingSection title="Preferences">
          <SettingItem
            icon={<Bell size={20} color={Colors.light.warning} />}
            title="Notifications"
            description="Reminders and achievements"
            rightElement={
              <Switch
                value={notifications}
                onValueChange={setNotifications}
                trackColor={{
                  false: Colors.light.border,
                  true: Colors.light.primary
                }}
                thumbColor={
                  notifications
                    ? Colors.light.primaryLight
                    : Colors.light.borderSubtle
                }
                ios_backgroundColor={Colors.light.border}
              />
            }
          />
          <SettingItem
            icon={<Moon size={20} color={Colors.light.textSecondary} />}
            title="Dark Mode"
            description="Toggle theme (not implemented)"
            rightElement={
              <Switch
                value={darkMode}
                onValueChange={setDarkMode}
                trackColor={{
                  false: Colors.light.border,
                  true: Colors.light.primary
                }}
                thumbColor={
                  darkMode
                    ? Colors.light.primaryLight
                    : Colors.light.borderSubtle
                }
                ios_backgroundColor={Colors.light.border}
              />
            }
          />
          <SettingItem
            icon={<Volume2 size={20} color={Colors.light.accentOrange} />}
            title="Sound Effects"
            description="Toggle in-app sounds"
            rightElement={
              <Switch
                value={soundEffects}
                onValueChange={setSoundEffects}
                trackColor={{
                  false: Colors.light.border,
                  true: Colors.light.primary
                }}
                thumbColor={
                  soundEffects
                    ? Colors.light.primaryLight
                    : Colors.light.borderSubtle
                }
                ios_backgroundColor={Colors.light.border}
              />
            }
          />
        </SettingSection>

        <SettingSection title="Content & Display">
          <SettingItem
            icon={<Globe2 size={20} color={Colors.light.accentGreen} />}
            title="App Language"
            description={selectedLanguage.name}
            showChevron
            onPress={() => {
              Alert.alert(
                'Select Language',
                'Language selection (Not Implemented)'
              )
            }}
          />
          <SettingItem
            icon={<Eye size={20} color={Colors.light.secondary} />}
            title="Font Size"
            description={fontSizes[fontSizeIndex]}
            showChevron
            onPress={() => {
              Alert.alert(
                'Adjust Font Size',
                'Font size adjustment (Not Implemented)'
              )
            }}
          />
        </SettingSection>

        <SettingSection title="Support & Info">
          <SettingItem
            icon={<HelpCircle size={20} color={Colors.light.info} />}
            title="Help Center"
            description="FAQs and support"
            showChevron
            onPress={() => {
              Alert.alert('Navigate', 'Help Center (Not Implemented)')
            }}
          />
          <SettingItem
            icon={<LogOut size={20} color={Colors.light.error} />}
            title="Sign Out"
            onPress={handleLogout}
            itemTextColor={Colors.light.error}
          />
        </SettingSection>

        <View style={styles.footer}>
          <Text style={styles.versionText}>
            Kielo.app v{Constants.expoConfig?.version || '1.0.0'}
          </Text>
          <Text style={styles.copyrightText}>
             {new Date().getFullYear()}. All rights reserved.
          </Text>
        </View>
      </ScrollView>
    </View>
  )
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: Colors.light.backgroundSecondary },
  fullScreenLoader: { flex: 1, backgroundColor: Colors.light.background },
  loaderContainer: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  contentContainer: {
    padding: 20
  },
  wideScreenContent: {
    maxWidth: 640,
    alignSelf: 'center',
    width: '100%'
  },
  section: {
    marginBottom: 28
  },
  sectionTitle: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 15,
    color: Colors.light.textSecondary,
    marginBottom: 10,
    paddingHorizontal: 8,
    textTransform: 'uppercase'
  },
  sectionContent: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 12,
    overflow: 'hidden',
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.08,
    shadowRadius: 4,
    elevation: 2
  },
  settingItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 14,
    paddingHorizontal: 16,
    backgroundColor: Colors.light.cardBackground,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: Colors.light.borderSubtle
  },
  settingItemLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
    marginRight: 8
  },
  iconContainer: {
    width: 36,
    height: 36,
    borderRadius: 10,
    backgroundColor: Colors.light.backgroundSecondary,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 14
  },
  settingTextContainer: {
    flex: 1
  },
  settingTitle: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 16,
    color: Colors.light.text
  },
  settingDescription: {
    fontFamily: 'Inter-Regular',
    fontSize: 13,
    color: Colors.light.textSecondary,
    marginTop: 2
  },
  settingItemRight: {
    flexDirection: 'row',
    alignItems: 'center'
  },
  footer: {
    alignItems: 'center',
    marginTop: 30,
    paddingBottom: 10
  },
  versionText: {
    fontFamily: 'Inter-Medium',
    fontSize: 13,
    color: Colors.light.textTertiary,
    marginBottom: 4
  },
  copyrightText: {
    fontFamily: 'Inter-Regular',
    fontSize: 12,
    color: Colors.light.textTertiary
  }
})

```
src/app/(main)/settings/profile-info.tsx
```
import React, { useState, useEffect } from 'react'
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  ScrollView,
  Pressable,
  ActivityIndicator,
  Alert,
  Platform
} from 'react-native'
import { useSelector, useDispatch } from 'react-redux'
import { useProtectedRoute } from '@hooks/useProtectedRoute'
import { selectUser } from '@features/auth/authSelectors'
import { AppDispatch, RootState } from '@store/store'
import { Colors } from '@constants/Colors'
import { ScreenHeader } from '@components/common/ScreenHeader'
import { showPlatformAlert } from '@lib/platformAlert'

const mockUpdateProfile = (data: {
  name: string
  bio: string
}): Promise<{ message: string }> => {
  console.log('Mock updating profile with:', data)
  return new Promise(resolve =>
    setTimeout(
      () => resolve({ message: 'Profile updated successfully!' }),
      1000
    )
  )
}

export default function ProfileInfoScreen(): React.ReactElement | null {
  const { isLoading: isAuthLoading, isAuthenticated } = useProtectedRoute()
  const user = useSelector((state: RootState) => selectUser(state))
  const dispatch = useDispatch<AppDispatch>()

  const [name, setName] = useState('')
  const [email, setEmail] = useState('')
  const [bio, setBio] = useState('')
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [successMessage, setSuccessMessage] = useState<string | null>(null)

  useEffect(() => {
    if (user) {
      setName(user.displayName || user.name || '')
      setEmail(user.email || '')
      setBio((user as any).bio || '')
    }
  }, [user])

  useEffect(() => {
    let timer: NodeJS.Timeout | null = null
    if (error || successMessage) {
      timer = setTimeout(() => {
        setError(null)
        setSuccessMessage(null)
      }, 4000)
    }
    return () => {
      if (timer) clearTimeout(timer)
    }
  }, [error, successMessage])

  const handleSaveChanges = async () => {
    setError(null)
    setSuccessMessage(null)
    if (!name.trim()) {
      setError('Name cannot be empty.')
      return
    }
    if (name.trim().length < 2) {
      setError('Name must be at least 2 characters long.')
      return
    }
    if (bio.length > 200) {
      setError('Bio cannot exceed 200 characters.')
      return
    }

    setIsLoading(true)
    try {
      const result = await mockUpdateProfile({
        name: name.trim(),
        bio: bio.trim()
      })
      setSuccessMessage(result.message)
    } catch (err: any) {
      setError(err.message || 'Failed to update profile. Please try again.')
    } finally {
      setIsLoading(false)
    }
  }

  if (isAuthLoading || !isAuthenticated) {
    return (
      <View style={styles.fullScreenLoader}>
        <ScreenHeader
          title="Profile Information"
          fallbackPath="/(main)/settings/"
        />
        <View style={styles.loaderContainer}>
          <ActivityIndicator size="large" color={Colors.light.primary} />
        </View>
      </View>
    )
  }
  if (!user) return null

  return (
    <View style={styles.container}>
      <ScreenHeader
        title="Profile Information"
        fallbackPath="/(main)/settings/"
      />
      <ScrollView
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
      >
        {error && <Text style={styles.errorText}>{error}</Text>}
        {successMessage && (
          <Text style={styles.successText}>{successMessage}</Text>
        )}

        <View style={styles.fieldContainer}>
          <Text style={styles.label}>Full Name</Text>
          <TextInput
            style={[styles.input, isLoading && styles.inputDisabled]}
            value={name}
            onChangeText={setName}
            editable={!isLoading}
            placeholder="Enter your full name"
            placeholderTextColor={Colors.light.textPlaceholder}
            autoCapitalize="words"
          />
        </View>

        <View style={styles.fieldContainer}>
          <Text style={styles.label}>Email Address</Text>
          <TextInput
            style={[styles.input, styles.inputDisabled]}
            value={email}
            editable={false}
            placeholderTextColor={Colors.light.textPlaceholder}
          />
          <Text style={styles.noteText}>Email cannot be changed here.</Text>
        </View>

        <View style={styles.fieldContainer}>
          <Text style={styles.label}>Bio / About Me (Optional)</Text>
          <TextInput
            style={[
              styles.input,
              styles.textArea,
              isLoading && styles.inputDisabled
            ]}
            value={bio}
            onChangeText={setBio}
            multiline
            numberOfLines={4}
            maxLength={200}
            editable={!isLoading}
            placeholder="Tell us a little about yourself..."
            placeholderTextColor={Colors.light.textPlaceholder}
            textAlignVertical="top"
          />
        </View>

        <Pressable
          style={({ pressed }) => [
            styles.button,
            isLoading && styles.buttonDisabled,
            pressed && !isLoading && styles.buttonPressed
          ]}
          onPress={handleSaveChanges}
          disabled={isLoading}
        >
          {isLoading ? (
            <ActivityIndicator color={Colors.light.primaryContent} />
          ) : (
            <Text style={styles.buttonText}>Save Changes</Text>
          )}
        </Pressable>
      </ScrollView>
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.backgroundSecondary
  },
  fullScreenLoader: { flex: 1, backgroundColor: Colors.light.background },
  loaderContainer: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  scrollContent: {
    padding: 20,
    paddingBottom: 40
  },
  fieldContainer: {
    marginBottom: 20
  },
  label: {
    fontSize: 14,
    fontFamily: 'Inter-Medium',
    color: Colors.light.textSecondary,
    marginBottom: 8
  },
  input: {
    width: '100%',
    minHeight: 50,
    backgroundColor: Colors.light.inputBackground,
    borderColor: Colors.light.inputBorder,
    borderWidth: 1,
    borderRadius: 10,
    paddingHorizontal: 16,
    paddingVertical: Platform.OS === 'ios' ? 14 : 10,
    fontSize: 16,
    fontFamily: 'Inter-Regular',
    color: Colors.light.text
  },
  inputDisabled: {
    backgroundColor: Colors.light.backgroundSecondary,
    color: Colors.light.textTertiary,
    borderColor: Colors.light.borderSubtle
  },
  textArea: {
    height: 120,
    textAlignVertical: 'top'
  },
  noteText: {
    fontSize: 12,
    color: Colors.light.textTertiary,
    marginTop: 6,
    fontFamily: 'Inter-Regular'
  },
  button: {
    width: '100%',
    height: 52,
    backgroundColor: Colors.light.primary,
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: 10,
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 2
  },
  buttonPressed: {
    backgroundColor: Colors.light.primaryLight
  },
  buttonDisabled: {
    backgroundColor: Colors.light.buttonDisabledBackground,
    shadowOpacity: 0,
    elevation: 0
  },
  buttonText: {
    color: Colors.light.primaryContent,
    fontSize: 16,
    fontFamily: 'Inter-SemiBold'
  },
  errorText: {
    color: Colors.light.error,
    backgroundColor: Colors.light.errorBackground,
    padding: 10,
    borderRadius: 8,
    marginBottom: 15,
    textAlign: 'center',
    fontFamily: 'Inter-Medium',
    fontSize: 14,
    borderWidth: 1,
    borderColor: Colors.light.error
  },
  successText: {
    color: Colors.light.success,
    backgroundColor: Colors.light.successBackground,
    padding: 10,
    borderRadius: 8,
    marginBottom: 15,
    textAlign: 'center',
    fontFamily: 'Inter-Medium',
    fontSize: 14,
    borderWidth: 1,
    borderColor: Colors.light.success
  }
})

```
src/app/(main)/(tabs)/_layout.tsx
```
import { Tabs, Slot, useRouter } from 'expo-router'
import {
  StyleSheet,
  Platform,
  View,
  Text,
  TouchableOpacity
} from 'react-native'
import { Colors } from '@constants/Colors'
import { navItems } from '@constants/navigation'
import { useResponsiveDimensions } from '@/hooks/useResponsiveDimensions'
import { useSelector } from 'react-redux'
import { selectIsAuthenticated } from '@/features/auth/authSelectors'
import { useRequireAuthAction } from '@/hooks/useRequireAuthAction'
import { useSafeAreaInsets } from 'react-native-safe-area-context'

export default function TabLayout(): React.ReactElement | null {
  const router = useRouter()
  const isAuthenticated = useSelector(selectIsAuthenticated)
  const { isDesktop } = useResponsiveDimensions()
  const insets = useSafeAreaInsets()

  if (isDesktop) {
    return <Slot />
  }

  const navigateToProtectedTab = useRequireAuthAction((path: string) => {
    router.push(path as any)
  }, 'Login to view this section.')

  return (
    <View style={{ flex: 1, backgroundColor: Colors.light.background }}>
      <Tabs
        screenOptions={({ route }) => ({
          tabBarActiveTintColor: Colors.light.tabBarActive,
          tabBarInactiveTintColor: Colors.light.tabBarInactive,
          headerShown: false,
          tabBarShowLabel: false,
          tabBarStyle: [
            styles.tabBarStyleFloating,
            { bottom: Math.max(insets.bottom, TAB_BAR_MARGIN_FROM_SAFE_AREA) }
          ],
          tabBarButton: props => {
            const isFocused = props['aria-selected']
            const item = navItems.find(
              navItem => navItem.targetSegment === route.name
            )

            if (!item) return null

            const IconComponent = item.icon

            return (
              <TouchableOpacity
                {...props}
                style={[props.style, styles.tabBarButton]}
                accessibilityLabel={item.name}
              >
                <View
                  style={[
                    styles.tabIconContainer,
                    isFocused && styles.tabIconContainerActive
                  ]}
                >
                  {IconComponent && (
                    <IconComponent
                      size={22}
                      color={
                        isFocused
                          ? Colors.light.tabBarActive
                          : Colors.light.tabBarInactive
                      }
                      strokeWidth={isFocused ? 2.5 : 2}
                    />
                  )}
                </View>
                <Text
                  style={[
                    styles.tabBarLabel,
                    isFocused && styles.tabBarLabelActive
                  ]}
                >
                  {item.name}
                </Text>
              </TouchableOpacity>
            )
          }
        })}
      >
        {navItems
          .filter(item => item.isTabItem && item.targetSegment)
          .map(item => {
            return (
              <Tabs.Screen
                key={item.name}
                name={item.targetSegment!}
                options={{
                  title: item.name
                }}
                listeners={
                  item.protected
                    ? {
                        tabPress: e => {
                          if (!isAuthenticated) {
                            e.preventDefault()
                            navigateToProtectedTab(item.path)
                          }
                        }
                      }
                    : undefined
                }
              />
            )
          })}
      </Tabs>
    </View>
  )
}

const TAB_BAR_HEIGHT = 78
const TAB_BAR_MARGIN_FROM_SAFE_AREA = 15

const styles = StyleSheet.create({
  tabBarStyleFloating: {
    position: 'absolute',
    marginLeft: TAB_BAR_MARGIN_FROM_SAFE_AREA,
    marginRight: TAB_BAR_MARGIN_FROM_SAFE_AREA,
    borderRadius: 24,
    height: TAB_BAR_HEIGHT,
    backgroundColor: Colors.light.tabBarBackground,
    borderTopWidth: 0,
    shadowColor: Colors.light.shadowMedium,
    shadowOffset: { width: 0, height: 6 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 10,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: Colors.light.borderSubtle
  },
  tabBarButton: {
    flex: 1,
    alignItems: 'center',
    paddingVertical: 14
  },
  tabIconContainer: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: Colors.light.tabIconBackgroundInactive,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 3
  },
  tabIconContainerActive: {
    backgroundColor: Colors.light.tabIconBackgroundActive
  },
  tabBarLabel: {
    fontFamily: 'Inter-Medium',
    fontSize: 12,
    color: Colors.light.tabBarInactive,
    textAlign: 'center'
  },
  tabBarLabelActive: {
    fontFamily: 'Inter-SemiBold',
    color: Colors.light.tabBarActive
  }
})

```
src/app/(main)/(tabs)/exercises.tsx
```
import React, { useEffect } from 'react'
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator
} from 'react-native'
import { SafeAreaView } from 'react-native-safe-area-context'
import {
  Brain,
  ChevronRight,
  Sparkles,
  Volume2,
  Trophy
} from 'lucide-react-native'
import { Colors } from '@constants/Colors'
import { useRequireAuthAction } from '@hooks/useRequireAuthAction'
import { useResponsiveDimensions } from '@/hooks/useResponsiveDimensions'
import { useRouter } from 'expo-router'
import { useDispatch, useSelector } from 'react-redux'
import { AppDispatch } from '@/store/store'

import {
  fetchSuggestedLessonsThunk,
  selectSuggestedLessons,
  selectSuggestedLessonsStatus
} from '@features/lessons/lessonsSlice'
import { LessonData } from '@/features/lessons/types'

const exerciseCategories = [
  {
    id: 'nsr_review_session',
    title: 'Daily Flashcards',
    description: 'Practice words & grammar due for review',
    icon: <Brain size={24} color={Colors.light.primaryContent} />,
    color: Colors.light.primary,
    targetPath: '/(main)/exercises/review-session'
  }
]

export default function ExercisesScreen(): React.ReactElement {
  const { isDesktop } = useResponsiveDimensions()
  const router = useRouter()
  const dispatch = useDispatch<AppDispatch>()

  const suggestedLessons = useSelector(selectSuggestedLessons)
  const lessonsStatus = useSelector(selectSuggestedLessonsStatus)

  useEffect(() => {
    if (lessonsStatus === 'idle') {
      dispatch(fetchSuggestedLessonsThunk({ max_suggestions: 3 }))
    }
  }, [dispatch, lessonsStatus])

  const navigateToScreen = useRequireAuthAction(
    (path: string, params?: Record<string, any>) => {
      router.push({ pathname: path, params })
    },
    'Login to start practicing.'
  )

  const handleCategoryPress = (category: (typeof exerciseCategories)[0]) => {
    navigateToScreen(category.targetPath)
  }

  const handleSuggestedLessonPress = (lesson: LessonData) => {
    navigateToScreen(`/(main)/exercises/player`, {
      lessonDataString: JSON.stringify(lesson)
    })
  }

  return (
    <SafeAreaView style={styles.container} edges={['top']}>
      <View style={styles.header}>
        <Text style={styles.headerTitle}>Practice Hub</Text>
      </View>

      <ScrollView
        contentContainerStyle={[
          styles.content,
          isDesktop && styles.wideScreenContent
        ]}
      >
        <Text style={styles.sectionTitle}>Daily Challenge</Text>
        <TouchableOpacity
          style={styles.challengeCard}
          onPress={() => router.push('/(main)/challenges/daily')}
          accessibilityRole="button"
          accessibilityLabel="Start daily challenge: Complete a News Article"
        >
          <View style={styles.challengeContent}>
            <View style={styles.challengeIconContainer}>
              <Trophy size={24} color={Colors.common.white} />
            </View>
            <View style={styles.challengeTextContainer}>
              <Text style={styles.challengeTitle}>Complete a News Article</Text>
              <Text style={styles.challengeSubtitle}>
                Read and learn 5 new words
              </Text>
            </View>
          </View>
          <View style={styles.challengeContentRight}>
            <ChevronRight size={20} color={Colors.light.textSecondary} />
          </View>
        </TouchableOpacity>

        <Text style={styles.sectionTitle}>Recommended For You</Text>
        {lessonsStatus === 'loading' && (
          <ActivityIndicator
            color={Colors.light.primary}
            style={{ marginVertical: 20 }}
          />
        )}
        {lessonsStatus === 'failed' && (
          <Text style={styles.errorText}>Could not load recommendations.</Text>
        )}
        {lessonsStatus === 'succeeded' && suggestedLessons.length === 0 && (
          <Text style={styles.emptySectionText}>
            No specific recommendations right now. Explore categories below!
          </Text>
        )}
        {suggestedLessons.map(lesson => (
          <TouchableOpacity
            key={lesson.lesson_id}
            style={styles.suggestionCard}
            onPress={() => handleSuggestedLessonPress(lesson)}
          >
            <View
              style={[
                styles.suggestionIconContainer,
                { backgroundColor: Colors.light.accentOrange }
              ]}
            >
              <Sparkles size={22} color={Colors.light.primaryContent} />
            </View>
            <View style={styles.suggestionTextContainer}>
              <Text style={styles.suggestionTitle}>{lesson.lesson_title}</Text>
              <Text style={styles.suggestionDescription} numberOfLines={2}>
                {lesson.description}
              </Text>
              <Text style={styles.suggestionMeta}>
                Approx. {lesson.estimated_duration_minutes || '?'} min
              </Text>
            </View>
            <ChevronRight size={20} color={Colors.light.textSecondary} />
          </TouchableOpacity>
        ))}

        <Text style={styles.sectionTitle}>Practice Areas</Text>
        <View
          style={[
            styles.exercisesGrid,
            isDesktop && styles.wideScreenExercisesGrid
          ]}
        >
          {exerciseCategories.map(category => (
            <TouchableOpacity
              key={category.id}
              style={[
                styles.exerciseCard,
                isDesktop && styles.wideScreenExerciseCard
              ]}
              onPress={() => handleCategoryPress(category)}
            >
              <View
                style={[
                  styles.exerciseIconContainer,
                  { backgroundColor: category.color }
                ]}
              >
                {category.icon}
              </View>
              <Text style={styles.exerciseTitle}>{category.title}</Text>
              <Text style={styles.exerciseDescription} numberOfLines={2}>
                {category.description}
              </Text>
              <View style={styles.exerciseInfoRow}>
                <Text style={styles.exerciseCount}>Explore</Text>
                <ChevronRight size={16} color={Colors.light.textSecondary} />
              </View>
            </TouchableOpacity>
          ))}
        </View>

        <Text style={styles.sectionTitle}>Word of the Day</Text>
        <View style={styles.wordOfDayCard}>
          <View style={styles.wordOfDayHeader}>
            <Text style={styles.finnishWord}>tervetuloa</Text>
            <Text style={styles.pronunciation}>/tervetuloa/</Text>
          </View>
          <Text style={styles.englishTranslation}>welcome</Text>
          <TouchableOpacity style={styles.wodListenButton}>
            <Volume2 size={18} color={Colors.light.primary} />
            <Text style={styles.wodListenButtonText}>Listen</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </SafeAreaView>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background
  },
  header: {
    paddingHorizontal: 20,
    paddingTop: 10,
    paddingBottom: 12
  },
  headerTitle: {
    fontFamily: 'Inter-Bold',
    fontSize: 24,
    color: Colors.light.text
  },
  content: {
    paddingHorizontal: 20,
    paddingTop: 8,
    paddingBottom: 90
  },
  wideScreenContent: {
    maxWidth: 768,
    alignSelf: 'center',
    width: '100%'
  },
  sectionTitle: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 18,
    color: Colors.light.text,
    marginTop: 24,
    marginBottom: 12
  },
  errorText: {
    textAlign: 'center',
    color: Colors.light.error,
    marginVertical: 15,
    fontFamily: 'Inter-Regular'
  },
  emptySectionText: {
    textAlign: 'center',
    color: Colors.light.textSecondary,
    marginVertical: 15,
    paddingHorizontal: 20,
    fontFamily: 'Inter-Regular'
  },

  challengeCard: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3
  },
  challengeContent: {
    flexDirection: 'row',
    alignItems: 'center',
    flexShrink: 1,
    marginRight: 8,
    flex: 1
  },
  challengeContentRight: {},
  challengeIconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: Colors.light.accent,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12
  },
  challengeTextContainer: {
    flex: 1
  },
  challengeTitle: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 16,
    color: Colors.light.text,
    marginBottom: 4
  },
  challengeSubtitle: {
    fontFamily: 'Inter-Regular',
    fontSize: 14,
    color: Colors.light.textSecondary
  },
  suggestionCard: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3
  },
  suggestionIconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12
  },
  suggestionTextContainer: {
    flex: 1,
    marginRight: 8
  },
  suggestionTitle: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 16,
    color: Colors.light.text,
    marginBottom: 2
  },
  suggestionDescription: {
    fontFamily: 'Inter-Regular',
    fontSize: 13,
    color: Colors.light.textSecondary,
    marginBottom: 4,
    lineHeight: 18
  },
  suggestionMeta: {
    fontFamily: 'Inter-Medium',
    fontSize: 12,
    color: Colors.light.primary
  },
  exercisesGrid: {
    flexDirection: 'column',
    gap: 16
  },
  wideScreenExercisesGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap'
  },
  exerciseCard: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 16,
    padding: 16,
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
    width: '100%',
    minHeight: 160,
    justifyContent: 'space-between'
  },
  wideScreenExerciseCard: {
    width: 'calc(50% - 8px)'
  },
  exerciseIconContainer: {
    width: 48,
    height: 48,
    borderRadius: 24,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 12
  },
  exerciseTitle: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 18,
    color: Colors.light.text,
    marginBottom: 4
  },
  exerciseDescription: {
    fontFamily: 'Inter-Regular',
    fontSize: 14,
    color: Colors.light.textSecondary,
    marginBottom: 12,
    lineHeight: 20,
    flexGrow: 1
  },
  exerciseInfoRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginTop: 'auto'
  },
  exerciseCount: {
    fontFamily: 'Inter-Medium',
    fontSize: 14,
    color: Colors.light.textSecondary
  },
  wordOfDayCard: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 16,
    padding: 20,
    marginBottom: 24,
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
    alignItems: 'center'
  },
  wordOfDayHeader: {
    alignItems: 'center',
    marginBottom: 8
  },
  finnishWord: {
    fontFamily: 'Inter-Bold',
    fontSize: 26,
    color: Colors.light.text,
    marginBottom: 4
  },
  pronunciation: {
    fontFamily: 'Inter-Regular',
    fontSize: 14,
    color: Colors.light.textSecondary,
    marginBottom: 12
  },
  englishTranslation: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 18,
    color: Colors.light.primary,
    marginBottom: 16
  },
  wodListenButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.light.primaryLight,
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 20
  },
  wodListenButtonText: {
    fontFamily: 'Inter-Medium',
    fontSize: 14,
    color: Colors.light.primary,
    marginLeft: 6
  }
})

```
src/app/(main)/(tabs)/index.tsx
```
import React, { useCallback, useEffect } from 'react'
import {
  StyleSheet,
  ScrollView,
  RefreshControl,
  View,
  Text,
  Alert
} from 'react-native'
import { SafeAreaView, useSafeAreaInsets } from 'react-native-safe-area-context'
import { useSelector, useDispatch } from 'react-redux'
import { LinearGradient } from 'expo-linear-gradient'
import { LearningModuleCard } from '@/components/home/LearningModuleCard'

import { Colors } from '@constants/Colors'
import { selectIsAuthenticated, selectUser } from '@features/auth/authSelectors'
import { AppDispatch, RootState } from '@store/store'
import { useRequireAuthAction } from '@hooks/useRequireAuthAction'
import { useRefresh } from '@hooks/useRefresh'
import { fetchProgressThunk } from '@features/progress/progressActions'
import {
  selectProgressSummary,
  selectProgressStatus
} from '@features/progress/progressSlice'
import { useRouter } from 'expo-router'

import { HomeHeader } from '@/components/home/HomeHeader'
import { StreakCard } from '@/components/home/StreakCard'
import { DailyGoalCard } from '@/components/home/DailyGoalCard'
import { FeaturedArticles } from '@/components/home/FeaturedArticles'
import { fetchArticles } from '@/features/articles/articlesActions'
import { selectPaginatedData } from '@/pagination/selectors'

const HOME_FEATURED_ARTICLES_KEY = 'home-featured-articles'

export default function HomeScreen(): React.ReactElement {
  const dispatch = useDispatch<AppDispatch>()
  const router = useRouter()
  const insets = useSafeAreaInsets()

  const isAuthenticated = useSelector(selectIsAuthenticated)
  const user = useSelector(selectUser)
  const progressSummary = useSelector(selectProgressSummary)
  const progressStatus = useSelector(selectProgressStatus)

  const { data: featuredArticles, pagination: featuredArticlesPagination } =
    useSelector((state: RootState) =>
      selectPaginatedData(
        'articles', // entityName for normalizr
        'articlePagination', // paginationType in pagination slice
        HOME_FEATURED_ARTICLES_KEY, // Specific key for this list
        false // isAccumulated: false, typically for feeds that reset
      )(state)
    )

  const handleLoadMoreFeaturedArticles = () => {
    if (
      !featuredArticlesPagination.isLoading &&
      featuredArticlesPagination.hasMore
    ) {
      dispatch(
        fetchArticles(HOME_FEATURED_ARTICLES_KEY, {
          fetchNext: true
        })
      )
    }
  }

  const fetchHomeScreenData = useCallback(async () => {
    const promises: Promise<any>[] = []
    if (
      isAuthenticated &&
      (progressStatus === 'idle' || progressStatus === 'failed')
    ) {
      promises.push(dispatch(fetchProgressThunk()))
    }
    // Fetch featured articles if not already loading or fetched (or if forcing refresh)
    if (
      !featuredArticlesPagination.isLoading &&
      (!featuredArticlesPagination.hasFetched ||
        featuredArticlesPagination.error)
    ) {
      promises.push(
        dispatch(
          fetchArticles(HOME_FEATURED_ARTICLES_KEY, {
            reset: true
          })
        )
      )
    }
    if (promises.length > 0) {
      try {
        await Promise.all(promises)
      } catch (e) {
        console.error('Error fetching home screen data:', e)
      }
    }
  }, [
    dispatch,
    isAuthenticated,
    progressStatus,
    featuredArticlesPagination.isLoading,
    featuredArticlesPagination.hasFetched,
    featuredArticlesPagination.error
  ])

  useEffect(() => {
    fetchHomeScreenData()
  }, [fetchHomeScreenData])

  const [isRefreshing, handleRefresh] = useRefresh(fetchHomeScreenData)

  const navigateToFlashcards = useRequireAuthAction(
    () => router.push('/(main)/exercises/review-session'),
    'Login to review flashcards.'
  )
  const navigateToQuiz = useRequireAuthAction(() => {
    router.push('/(main)/challenges/daily')
  }, 'Login to play quiz games.')

  const navigateToNewWordsAndPronunciation = useRequireAuthAction(() => {
    router.push('/(main)/(tabs)/exercises')
  }, 'Login to learn new words or practice pronunciation.')

  return (
    <LinearGradient
      colors={[
        Colors.light.screenBackgroundGradientFrom,
        Colors.light.screenBackgroundGradientTo
      ]}
      style={styles.gradientBackground}
    >
      <SafeAreaView style={styles.container} edges={['top']}>
        <ScrollView
          contentContainerStyle={[
            styles.scrollContent,
            { paddingBottom: insets.bottom + 90 }
          ]}
          refreshControl={
            <RefreshControl
              refreshing={isRefreshing}
              onRefresh={handleRefresh}
              tintColor={Colors.light.primary}
              colors={[Colors.light.primary]}
            />
          }
          showsVerticalScrollIndicator={false}
        >
          <HomeHeader user={user} />
          <StreakCard progressSummary={progressSummary} />
          <DailyGoalCard progressSummary={progressSummary} />

          <View style={styles.featuredArticlesContainer}>
            <FeaturedArticles
              articles={featuredArticles}
              pagination={featuredArticlesPagination}
              marginHorizontal={24}
              onLoadMore={handleLoadMoreFeaturedArticles} // Pass load more handler
            />
          </View>

          <Text style={styles.sectionTitle}>Continue Learning</Text>
          <View style={styles.modulesGrid}>
            <LearningModuleCard
              title="Flashcards"
              description="Review today's words"
              iconUrl="https://cdn-icons-png.flaticon.com/512/2490/2490396.png"
              backgroundColor={Colors.light.moduleFlashcardBg}
              onPress={navigateToFlashcards}
            />
            <LearningModuleCard
              title="Quiz Game"
              description="Test your knowledge"
              iconUrl="https://cdn-icons-png.flaticon.com/512/3341/3341505.png"
              backgroundColor={Colors.light.moduleQuizBg}
              onPress={navigateToQuiz}
            />
            <LearningModuleCard
              title="New Words"
              description="Learn something new"
              iconUrl="https://cdn-icons-png.flaticon.com/512/4456/4456136.png"
              backgroundColor={Colors.light.moduleNewWordsBg}
              onPress={navigateToNewWordsAndPronunciation}
            />
          </View>
        </ScrollView>
      </SafeAreaView>
    </LinearGradient>
  )
}

const styles = StyleSheet.create({
  gradientBackground: { flex: 1 },
  container: { flex: 1 },
  scrollContent: { paddingHorizontal: 24, paddingTop: 10, paddingBottom: 120 },
  sectionTitle: {
    fontFamily: 'Inter-Bold',
    textAlign: 'center',
    color: Colors.light.text,
    marginBottom: 16,
    fontSize: 20
  },
  modulesGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between'
  },
  featuredArticlesContainer: { marginHorizontal: -24 }
})

```
src/app/(main)/(tabs)/profile.tsx
```
import React, { useEffect, useCallback } from 'react'
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  Image,
  TouchableOpacity,
  ActivityIndicator,
  RefreshControl
} from 'react-native'
import { SafeAreaView } from 'react-native-safe-area-context'
import {
  Settings,
  BookOpen,
  CheckCircle,
  BarChart,
  Award,
  Calendar,
  Zap,
  Clock
} from 'lucide-react-native'
import { Colors } from '@constants/Colors'
import { ProgressRing } from '@/components/profile/ProgressRing'
import { fetchProgressThunk } from '@features/progress/progressActions'
import {
  selectProgressSummary,
  selectProgressStatus
} from '@features/progress/progressSlice'
import { fetchEarnedAchievementsThunk } from '@features/achievements/achievementsActions'
import {
  selectEarnedAchievements,
  selectAchievementsStatus
} from '@features/achievements/achievementsSlice'
import { AchievementCard } from '@/components/profile/AchievementCard'
import { useResponsiveDimensions } from '@hooks/useResponsiveDimensions'
import { useSelector, useDispatch } from 'react-redux'
import { AppDispatch, RootState } from '@store/store'
import { selectUser } from '@features/auth/authSelectors'
import { useRouter, Link } from 'expo-router'
import { useProtectedRoute } from '@hooks/useProtectedRoute'
import { nameParser } from '@/utils/string'
import { useFloatingTabBarHeight } from '@/hooks/useFloatingTabBarHeight'
import { useRefresh } from '@/hooks/useRefresh'
import { FeaturedArticles } from '@/components/home/FeaturedArticles'
import { fetchSavedItemsThunk } from '@features/savedItems/savedItemsActions'
import {
  selectHydratedSavedArticles,
  selectSavedItemsStatus
} from '@/features/savedItems/savedItemsSlice'

export default function ProfileScreen() {
  const { isLoading: isAuthLoading, isAuthenticated } = useProtectedRoute()
  const { isDesktop } = useResponsiveDimensions()
  const dispatch = useDispatch<AppDispatch>()
  const router = useRouter()
  const floatingTabBarHeight = useFloatingTabBarHeight()

  // --- Selectors for state ---
  const userState = useSelector((state: RootState) => selectUser(state))
  const progressSummary = useSelector(selectProgressSummary)
  const progressStatus = useSelector(selectProgressStatus)
  const earnedAchievements = useSelector(selectEarnedAchievements)
  const achievementsStatus = useSelector(selectAchievementsStatus)

  // Correct way to get saved articles
  const savedArticles = useSelector(selectHydratedSavedArticles)
  const savedItemsStatus = useSelector(selectSavedItemsStatus)
  const savedItemsError = useSelector(
    (state: RootState) => state.savedItems.error
  )

  // --- Unified Data Fetching Logic ---
  const fetchProfileData = useCallback(async () => {
    if (isAuthenticated) {
      const promises: Promise<any>[] = []
      // Fetch progress if needed
      if (progressStatus === 'idle' || progressStatus === 'failed') {
        promises.push(dispatch(fetchProgressThunk()))
      }
      // Fetch achievements if needed
      if (achievementsStatus === 'idle' || achievementsStatus === 'failed') {
        promises.push(dispatch(fetchEarnedAchievementsThunk()))
      }
      // Fetch saved items if needed
      if (savedItemsStatus === 'idle' || savedItemsStatus === 'failed') {
        promises.push(dispatch(fetchSavedItemsThunk()))
      }
      if (promises.length > 0) {
        await Promise.all(promises)
      }
    }
  }, [
    dispatch,
    isAuthenticated,
    progressStatus,
    achievementsStatus,
    savedItemsStatus
  ])

  useEffect(() => {
    fetchProfileData()
  }, [fetchProfileData])

  const [isRefreshing, handleRefresh] = useRefresh(fetchProfileData)

  // Mock pagination state for FeaturedArticles component from savedItems state
  const savedArticlesPagination = {
    isLoading: savedItemsStatus === 'loading' && savedArticles.length === 0,
    error: savedItemsError,
    hasMore: false, // Saved items list is not paginated
    hasFetched: savedItemsStatus === 'succeeded' || savedArticles.length > 0,
    // Add other default fields to satisfy the type
    ids: [],
    currentPage: 1,
    pageSize: 20,
    nextPageKey: null,
    prevPageKey: null,
    totalCount: savedArticles.length,
    hasReachedEnd: true,
    lastSuccessfulFetchAt: null
  }

  if (isAuthLoading || !isAuthenticated || !userState) {
    return (
      <SafeAreaView style={[styles.container, styles.centered]} edges={['top']}>
        <ActivityIndicator size="large" color={Colors.light.primary} />
      </SafeAreaView>
    )
  }

  const userStats = progressSummary
    ? [
        {
          id: 'words',
          label: 'Words Learned',
          value: progressSummary.learned_words_count,
          icon: <CheckCircle size={18} color={Colors.light.primary} />
        },
        {
          id: 'articles',
          label: 'Articles Read',
          value: progressSummary.articles_read_count,
          icon: <BookOpen size={18} color={Colors.light.accent} />
        },
        {
          id: 'streak',
          label: 'Day Streak',
          value: progressSummary.streak.current_streak_days,
          icon: <Calendar size={18} color={Colors.light.warning} />
        },
        {
          id: 'exercises',
          label: 'Exercises Done',
          value: progressSummary.exercises_completed_count,
          icon: <Zap size={18} color={Colors.light.success} />
        }
      ]
    : []

  return (
    <SafeAreaView style={styles.container} edges={['top']}>
      <View style={styles.header}>
        <Text style={styles.screenTitle}>Profile</Text>
        <TouchableOpacity
          style={styles.settingsButton}
          onPress={() => router.push('/(main)/settings/')}
        >
          <Settings size={24} color={Colors.light.text} />
        </TouchableOpacity>
      </View>

      <ScrollView
        contentContainerStyle={[
          styles.scrollContent,
          isDesktop && styles.wideScreenContent,
          { paddingBottom: floatingTabBarHeight + 20 }
        ]}
        refreshControl={
          <RefreshControl
            refreshing={isRefreshing}
            onRefresh={handleRefresh}
            tintColor={Colors.light.primary}
          />
        }
      >
        <View style={styles.profileSection}>
          <Image
            source={{
              uri: `https://picsum.photos/seed/${userState?.id}/160/160`
            }}
            style={styles.profileImage}
          />
          <View style={styles.profileInfo}>
            <Text style={styles.profileName}>
              {nameParser(userState?.displayName || 'User', {
                maxLen: 32
              })}
            </Text>
            <Text style={styles.profileSubtitle}>
              Learning Finnish  Beginner
            </Text>
            <View style={styles.learningStatus}>
              <View style={styles.progressContainer}>
                <ProgressRing
                  progress={progressSummary?.progress_to_next_level ?? 0}
                  size={60}
                  strokeWidth={6}
                  color={Colors.light.primary}
                />
                <View style={styles.progressTextContainer}>
                  {progressSummary ? (
                    <>
                      <Text style={styles.progressPercentage}>
                        {Math.round(
                          (progressSummary.progress_to_next_level ?? 0) * 100
                        )}
                        %
                      </Text>
                      <Text style={styles.progressLabel}>
                        Level {progressSummary.level}
                      </Text>
                    </>
                  ) : progressStatus === 'loading' ? (
                    <ActivityIndicator size="small" />
                  ) : null}
                </View>
              </View>
              <View style={styles.divider} />
              <View style={styles.streakContainer}>
                <Award size={24} color={Colors.light.accent} />
                {progressStatus === 'loading' && !progressSummary ? (
                  <ActivityIndicator size="small" />
                ) : (
                  <Text style={styles.streakValue}>
                    {progressSummary?.streak?.current_streak_days ?? 0}
                  </Text>
                )}
                <Text style={styles.streakLabel}>Day Streak</Text>
              </View>
            </View>
          </View>
        </View>

        <View style={styles.statsContainer}>
          {progressStatus === 'loading' && !progressSummary ? (
            <ActivityIndicator />
          ) : (
            userStats.map(stat => (
              <View key={stat.id} style={styles.statItem}>
                <View style={styles.statIconContainer}>{stat.icon}</View>
                <Text style={styles.statValue}>{stat.value}</Text>
                <Text style={styles.statLabel}>{stat.label}</Text>
              </View>
            ))
          )}
          {progressStatus === 'failed' && (
            <Text style={styles.errorTextSmall}>Failed to load stats</Text>
          )}
        </View>

        {progressSummary?.category_progress &&
          progressSummary.category_progress.length > 0 && (
            <View style={styles.section}>
              <View style={styles.sectionHeader}>
                <Text style={styles.sectionTitle}>Time Spent by Category</Text>
              </View>
              <View style={styles.categoryProgressContainer}>
                {progressSummary.category_progress.map(catProg => (
                  <View key={catProg.category} style={styles.categoryItem}>
                    <Text style={styles.categoryName}>{catProg.category}</Text>
                    <View style={styles.categoryBarContainer}>
                      <View
                        style={[
                          styles.categoryBar,
                          {
                            width: `${Math.min(
                              100,
                              (catProg.time_spent_minutes /
                                (progressSummary.total_study_time_minutes ||
                                  1)) *
                                100
                            )}%`
                          }
                        ]}
                      />
                    </View>
                    <Text style={styles.categoryTime}>
                      {catProg.time_spent_minutes} min
                    </Text>
                  </View>
                ))}
                <View style={styles.totalTimeContainer}>
                  <Clock size={16} color={Colors.light.textSecondary} />
                  <Text style={styles.totalTimeText}>
                    Total Study Time: {progressSummary.total_study_time_minutes}{' '}
                    minutes
                  </Text>
                </View>
              </View>
            </View>
          )}

        {/* --- REPLACED SECTION FOR SAVED ARTICLES --- */}
        <View style={styles.savedArticlesSection}>
          <FeaturedArticles
            title="My Library"
            viewAllPath="/(main)/saved-articles"
            articles={savedArticles}
            pagination={savedArticlesPagination}
            marginHorizontal={20}
            onLoadMore={() => {}} // No pagination for this list on this screen
          />
        </View>

        <View style={styles.section}>
          <View style={styles.sectionHeader}>
            <Text style={styles.sectionTitle}>My Vocabulary</Text>
            <Link href="/(main)/vocabulary" asChild>
              <TouchableOpacity>
                <Text style={styles.viewAllText}>View all</Text>
              </TouchableOpacity>
            </Link>
          </View>
          <View style={styles.vocabularyCard}>
            <View style={styles.vocabularyHeader}>
              <View style={styles.vocabularyInfo}>
                <Text style={styles.vocabularyTitle}>Collected Words</Text>
                <Text style={styles.vocabularyCount}>145 words</Text>
              </View>
              <BarChart size={24} color={Colors.light.primary} />
            </View>
            <TouchableOpacity
              style={styles.practiceButton}
              onPress={() => router.push('/(main)/(tabs)/exercises')}
            >
              <Text style={styles.practiceButtonText}>Practice Vocabulary</Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.section}>
          <View style={styles.sectionHeader}>
            <Text style={styles.sectionTitle}>Achievements</Text>
            <Link href="/(main)/achievements" asChild>
              <TouchableOpacity>
                <Text style={styles.viewAllText}>View all</Text>
              </TouchableOpacity>
            </Link>
          </View>
          {achievementsStatus === 'loading' &&
            earnedAchievements.length === 0 && <ActivityIndicator />}
          {achievementsStatus === 'failed' && (
            <Text style={styles.errorTextSmall}>
              Failed to load achievements
            </Text>
          )}
          {achievementsStatus === 'succeeded' &&
            earnedAchievements.length === 0 && (
              <Text style={styles.emptySectionText}>
                No achievements earned yet.
              </Text>
            )}
          {earnedAchievements.length > 0 && (
            <View
              style={[
                styles.achievementsContainer,
                isDesktop && styles.wideScreenAchievements
              ]}
            >
              {earnedAchievements.slice(0, 4).map(achievement => (
                <AchievementCard
                  key={achievement.achievement_id}
                  achievement={achievement}
                />
              ))}
            </View>
          )}
        </View>
      </ScrollView>
    </SafeAreaView>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background
  },
  centered: {
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: Colors.light.background
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 12,
    backgroundColor: Colors.light.background
  },
  screenTitle: {
    fontFamily: 'Inter-Bold',
    fontSize: 22,
    color: Colors.light.text
  },
  settingsButton: {
    borderRadius: 22,
    backgroundColor: Colors.light.background,
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 3,
    elevation: 4,
    padding: 10
  },
  scrollContent: {
    paddingHorizontal: 20
  },
  wideScreenContent: {
    maxWidth: 900,
    alignSelf: 'center',
    width: '100%'
  },
  profileSection: {
    flexDirection: 'row',
    marginBottom: 24,
    alignItems: 'flex-start'
  },
  profileImage: {
    width: 72,
    height: 72,
    borderRadius: 36,
    marginRight: 16,
    borderWidth: 2,
    borderColor: Colors.common.white
  },
  profileInfo: { flex: 1, justifyContent: 'center' },
  profileName: {
    fontFamily: 'Inter-Bold',
    fontSize: 20,
    color: Colors.light.text,
    marginBottom: 2
  },
  profileSubtitle: {
    fontFamily: 'Inter-Regular',
    fontSize: 13,
    color: Colors.light.textSecondary,
    marginBottom: 10
  },
  learningStatus: { flexDirection: 'row', alignItems: 'center', marginTop: 8 },
  progressContainer: { flexDirection: 'row', alignItems: 'center' },
  progressTextContainer: { marginLeft: 10, alignItems: 'flex-start' },
  progressPercentage: {
    fontFamily: 'Inter-Bold',
    fontSize: 15,
    color: Colors.light.primary
  },
  progressLabel: {
    fontFamily: 'Inter-Regular',
    fontSize: 11,
    color: Colors.light.textSecondary
  },
  divider: {
    width: 1,
    height: 36,
    backgroundColor: Colors.light.border,
    marginHorizontal: 16
  },
  streakContainer: { alignItems: 'center' },
  streakValue: {
    fontFamily: 'Inter-Bold',
    fontSize: 18,
    color: Colors.light.text,
    marginTop: 4
  },
  streakLabel: {
    fontFamily: 'Inter-Regular',
    fontSize: 11,
    color: Colors.light.textSecondary
  },
  statsContainer: {
    flexDirection: 'row',
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 16,
    paddingVertical: 16,
    paddingHorizontal: 8,
    marginBottom: 24,
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
    justifyContent: 'space-around'
  },
  statItem: {
    flex: 1,
    alignItems: 'center',
    paddingHorizontal: 4
  },
  statIconContainer: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: Colors.light.backgroundSecondary,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 6
  },
  statValue: {
    fontFamily: 'Inter-Bold',
    fontSize: 17,
    color: Colors.light.text
  },
  statLabel: {
    fontFamily: 'Inter-Regular',
    fontSize: 11,
    color: Colors.light.textSecondary,
    textAlign: 'center',
    marginTop: 2
  },
  section: { marginBottom: 28 },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12
  },
  sectionTitle: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 19,
    color: Colors.light.text
  },
  viewAllText: {
    fontFamily: 'Inter-Medium',
    fontSize: 14,
    color: Colors.light.primary,
    marginRight: 2
  },
  vocabularyCard: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 16,
    padding: 16,
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3
  },
  vocabularyHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16
  },
  vocabularyInfo: {},
  vocabularyTitle: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 16,
    color: Colors.light.text,
    marginBottom: 2
  },
  vocabularyCount: {
    fontFamily: 'Inter-Regular',
    fontSize: 13,
    color: Colors.light.textSecondary
  },
  practiceButton: {
    backgroundColor: Colors.light.primary,
    borderRadius: 12,
    paddingVertical: 12,
    alignItems: 'center',
    justifyContent: 'center'
  },
  practiceButtonText: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 14,
    color: Colors.light.primaryContent
  },
  emptySectionText: {
    color: Colors.light.textSecondary,
    textAlign: 'center',
    fontFamily: 'Inter-Regular',
    paddingVertical: 30,
    fontSize: 14
  },
  errorTextSmall: {
    fontSize: 13,
    color: Colors.light.error,
    textAlign: 'center',
    width: '100%',
    paddingVertical: 10,
    fontFamily: 'Inter-Regular'
  },
  categoryProgressContainer: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 16,
    padding: 16,
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3
  },
  categoryItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 10,
    paddingBottom: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: Colors.light.borderSubtle
  },
  categoryName: {
    fontFamily: 'Inter-Medium',
    fontSize: 14,
    color: Colors.light.text,
    width: 100
  },
  categoryBarContainer: {
    flex: 1,
    height: 8,
    backgroundColor: Colors.light.backgroundSecondary,
    borderRadius: 4,
    marginHorizontal: 10,
    overflow: 'hidden'
  },
  categoryBar: {
    height: '100%',
    backgroundColor: Colors.light.primary,
    borderRadius: 4
  },
  categoryTime: {
    fontFamily: 'Inter-Regular',
    fontSize: 13,
    color: Colors.light.textSecondary,
    minWidth: 60,
    textAlign: 'right'
  },
  totalTimeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 15,
    paddingTop: 10,
    borderTopWidth: 1,
    borderTopColor: Colors.light.borderSubtle,
    justifyContent: 'center'
  },
  totalTimeText: {
    fontFamily: 'Inter-Regular',
    fontSize: 13,
    color: Colors.light.textSecondary,
    marginLeft: 6
  },
  achievementsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginHorizontal: -6 // Gutter compensation
  },
  wideScreenAchievements: {
    justifyContent: 'flex-start'
  },
  savedArticlesSection: {
    marginHorizontal: -20
  }
})

```
src/app/(main)/(tabs)/reader.tsx
```
import React, { useState, useRef, useEffect, useCallback } from 'react'
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  FlatList,
  ActivityIndicator,
  TouchableOpacity,
  ScrollView,
  RefreshControl,
  Platform,
  Alert
} from 'react-native'
import { SafeAreaView, useSafeAreaInsets } from 'react-native-safe-area-context'
import { Search, PlusCircle } from 'lucide-react-native'
import { Colors } from '@constants/Colors'
import { ArticleCard } from '@/components/reader/ArticleCard'
import { useRouter } from 'expo-router'
import { useResponsiveDimensions } from '@hooks/useResponsiveDimensions'
import { useSelector, useDispatch } from 'react-redux'
import { fetchArticles } from '@features/articles/articlesActions'
import { AppDispatch, RootState } from '@store/store'
import { selectUser } from '@features/auth/authSelectors'
import { selectPaginatedData } from '@pagination/selectors'
import { useRefresh } from '@hooks/useRefresh'
import { Article } from '@features/articles/types'
import { LinearGradient } from 'expo-linear-gradient'

const CATEGORIES = [
  { id: 'all', name: 'All' },
  { id: 'news', name: 'News' },
  { id: 'culture', name: 'Culture' },
  { id: 'sports', name: 'Sports' },
  { id: 'science', name: 'Science' },
  { id: 'technology', name: 'Technology' }
]

const ARTICLES_PAGINATION_KEY = (
  userId?: string,
  categoryId: string = 'all',
  searchQuery: string = ''
) => {
  const userPrefix = userId ? `user-${userId}` : 'public'
  const categorySuffix = categoryId === 'all' ? '' : `-cat-${categoryId}`
  const searchSuffix = searchQuery
    ? `-search-${encodeURIComponent(searchQuery.substring(0, 15))}`
    : ''
  return `${userPrefix}-articles-feed${categorySuffix}${searchSuffix}`
}

export default function ReaderScreen(): React.ReactElement {
  const router = useRouter()
  const { isDesktop } = useResponsiveDimensions()
  const dispatch = useDispatch<AppDispatch>()
  const user = useSelector((state: RootState) => selectUser(state))
  const insets = useSafeAreaInsets()
  const tabBarHeight = 70 + 15 + insets.bottom

  const [searchQuery, setSearchQuery] = useState('')
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('')
  const [selectedCategory, setSelectedCategory] = useState('all')
  const [isSearchFocused, setIsSearchFocused] = useState(false)
  const searchRef = useRef<TextInput>(null)

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedSearchQuery(searchQuery)
    }, 500)
    return () => clearTimeout(handler)
  }, [searchQuery])

  const currentPaginationKey = ARTICLES_PAGINATION_KEY(
    user?.id,
    selectedCategory,
    debouncedSearchQuery
  )

  const { data: articles, pagination } = useSelector((state: RootState) =>
    selectPaginatedData(
      'articles',
      'articlePagination',
      currentPaginationKey,
      false
    )(state)
  )

  const fetchArticlesList = useCallback(
    (options?: { reset?: boolean; fetchNext?: boolean }) => {
      let queryParams: Record<string, any> = {}
      if (selectedCategory !== 'all') {
        queryParams.category = selectedCategory
      }
      if (debouncedSearchQuery) {
        queryParams.q = debouncedSearchQuery
      }
      dispatch(
        fetchArticles(currentPaginationKey, {
          ...options,
          additionalQueryParams: queryParams
        })
      )
    },
    [dispatch, currentPaginationKey, selectedCategory, debouncedSearchQuery]
  )

  useEffect(() => {
    if (!pagination.isLoading && !pagination.hasFetched) {
      fetchArticlesList({ reset: true })
    }
  }, [fetchArticlesList, pagination.isLoading, pagination.hasFetched])

  const [isRefreshing, handleRefresh] = useRefresh(async () => {
    await fetchArticlesList({ reset: true, forceRefresh: true })
  })

  const handleLoadMore = () => {
    if (!pagination.isLoading && pagination.hasMore) {
      fetchArticlesList({ fetchNext: true })
    }
  }

  const handleAddArticle = () => {
    Alert.alert(
      'Add Article',
      'Feature to add new articles is not yet implemented.'
    )
  }

  const renderFooter = () => {
    if (!pagination.isLoading && !pagination.hasMore && articles.length > 0) {
      return <Text style={styles.listEndText}>No more articles.</Text>
    }
    if (pagination.isLoading && articles.length > 0) {
      return (
        <ActivityIndicator
          style={{ marginVertical: 20 }}
          color={Colors.light.primary}
        />
      )
    }
    return null
  }

  return (
    <LinearGradient
      colors={[Colors.common.white, Colors.light.backgroundSecondary]}
      style={styles.gradientBackground}
    >
      <SafeAreaView style={styles.container} edges={['top']}>
        <View style={styles.header}>
          <Text style={styles.headerTitle}>Reader</Text>
          <TouchableOpacity
            style={styles.headerButton}
            onPress={handleAddArticle}
          >
            <PlusCircle size={24} color={Colors.light.text} />
          </TouchableOpacity>
        </View>

        <View style={styles.searchContainer}>
          <View
            style={[
              styles.searchInputContainer,
              isSearchFocused && styles.searchInputFocused
            ]}
          >
            <Search size={20} color={Colors.light.textTertiary} />
            <TextInput
              ref={searchRef}
              style={styles.searchInput}
              placeholder="Search articles..."
              placeholderTextColor={Colors.light.textTertiary}
              value={searchQuery}
              onChangeText={setSearchQuery}
              // onFocus={() => setIsSearchFocused(true)}
              // onBlur={() => setIsSearchFocused(false)}
              returnKeyType="search"
              onSubmitEditing={() => fetchArticlesList({ reset: true })}
            />
          </View>
        </View>

        <View style={styles.categoriesContainer}>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={styles.categoriesScrollContent}
          >
            {CATEGORIES.map(category => (
              <TouchableOpacity
                key={category.id}
                style={[
                  styles.categoryButton,
                  selectedCategory === category.id &&
                    styles.categoryButtonActive
                ]}
                onPress={() => {
                  setSelectedCategory(category.id)
                }}
              >
                <Text
                  style={[
                    styles.categoryButtonText,
                    selectedCategory === category.id &&
                      styles.categoryButtonTextActive
                  ]}
                >
                  {category.name}
                </Text>
              </TouchableOpacity>
            ))}
          </ScrollView>
        </View>

        {pagination.isLoading && articles.length === 0 ? (
          <View style={styles.centeredLoader}>
            <ActivityIndicator size="large" color={Colors.light.primary} />
          </View>
        ) : (
          <FlatList
            data={articles}
            keyExtractor={item => item.id}
            renderItem={({ item }) => (
              <ArticleCard
                article={item}
                onPress={() => router.push(`/(main)/reader/${item.id}`)}
              />
            )}
            contentContainerStyle={[
              styles.articlesContainer,
              isDesktop && styles.wideScreenArticlesContainer,
              { paddingBottom: tabBarHeight + 20 }
            ]}
            ListEmptyComponent={
              !pagination.isLoading && articles.length === 0 ? (
                <Text style={styles.emptyText}>
                  No articles found for "{selectedCategory}"{' '}
                  {debouncedSearchQuery
                    ? `matching "${debouncedSearchQuery}"`
                    : ''}
                  .
                </Text>
              ) : null
            }
            refreshControl={
              <RefreshControl
                refreshing={isRefreshing}
                onRefresh={handleRefresh}
                tintColor={Colors.light.primary}
              />
            }
            onEndReached={handleLoadMore}
            onEndReachedThreshold={0.7}
            ListFooterComponent={renderFooter}
            showsVerticalScrollIndicator={false}
          />
        )}
      </SafeAreaView>
    </LinearGradient>
  )
}

const styles = StyleSheet.create({
  gradientBackground: { flex: 1 },
  container: {
    flex: 1
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 12,
    backgroundColor: Colors.light.background
  },
  headerTitle: {
    fontFamily: 'Inter-Bold',
    fontSize: 22,
    color: Colors.light.text
  },
  headerButton: {
    padding: 6
  },
  searchContainer: {
    paddingHorizontal: 20,
    paddingVertical: 12,
    backgroundColor: Colors.light.background
  },
  searchInputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.light.cardBackgroundSubtle,
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: Platform.OS === 'ios' ? 12 : 8,
    borderWidth: 1,
    borderColor: Colors.light.borderSubtle
  },
  searchInputFocused: {
    borderColor: Colors.light.primary,
    shadowColor: Colors.light.primary,
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.2,
    shadowRadius: 3,
    elevation: 2
  },
  searchInput: {
    flex: 1,
    marginLeft: 10,
    fontFamily: 'Inter-Regular',
    fontSize: 15,
    color: Colors.light.text
  },
  categoriesContainer: {
    paddingVertical: 8,
    backgroundColor: Colors.light.background,
    borderBottomWidth: 1,
    borderBottomColor: Colors.light.border,
    marginBottom: 8
  },
  categoriesScrollContent: {
    paddingHorizontal: 16,
    paddingVertical: 4,
    gap: 10
  },
  categoryButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    backgroundColor: Colors.light.cardBackgroundSubtle,
    borderWidth: 1,
    borderColor: Colors.light.borderSubtle
  },
  categoryButtonActive: {
    backgroundColor: Colors.light.primary,
    borderColor: Colors.light.primary
  },
  categoryButtonText: {
    fontFamily: 'Inter-Medium',
    fontSize: 13,
    color: Colors.light.textSecondary
  },
  categoryButtonTextActive: {
    color: Colors.light.primaryContent,
    fontFamily: 'Inter-SemiBold'
  },
  articlesContainer: {
    paddingHorizontal: 20,
    paddingTop: 10
  },
  wideScreenArticlesContainer: {
    maxWidth: 768,
    alignSelf: 'center',
    width: '100%'
  },
  centeredLoader: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center'
  },
  emptyText: {
    textAlign: 'center',
    marginTop: 50,
    color: Colors.light.textSecondary,
    paddingHorizontal: 40,
    fontSize: 15,
    fontFamily: 'Inter-Regular'
  },
  listEndText: {
    textAlign: 'center',
    color: Colors.light.textTertiary,
    paddingVertical: 20,
    fontFamily: 'Inter-Regular'
  }
})

```
src/app/(main)/challenges/daily.tsx
```
import React, { useCallback, useEffect } from 'react'
import {
  View,
  Text,
  StyleSheet,
  ActivityIndicator,
  TouchableOpacity,
  ScrollView,
  Platform,
  RefreshControl
} from 'react-native'
import { useDispatch, useSelector } from 'react-redux'
import { Stack, useRouter } from 'expo-router'
import { SafeAreaView, useSafeAreaInsets } from 'react-native-safe-area-context'
import { LinearGradient } from 'expo-linear-gradient'
import {
  CheckCircle,
  PlayCircle,
  BookOpen,
  ChevronRight,
  AlertTriangle,
  Sparkles,
  ChevronLeft
} from 'lucide-react-native'

import { AppDispatch, RootState } from '@store/store'
import {
  fetchDailyChallengeThunk,
  updateDailyChallengeStatusThunk,
  selectCurrentDailyChallenge,
  selectDailyChallengeFetchStatus,
  selectDailyChallengeFetchError
} from '@features/challenges/challengesSlice'
import {
  ChallengeSection,
  ChallengeLessonSection,
  ChallengeContextualPracticeSection,
  ChallengeNSRSection
} from '@features/challenges/types'
import { Colors } from '@constants/Colors'
import { LessonData } from '@/features/lessons/types'
import { useRefresh } from '@/hooks/useRefresh'

export default function DailyChallengeScreen(): React.ReactElement {
  const dispatch = useDispatch<AppDispatch>()
  const router = useRouter()
  const insets = useSafeAreaInsets()

  const challenge = useSelector(selectCurrentDailyChallenge)
  const status = useSelector(selectDailyChallengeFetchStatus)
  const error = useSelector(selectDailyChallengeFetchError)

  const fetchChallengeData = useCallback(() => {
    if (status === 'idle' && !challenge) {
      return dispatch(fetchDailyChallengeThunk())
    }
    if (challenge) {
      return dispatch(fetchDailyChallengeThunk())
    }
    return Promise.resolve()
  }, [dispatch, status, challenge])

  useEffect(() => {
    if (status === 'idle' && !challenge) {
      fetchChallengeData()
    }
  }, [fetchChallengeData, status, challenge])

  const [isRefreshing, handleRefresh] = useRefresh(fetchChallengeData)

  const handleStartSection = (
    section: ChallengeSection,
    sectionArrayIndex: number
  ) => {
    if (!challenge) return

    if (challenge.status === 'generated') {
      dispatch(
        updateDailyChallengeStatusThunk({
          challengeId: challenge.challenge_id,
          newStatus: 'started'
        })
      )
    }

    const commonParams = {
      challenge_id: challenge.challenge_id,
      challenge_section_array_index: String(sectionArrayIndex)
    }

    let path = ''
    let params: Record<string, string | undefined> = { ...commonParams }

    if (section.type === 'spaced_repetition_review') {
      path = '/(main)/exercises/review-session'
    } else if (
      section.type === 'targeted_weakness_practice' ||
      section.type === 'lesson_practice'
    ) {
      const lessonSection = section as ChallengeLessonSection
      if (
        !lessonSection.lesson_details ||
        !lessonSection.lesson_details.exercises
      ) {
        console.error(
          'ERROR: lesson_details or exercises missing for lesson section!'
        )
        return
      }
      path = '/(main)/exercises/player'
      params.lessonDataString = JSON.stringify(lessonSection.lesson_details)
    } else if (section.type === 'contextual_practice') {
      const contextualSection = section as ChallengeContextualPracticeSection
      if (!contextualSection.exercises) {
        console.error(
          'ERROR: exercises missing for contextual_practice section!'
        )
        return
      }
      const lessonDataForPlayer: LessonData = {
        lesson_id: `challenge_contextual_${challenge?.challenge_id}_${sectionArrayIndex}`,
        lesson_title: section.title,
        description: 'Practice items related to your recent activity.',
        exercises: contextualSection.exercises,
        user_id: challenge?.user_id || ''
      }
      path = '/(main)/exercises/player'
      params.lessonDataString = JSON.stringify(lessonDataForPlayer)
    } else {
      console.warn(
        'Unhandled challenge section type for navigation:',
        section.type
      )
      return
    }
    router.push({ pathname: path, params })
  }

  const handleCompleteChallenge = () => {
    if (challenge && challenge.status !== 'completed') {
      dispatch(
        updateDailyChallengeStatusThunk({
          challengeId: challenge.challenge_id,
          newStatus: 'completed'
        })
      )
    }
  }

  const handleGoBack = () => {
    if (router.canGoBack()) router.back()
    else router.replace('/(main)/(tabs)/')
  }

  if (status === 'loading') {
    return (
      <LinearGradient
        colors={[Colors.light.accentGreenLight, Colors.light.background]}
        style={styles.gradientBackgroundFull}
        start={{ x: 0.5, y: 0 }}
        end={{ x: 0.5, y: 0.4 }}
      >
        <SafeAreaView style={styles.containerCentered}>
          <ActivityIndicator size="large" color={Colors.light.accentGreen} />
          <Text
            style={[styles.infoText, { color: Colors.light.textSecondary }]}
          >
            Loading Daily Challenge...
          </Text>
        </SafeAreaView>
      </LinearGradient>
    )
  }

  if (status === 'failed' || !challenge) {
    return (
      <LinearGradient
        colors={[Colors.light.accentGreenLight, Colors.light.background]}
        style={styles.gradientBackgroundFull}
        start={{ x: 0.5, y: 0 }}
        end={{ x: 0.5, y: 0.4 }}
      >
        <SafeAreaView style={styles.containerCentered}>
          <View
            style={[
              styles.customHeader,
              { paddingTop: Platform.OS === 'android' ? insets.top : 0 }
            ]}
          >
            <TouchableOpacity
              onPress={handleGoBack}
              style={styles.headerBackButton}
            >
              <ChevronLeft size={24} color={Colors.light.text} />
            </TouchableOpacity>
            <Text style={styles.headerTitle}>Daily Challenge</Text>
            <View style={{ width: 30 }} />
          </View>
          <View
            style={{
              flex: 1,
              justifyContent: 'center',
              alignItems: 'center',
              paddingHorizontal: 20
            }}
          >
            <AlertTriangle
              size={40}
              color={Colors.light.error}
              style={{ marginBottom: 10 }}
            />
            <Text style={styles.errorText}>
              Could not load challenge: {error}
            </Text>
            <TouchableOpacity
              style={styles.retryButton}
              onPress={() => dispatch(fetchDailyChallengeThunk())}
            >
              <Text style={styles.retryButtonText}>Try Again</Text>
            </TouchableOpacity>
          </View>
        </SafeAreaView>
      </LinearGradient>
    )
  }

  const allSectionsCompleted = challenge.sections.every(s => s.is_completed)

  if (
    challenge.status === 'completed' ||
    (allSectionsCompleted && status === 'succeeded')
  ) {
    return (
      <LinearGradient
        colors={[Colors.light.accentGreenLight, Colors.light.background]}
        style={styles.gradientBackgroundFull}
        start={{ x: 0.5, y: 0 }}
        end={{ x: 0.5, y: 0.4 }}
      >
        <SafeAreaView style={styles.containerCentered}>
          <View
            style={[
              styles.customHeader,
              { paddingTop: Platform.OS === 'android' ? insets.top : 0 }
            ]}
          >
            <TouchableOpacity
              onPress={handleGoBack}
              style={styles.headerBackButton}
            >
              <ChevronLeft size={24} color={Colors.light.text} />
            </TouchableOpacity>
            <Text style={styles.headerTitle}>Challenge Complete!</Text>
            <View style={{ width: 30 }} />
          </View>
          <View
            style={{
              flex: 1,
              justifyContent: 'center',
              alignItems: 'center',
              paddingHorizontal: 20
            }}
          >
            <CheckCircle
              size={60}
              color={Colors.light.success}
              style={{ marginBottom: 20 }}
            />
            <Text style={styles.pageTitle}>Challenge Complete!</Text>
            <Text style={styles.infoTextNormal}>{challenge.title}</Text>
            <Text style={styles.infoTextNormal}>
              You earned {challenge.total_reward_points || 0} points!
            </Text>
            <TouchableOpacity
              style={[
                styles.actionButton,
                { backgroundColor: Colors.light.accentGreen }
              ]}
              onPress={() => router.replace('/(main)/(tabs)/')}
            >
              <Text style={styles.actionButtonText}>Back to Dashboard</Text>
            </TouchableOpacity>
          </View>
        </SafeAreaView>
      </LinearGradient>
    )
  }

  function getSectionIcon(sectionType: string, isCompleted?: boolean) {
    const color = isCompleted ? Colors.common.white : Colors.light.accentGreen
    switch (sectionType) {
      case 'spaced_repetition_review':
        return <BookOpen size={22} color={color} />
      case 'targeted_weakness_practice':
      case 'lesson_practice':
        return <PlayCircle size={22} color={color} />
      case 'contextual_practice':
        return <Sparkles size={22} color={color} />
      default:
        return <PlayCircle size={22} color={color} />
    }
  }

  return (
    <LinearGradient
      colors={[Colors.light.accentGreenLight, Colors.light.background]}
      style={styles.gradientBackgroundFull}
      start={{ x: 0.5, y: 0 }}
      end={{ x: 0.5, y: 0.4 }}
    >
      <SafeAreaView style={styles.container} edges={['top', 'bottom']}>
        <Stack.Screen options={{ headerShown: false }} />
        <View
          style={[
            styles.customHeader,
            { paddingTop: Platform.OS === 'android' ? insets.top : 0 }
          ]}
        >
          <TouchableOpacity
            onPress={handleGoBack}
            style={styles.headerBackButton}
          >
            <ChevronLeft size={24} color={Colors.light.text} />
          </TouchableOpacity>
          <Text style={styles.headerTitle}>Daily Challenge</Text>
          <View style={{ width: 30 }} />
        </View>

        <ScrollView
          contentContainerStyle={styles.scrollContent}
          refreshControl={
            <RefreshControl
              refreshing={isRefreshing}
              onRefresh={handleRefresh}
              tintColor={Colors.light.accentGreen}
            />
          }
        >
          <View style={styles.challengeHeaderInfo}>
            <Text style={styles.challengeTitleText}>{challenge.title}</Text>
            <Text style={styles.challengeDateText}>
              {new Date(challenge.challenge_date).toLocaleDateString('en-GB', {
                weekday: 'long',
                month: 'long',
                day: 'numeric'
              })}
            </Text>
            {challenge.estimated_total_time_minutes && (
              <Text style={styles.challengeMetaText}>
                Approx. {challenge.estimated_total_time_minutes} min
              </Text>
            )}
          </View>

          {challenge.sections.map((section, index) => (
            <TouchableOpacity
              key={index}
              style={[
                styles.sectionCard,
                section.is_completed && styles.sectionCompletedCard
              ]}
              onPress={() =>
                !section.is_completed && handleStartSection(section, index)
              }
              disabled={section.is_completed}
            >
              <View
                style={[
                  styles.sectionIconContainer,
                  section.is_completed && {
                    backgroundColor: Colors.light.success
                  }
                ]}
              >
                {getSectionIcon(section.type, section.is_completed)}
              </View>
              <View style={styles.sectionTextContainer}>
                <Text style={styles.sectionTitleCardText}>{section.title}</Text>
                {section.type === 'targeted_weakness_practice' &&
                  (section as ChallengeLessonSection).lesson_details && (
                    <Text style={styles.sectionSubtitleText}>
                      Lesson:{' '}
                      {
                        (section as ChallengeLessonSection).lesson_details
                          .lesson_title
                      }
                    </Text>
                  )}
                {section.type === 'contextual_practice' &&
                  (section as ChallengeContextualPracticeSection).exercises && (
                    <Text style={styles.sectionSubtitleText}>
                      Practice{' '}
                      {
                        (section as ChallengeContextualPracticeSection)
                          .exercises.length
                      }{' '}
                      quick items
                    </Text>
                  )}
                {section.type === 'spaced_repetition_review' &&
                  (section as ChallengeNSRSection).items && (
                    <Text style={styles.sectionSubtitleText}>
                      Complete {(section as ChallengeNSRSection).items.length}{' '}
                      reviews
                    </Text>
                  )}
              </View>
              {section.is_completed ? (
                <CheckCircle size={24} color={Colors.light.success} />
              ) : (
                <ChevronRight size={20} color={Colors.light.textSecondary} />
              )}
            </TouchableOpacity>
          ))}

          {allSectionsCompleted && challenge.status !== 'completed' && (
            <TouchableOpacity
              style={[styles.actionButton, styles.completeChallengeButton]}
              onPress={handleCompleteChallenge}
              disabled={status === 'loading'}
            >
              {status === 'loading' ? (
                <ActivityIndicator color={Colors.light.primaryContent} />
              ) : (
                <Text style={styles.actionButtonText}>
                  Mark Challenge Complete
                </Text>
              )}
            </TouchableOpacity>
          )}
        </ScrollView>
      </SafeAreaView>
    </LinearGradient>
  )
}

const styles = StyleSheet.create({
  gradientBackgroundFull: { flex: 1 },
  container: { flex: 1 },
  containerCentered: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center'
  },
  customHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 15,
    paddingTop: Platform.OS === 'android' ? 10 : 0,
    paddingBottom: 10
  },
  headerBackButton: {
    padding: 8
  },
  headerTitle: {
    fontSize: 17,
    fontFamily: 'Inter-SemiBold',
    color: Colors.light.text
  },
  scrollContent: {
    paddingHorizontal: 20,
    paddingTop: 10,
    paddingBottom: 40
  },
  pageTitle: {
    fontSize: 26,
    fontFamily: 'Inter-Bold',
    color: Colors.light.text,
    marginBottom: 12,
    textAlign: 'center'
  },
  infoText: {
    fontSize: 16,
    fontFamily: 'Inter-Regular',
    textAlign: 'center',
    marginTop: 10
  },
  infoTextNormal: {
    fontSize: 16,
    fontFamily: 'Inter-Regular',
    color: Colors.light.textSecondary,
    textAlign: 'center',
    marginBottom: 8,
    lineHeight: 22
  },
  errorText: {
    fontSize: 16,
    fontFamily: 'Inter-Medium',
    color: Colors.light.error,
    textAlign: 'center',
    marginBottom: 20
  },
  retryButton: {
    backgroundColor: Colors.light.accentGreen,
    paddingVertical: 12,
    paddingHorizontal: 30,
    borderRadius: 25
  },
  retryButtonText: {
    color: Colors.light.primaryContent,
    fontSize: 16,
    fontFamily: 'Inter-SemiBold'
  },
  actionButton: {
    backgroundColor: Colors.light.primary,
    paddingVertical: 14,
    paddingHorizontal: 30,
    borderRadius: 25,
    marginTop: 24,
    alignSelf: 'center'
  },
  actionButtonText: {
    color: Colors.light.primaryContent,
    fontSize: 16,
    fontFamily: 'Inter-SemiBold'
  },
  challengeHeaderInfo: {
    marginBottom: 25,
    paddingBottom: 15,
    borderBottomWidth: 1,
    borderBottomColor: Colors.light.borderSubtle,
    alignItems: 'center'
  },
  challengeTitleText: {
    fontSize: 24,
    fontFamily: 'Inter-Bold',
    color: Colors.light.text,
    marginBottom: 6,
    textAlign: 'center'
  },
  challengeDateText: {
    fontSize: 14,
    fontFamily: 'Inter-Regular',
    color: Colors.light.textSecondary,
    marginBottom: 8
  },
  challengeMetaText: {
    fontSize: 14,
    fontFamily: 'Inter-Medium',
    color: Colors.light.accentGreen
  },
  sectionCard: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 16,
    padding: 16,
    marginBottom: 16,
    flexDirection: 'row',
    alignItems: 'center',
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.08,
    shadowRadius: 4,
    elevation: 3,
    borderWidth: 1,
    borderColor: Colors.light.borderSubtle
  },
  sectionCompletedCard: {
    opacity: 0.8,
    backgroundColor: Colors.light.backgroundSecondary,
    borderColor: Colors.light.success
  },
  sectionIconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: Colors.light.accentGreenLight,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12
  },
  sectionTextContainer: {
    flex: 1,
    marginRight: 8
  },
  sectionTitleCardText: {
    fontSize: 17,
    fontFamily: 'Inter-SemiBold',
    color: Colors.light.text,
    marginBottom: 3
  },
  sectionSubtitleText: {
    fontSize: 13,
    fontFamily: 'Inter-Regular',
    color: Colors.light.textSecondary
  },
  completeChallengeButton: {
    backgroundColor: Colors.light.success,
    marginTop: 24
  }
})

```
src/app/(main)/exercises/player.tsx
```
import React, { useState, useEffect, useMemo } from 'react'
import {
  View,
  Text,
  StyleSheet,
  ActivityIndicator,
  TouchableOpacity,
  Alert,
  ScrollView,
  Platform
} from 'react-native'
import { useDispatch } from 'react-redux'
import { Stack, useLocalSearchParams, useRouter } from 'expo-router'
import { LinearGradient } from 'expo-linear-gradient'

import { AppDispatch } from '@store/store'
import { reportReviewOutcomeThunk } from '@features/reviews/reviewsSlice'
import { ReviewOutcomePayload, ReviewItem } from '@features/reviews/types'
import { markChallengeSectionCompleted } from '@/features/challenges/challengesSlice'
import {
  LessonData,
  LessonExercise,
  KLearnMCTranslationExercise
} from '@features/lessons/types'

import { FillInTheBlankExerciseCard } from '@components/exercises/FillInTheBlankExerciseCard'
import { MultipleChoiceTranslationExerciseCard } from '@components/exercises/MultipleChoiceTranslationExerciseCard'
import { SentenceConstructionExerciseCard } from '@components/exercises/SentenceConstructionExerciseCard'
import { FlashcardExerciseCard } from '@components/exercises/FlashcardExerciseCard'
import { GrammarRuleExplanationCard } from '@components/exercises/GrammarRuleExplanationCard'
import { IdentifyTheConceptExerciseCard } from '@components/exercises/IdentifyTheConceptExerciseCard'

import { Colors } from '@constants/Colors'
import { ChevronLeft, Star } from 'lucide-react-native'
import { useSafeAreaInsets, SafeAreaView } from 'react-native-safe-area-context'

export default function LessonPlayerScreen(): React.ReactElement {
  const dispatch = useDispatch<AppDispatch>()
  const router = useRouter()
  const insets = useSafeAreaInsets()
  const { lessonDataString, challenge_id, challenge_section_array_index } =
    useLocalSearchParams<{
      lessonDataString?: string
      challenge_id?: string
      challenge_section_array_index?: string
    }>()

  const [lesson, setLesson] = useState<LessonData | null>(null)
  const [currentExerciseIndex, setCurrentExerciseIndex] = useState(0)
  const [playerStatus, setPlayerStatus] = useState<
    'loading' | 'playing' | 'completed' | 'error'
  >('loading')
  const [exerciseResults, setExerciseResults] = useState<
    Array<{ exerciseType: string; correct: boolean }>
  >([])

  const isQuizMode =
    lesson?.lesson_title?.toLowerCase().includes('quiz') ||
    !!challenge_id ||
    lesson?.exercises.every(
      ex => ex.exercise_type === 'multiple_choice_translation'
    )

  useEffect(() => {
    if (lessonDataString) {
      try {
        const parsedLesson: LessonData = JSON.parse(lessonDataString)
        if (
          parsedLesson &&
          parsedLesson.exercises &&
          parsedLesson.exercises.length > 0
        ) {
          setLesson(parsedLesson)
          setCurrentExerciseIndex(0)
          setExerciseResults([])
          setPlayerStatus('playing')
        } else {
          console.error(
            'Player: Parsed lesson invalid or no exercises.',
            parsedLesson
          )
          setPlayerStatus('error')
        }
      } catch (e) {
        console.error('Player: Failed to parse lessonDataString.', e)
        setPlayerStatus('error')
      }
    } else {
      console.error('Player: lessonDataString is missing.')
      setPlayerStatus('error')
    }
  }, [lessonDataString])

  const correctAnswersCount = useMemo(() => {
    return exerciseResults.filter(r => r.correct).length
  }, [exerciseResults])

  const completeLessonAndNotifyChallenge = (
    finalResults: Array<{ exerciseType: string; correct: boolean }>
  ) => {
    if (challenge_id && challenge_section_array_index !== undefined) {
      const sectionIndexNum = parseInt(challenge_section_array_index, 10)
      if (!isNaN(sectionIndexNum)) {
        dispatch(
          markChallengeSectionCompleted({ sectionArrayIndex: sectionIndexNum })
        )
      }
    }
    const correctCount = finalResults.filter(r => r.correct).length
    const totalCount = lesson?.exercises.length || 0
    const scoreMessage =
      totalCount > 0
        ? `You got ${correctCount} out of ${totalCount} correct.`
        : 'Lesson finished.'
    Alert.alert('Lesson Complete!', scoreMessage, [
      {
        text: 'OK',
        onPress: () =>
          router.canGoBack()
            ? router.back()
            : router.replace('/(main)/(tabs)/exercises')
      }
    ])
  }

  const handleAnswered = (
    isCorrect: boolean,
    userAnswer: string,
    exerciseDetails: LessonExercise
  ) => {
    const newResults = [
      ...exerciseResults,
      { exerciseType: exerciseDetails.exercise_type, correct: isCorrect }
    ]
    setExerciseResults(newResults)

    const { item_id_fk, item_type_fk } = exerciseDetails
    if (item_id_fk && item_type_fk) {
      const outcomePayload: ReviewOutcomePayload = {
        interaction_success: isCorrect,
        review_timestamp_client: new Date().toISOString(),
        review_interaction_type: `lesson_player_${exerciseDetails.exercise_type}`
      }
      const itemForReportingThunk: ReviewItem = {
        item_id: item_id_fk,
        item_type: item_type_fk,
        display_text:
          (exerciseDetails as any).prompt ||
          (exerciseDetails as any).source_phrase ||
          lesson?.lesson_title ||
          'Exercise Item'
      }
      dispatch(
        reportReviewOutcomeThunk({
          item: itemForReportingThunk,
          outcome: outcomePayload
        })
      )
    }

    if (lesson && currentExerciseIndex < lesson.exercises.length - 1) {
      setCurrentExerciseIndex(currentExerciseIndex + 1)
    } else {
      setPlayerStatus('completed')
      completeLessonAndNotifyChallenge(newResults)
    }
  }

  const PlayerWrapper = isQuizMode ? LinearGradient : View
  const playerWrapperProps = isQuizMode
    ? {
        colors: [
          Colors.light.quizScreenGradientFrom,
          Colors.light.quizScreenGradientTo
        ],
        style: styles.quizGradientBackground
      }
    : { style: styles.container }

  if (playerStatus === 'loading') {
    return (
      <PlayerWrapper {...playerWrapperProps}>
        <SafeAreaView
          style={styles.containerCentered}
          edges={['top', 'bottom']}
        >
          <ActivityIndicator
            size="large"
            color={isQuizMode ? Colors.light.text : Colors.light.primary}
          />
          <Text
            style={isQuizMode ? styles.quizLoadingText : styles.loadingText}
          >
            Loading Lesson...{' '}
          </Text>
        </SafeAreaView>
      </PlayerWrapper>
    )
  }

  if (playerStatus === 'error' || !lesson) {
    return (
      <PlayerWrapper {...playerWrapperProps}>
        <SafeAreaView style={styles.container} edges={['top', 'bottom']}>
          <View
            style={[
              styles.customHeader,
              { paddingTop: Platform.OS === 'android' ? insets.top : 0 }
            ]}
          >
            <TouchableOpacity
              onPress={() => router.back()}
              style={styles.headerBackButtonOnError}
            >
              <ChevronLeft size={22} color={Colors.light.textSecondary} />
            </TouchableOpacity>
            <View style={{ width: 40 }} />
          </View>
          <View style={styles.centeredContentMessage}>
            <Text style={styles.errorText}>
              Could not load the lesson. Please try again.
            </Text>
            <TouchableOpacity
              style={styles.actionButton}
              onPress={() => router.back()}
            >
              <Text style={styles.actionButtonText}>Go Back</Text>
            </TouchableOpacity>
          </View>
        </SafeAreaView>
      </PlayerWrapper>
    )
  }

  if (playerStatus === 'completed') {
    const totalCount = lesson.exercises.length || 0
    const score =
      totalCount > 0 ? Math.round((correctAnswersCount / totalCount) * 100) : 0
    return (
      <PlayerWrapper {...playerWrapperProps}>
        <SafeAreaView style={styles.container} edges={['top', 'bottom']}>
          <Stack.Screen
            options={{ title: 'Lesson Finished', headerShown: false }}
          />
          <View
            style={[
              styles.customHeader,
              { paddingTop: Platform.OS === 'android' ? insets.top : 0 }
            ]}
          >
            <TouchableOpacity
              onPress={() =>
                router.canGoBack()
                  ? router.back()
                  : router.replace(
                      challenge_id
                        ? `/(main)/challenges/daily`
                        : '/(main)/(tabs)/exercises'
                    )
              }
              style={styles.headerBackButtonOnError}
            >
              <ChevronLeft size={22} color={Colors.light.textSecondary} />
            </TouchableOpacity>
            <Text style={styles.headerTitle}>Lesson Finished!</Text>
            <View style={{ width: 40 }} />
          </View>
          <View style={styles.centeredContentMessage}>
            <Text style={styles.completionTitle}>Nicely Done </Text>
            <Text style={styles.completionScore}>
              Your score: {score}% ({correctAnswersCount}/{totalCount}){' '}
            </Text>
            <TouchableOpacity
              style={styles.successActionButton}
              onPress={() =>
                router.canGoBack()
                  ? router.back()
                  : router.replace(
                      challenge_id
                        ? `/(main)/challenges/daily`
                        : '/(main)/(tabs)/exercises'
                    )
              }
            >
              <Text style={styles.successActionButtonText}>Continue</Text>
            </TouchableOpacity>
          </View>
        </SafeAreaView>
      </PlayerWrapper>
    )
  }

  const renderExercise = () => {
    const currentExercise = lesson.exercises[currentExerciseIndex]
    if (!currentExercise) return <ActivityIndicator style={{ marginTop: 50 }} />
    const onAnsweredCb = (isCorrect: boolean, userAnswer: string) =>
      handleAnswered(isCorrect, userAnswer, currentExercise)
    const commonProps = {
      exercise: currentExercise,
      onAnswered: onAnsweredCb,
      currentQuestionNumber: currentExerciseIndex + 1,
      totalQuestions: lesson.exercises.length
    }
    switch (currentExercise.exercise_type) {
      case 'flashcard':
        return <FlashcardExerciseCard {...commonProps} />
      case 'fill_in_the_blank':
        return <FillInTheBlankExerciseCard {...commonProps} />
      case 'multiple_choice_translation':
        return <MultipleChoiceTranslationExerciseCard {...commonProps} />
      case 'sentence_construction':
        return <SentenceConstructionExerciseCard {...commonProps} />
      case 'grammar_rule_explanation':
        return <GrammarRuleExplanationCard {...commonProps} />
      case 'identify_the_concept':
        return <IdentifyTheConceptExerciseCard {...commonProps} />
      default:
        return (
          <Text>
            Unsupported exercise: {(currentExercise as any).exercise_type}
          </Text>
        )
    }
  }

  return (
    <PlayerWrapper {...playerWrapperProps}>
      <SafeAreaView style={{ flex: 1 }} edges={['top', 'bottom']}>
        <Stack.Screen options={{ headerShown: false }} />
        <View
          style={[
            styles.customHeader,
            { paddingTop: Platform.OS === 'android' ? insets.top : 0 },
            isQuizMode && styles.quizHeaderSpecific
          ]}
        >
          <TouchableOpacity
            onPress={() => router.back()}
            style={
              isQuizMode
                ? styles.quizHeaderBackButton
                : styles.headerBackButtonOnError
            }
          >
            <ChevronLeft
              size={22}
              color={
                isQuizMode ? Colors.light.text : Colors.light.textSecondary
              }
            />
          </TouchableOpacity>
          <Text
            style={[
              styles.headerTitle,
              isQuizMode && styles.quizHeaderTitleSpecific
            ]}
            numberOfLines={1}
            ellipsizeMode="tail"
          >
            {lesson.lesson_title || 'Practice'}
          </Text>
          {lesson.exercises.length > 1 ? (
            <View
              style={[
                styles.scoreContainer,
                isQuizMode && styles.quizScoreContainer
              ]}
            >
              <Star
                size={15}
                color={Colors.light.warning}
                fill={Colors.light.warning}
              />
              <Text style={styles.quizScoreText}>{correctAnswersCount}</Text>
            </View>
          ) : (
            <View style={{ width: 40 }} />
          )}
        </View>

        {lesson.exercises.length > 1 && (
          <View
            style={[
              styles.progressHeaderContainer,
              isQuizMode && styles.quizProgressHeaderContainer
            ]}
          >
            <View
              style={[
                styles.progressBarTrack,
                isQuizMode && styles.quizProgressBarTrack
              ]}
            >
              <View
                style={[
                  styles.progressBarFill,
                  isQuizMode && styles.quizProgressBarFill,
                  {
                    width: `${
                      lesson.exercises.length > 0
                        ? ((currentExerciseIndex + 1) /
                            lesson.exercises.length) *
                          100
                        : 0
                    }%`
                  }
                ]}
              />
            </View>
            <Text style={styles.standardProgressCountText}>
              {currentExerciseIndex + 1}/{lesson.exercises.length}
            </Text>
          </View>
        )}

        <ScrollView
          contentContainerStyle={[
            styles.scrollContentContainer,
            { paddingBottom: insets.bottom + 20 }
          ]}
          showsVerticalScrollIndicator={false}
          keyboardShouldPersistTaps="handled"
        >
          {playerStatus === 'playing' && renderExercise()}
        </ScrollView>
      </SafeAreaView>
    </PlayerWrapper>
  )
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: Colors.light.background },
  quizGradientBackground: { flex: 1 },
  containerCentered: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20
  },
  loadingText: {
    fontFamily: 'Inter-Regular',
    fontSize: 15,
    color: Colors.light.textSecondary,
    marginTop: 10
  },
  quizLoadingText: {
    fontFamily: 'Inter-Regular',
    fontSize: 15,
    color: Colors.light.text,
    marginTop: 10
  },
  customHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 15,
    paddingBottom: 10
  },
  quizHeaderSpecific: {},
  headerBackButtonOnError: {
    padding: 8
  },
  quizHeaderBackButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: Colors.light.cardBackground,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.15,
    shadowRadius: 3,
    elevation: 2
  },
  headerTitle: {
    fontFamily: 'Inter-Bold',
    fontSize: 20,
    color: Colors.light.text,
    textAlign: 'center',
    marginHorizontal: 5,
    flexShrink: 1
  },
  quizHeaderTitleSpecific: {
    fontFamily: 'Inter-Bold',
    fontSize: 20,
    color: Colors.light.text
  },
  scoreContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 16,
    minWidth: 50,
    justifyContent: 'center'
  },
  quizScoreContainer: {
    backgroundColor: Colors.light.cardBackground,
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 2
  },
  quizScoreText: {
    marginLeft: 5,
    fontFamily: 'Inter-Bold',
    fontSize: 14
  },
  progressHeaderContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 20,
    marginBottom: 12
  },
  quizProgressHeaderContainer: {
    paddingHorizontal: 24,
    marginVertical: 10
  },
  progressBarTrack: {
    flex: 1,
    height: 8,
    borderRadius: 4,
    overflow: 'hidden',
    backgroundColor: Colors.common.black + '15'
  },
  progressBarFill: {
    height: '100%',
    borderRadius: 4
  },
  standardProgressFill: {
    backgroundColor: Colors.light.primary
  },
  quizProgressBarFill: {
    backgroundColor: Colors.light.secondary,
    borderRadius: 3.5
  },
  standardProgressCountText: {
    fontSize: 13,
    fontFamily: 'Inter-Bold',
    color: Colors.light.text,
    marginLeft: 12
  },
  scrollContentContainer: {
    paddingHorizontal: 20
  },
  centeredContentMessage: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 20
  },
  errorText: {
    fontSize: 16,
    color: Colors.light.error,
    textAlign: 'center',
    marginBottom: 15,
    fontFamily: 'Inter-Medium'
  },
  completionTitle: {
    fontSize: 24,
    fontFamily: 'Inter-Bold',
    color: Colors.light.text,
    marginBottom: 10,
    textAlign: 'center'
  },
  completionScore: {
    fontSize: 18,
    fontFamily: 'Inter-Regular',
    color: Colors.light.textSecondary,
    marginBottom: 20,
    textAlign: 'center'
  },
  actionButton: {
    backgroundColor: Colors.common.white,
    borderWidth: 1,
    borderColor: Colors.common.black,
    paddingVertical: 12,
    paddingHorizontal: 30,
    borderRadius: 25,
    marginTop: 20
  },
  actionButtonText: {
    color: Colors.common.black,
    fontSize: 16,
    fontFamily: 'Inter-SemiBold'
  },
  successActionButton: {
    backgroundColor: Colors.light.primary,
    paddingVertical: 12,
    paddingHorizontal: 30,
    borderRadius: 25,
    marginTop: 20
  },
  successActionButtonText: {
    color: Colors.light.primaryContent,
    fontSize: 16,
    fontFamily: 'Inter-SemiBold'
  }
})

```
src/app/(main)/exercises/review-session.tsx
```
import React, { useEffect, useState } from 'react'
import {
  View,
  Text,
  StyleSheet,
  ActivityIndicator,
  TouchableOpacity,
  ScrollView,
  Platform,
  Alert
} from 'react-native'
import { SafeAreaView } from 'react-native-safe-area-context'
import { useDispatch, useSelector } from 'react-redux'
import { Stack, useRouter, useLocalSearchParams } from 'expo-router'
import {
  ChevronLeft,
  X as IconX,
  AlertCircle as IconMedium,
  CheckCircle as IconEasy
} from 'lucide-react-native'
import { LinearGradient } from 'expo-linear-gradient'

import { AppDispatch } from '@store/store'
import {
  fetchReviewsThunk,
  reportReviewOutcomeThunk,
  advanceReviewItem,
  clearReviews,
  selectCurrentReviewItem,
  selectReviewStatus,
  selectReviewError,
  selectIsReviewSessionActive,
  selectCurrentReviewItemIndex,
  selectAllReviewItems
} from '@features/reviews/reviewsSlice'
import { ReviewOutcomePayload } from '@features/reviews/types'
import { WordReviewCard } from '@components/reviews/WordReviewCard'
import { GrammarReviewCard } from '@components/reviews/GrammarReviewCard'
import { Colors } from '@constants/Colors'
import { LearningTipCard } from '@/components/common/LearningTipCard'
import { markChallengeSectionCompleted } from '@/features/challenges/challengesSlice'
import { useSafeAreaInsets } from 'react-native-safe-area-context'

export default function ReviewSessionScreen(): React.ReactElement {
  const dispatch = useDispatch<AppDispatch>()
  const router = useRouter()
  const insets = useSafeAreaInsets()

  const { challenge_id, challenge_section_array_index } = useLocalSearchParams<{
    challenge_id?: string
    challenge_section_array_index?: string
  }>()

  const currentItem = useSelector(selectCurrentReviewItem)
  const status = useSelector(selectReviewStatus)
  const error = useSelector(selectReviewError)
  const isSessionActive = useSelector(selectIsReviewSessionActive)
  const currentIndex = useSelector(selectCurrentReviewItemIndex)
  const totalItems = useSelector(selectAllReviewItems).length

  const [isCardFlipped, setIsCardFlipped] = useState(false)

  useEffect(() => {
    if (!isSessionActive && status === 'idle') {
      dispatch(fetchReviewsThunk({ limit: challenge_id ? 5 : 20 }))
    }
  }, [dispatch, isSessionActive, status, challenge_id])

  useEffect(() => {
    setIsCardFlipped(false)
  }, [currentItem])

  const handleAssessment = (difficulty: 'easy' | 'medium' | 'hard') => {
    if (currentItem) {
      let success = false
      if (difficulty === 'easy' || difficulty === 'medium') success = true

      const outcome: ReviewOutcomePayload = {
        interaction_success: success,
        review_timestamp_client: new Date().toISOString(),
        review_interaction_type: `nsr_${currentItem.item_type}_flashcard_assess_${difficulty}`
      }
      dispatch(reportReviewOutcomeThunk({ item: currentItem, outcome }))
    }
    dispatch(advanceReviewItem())
  }

  const handleGoBack = () => {
    if (
      isSessionActive &&
      totalItems > 0 &&
      currentIndex < totalItems &&
      currentIndex !== -1
    ) {
      Alert.alert(
        'End Review Session?',
        'Your progress in this session will not be saved if you go back now.',
        [
          { text: 'Cancel', style: 'cancel' },
          {
            text: 'End Session',
            style: 'destructive',
            onPress: () => {
              dispatch(clearReviews())
              router.canGoBack()
                ? router.back()
                : router.replace(
                    challenge_id
                      ? `/(main)/challenges/daily`
                      : '/(main)/(tabs)/exercises'
                  )
            }
          }
        ]
      )
    } else {
      dispatch(clearReviews())
      router.canGoBack()
        ? router.back()
        : router.replace(
            challenge_id
              ? `/(main)/challenges/daily`
              : '/(main)/(tabs)/exercises'
          )
    }
  }

  useEffect(() => {
    if (
      status === 'succeeded' &&
      !isSessionActive &&
      totalItems > 0 &&
      currentIndex === -1
    ) {
      if (challenge_id && challenge_section_array_index !== undefined) {
        const sectionIndexNum = parseInt(challenge_section_array_index, 10)
        if (!isNaN(sectionIndexNum)) {
          dispatch(
            markChallengeSectionCompleted({
              sectionArrayIndex: sectionIndexNum
            })
          )
        }
      }
    }
  }, [
    status,
    isSessionActive,
    totalItems,
    currentIndex,
    challenge_id,
    challenge_section_array_index,
    dispatch
  ])

  if (status === 'loading' && !isSessionActive) {
    return (
      <LinearGradient
        colors={[
          Colors.light.flashcardGradientFrom,
          Colors.light.flashcardGradientTo
        ]}
        style={styles.gradientBackgroundFull}
      >
        <SafeAreaView
          style={styles.containerCentered}
          edges={['top', 'bottom']}
        >
          <ActivityIndicator size="large" color={Colors.light.text} />
          <Text style={styles.loadingText}>Loading Flashcards...</Text>
        </SafeAreaView>
      </LinearGradient>
    )
  }

  const progressPercentage =
    totalItems > 0 ? ((currentIndex + 1) / totalItems) * 100 : 0

  if (!isSessionActive && status !== 'loading') {
    const title = status === 'failed' ? 'Error' : 'Review Complete'
    const message =
      status === 'failed'
        ? error || 'Could not load flashcards.'
        : totalItems > 0
        ? "You've reviewed all flashcards!"
        : 'No flashcards due for review right now.'

    return (
      <LinearGradient
        colors={[
          Colors.light.flashcardGradientFrom,
          Colors.light.flashcardGradientTo
        ]}
        style={styles.gradientBackgroundFull}
      >
        <SafeAreaView style={styles.container} edges={['top', 'bottom']}>
          <Stack.Screen options={{ headerShown: false }} />
          <View
            style={[
              styles.customHeader,
              { paddingTop: Platform.OS === 'android' ? insets.top : 0 }
            ]}
          >
            <TouchableOpacity
              onPress={handleGoBack}
              style={styles.headerBackButton}
            >
              <ChevronLeft size={22} color={Colors.light.textSecondary} />
            </TouchableOpacity>
            <Text style={styles.headerTitleText}>{title}</Text>
            <View style={{ width: 30 }} />
          </View>
          <View style={styles.centeredContentMessage}>
            <Text
              style={
                status === 'failed'
                  ? styles.errorMessageText
                  : styles.completionMessageTitle
              }
            >
              {message}
            </Text>
            {status === 'failed' && (
              <TouchableOpacity
                style={styles.retryButton}
                onPress={() => dispatch(fetchReviewsThunk({ limit: 20 }))}
              >
                <Text style={styles.retryButtonText}>Try Again</Text>
              </TouchableOpacity>
            )}
            {status !== 'failed' && (
              <TouchableOpacity
                style={styles.backToHubButton}
                onPress={handleGoBack}
              >
                <Text style={styles.backToHubButtonText}>Back to Hub</Text>
              </TouchableOpacity>
            )}
          </View>
        </SafeAreaView>
      </LinearGradient>
    )
  }

  const learningTipExample =
    currentItem?.item_type === 'word'
      ? currentItem.word_examples?.[0]?.sentence_fi ||
        'Try using this in a sentence today!'
      : currentItem?.grammar_examples?.[0]?.sentence_fi ||
        'Think of a sentence using this rule.'

  return (
    <LinearGradient
      colors={[
        Colors.light.flashcardGradientFrom,
        Colors.light.flashcardGradientTo
      ]}
      style={styles.gradientBackgroundFull}
    >
      <SafeAreaView style={styles.container} edges={['top', 'bottom']}>
        <Stack.Screen options={{ headerShown: false }} />
        <View
          style={[
            styles.customHeader,
            { paddingTop: Platform.OS === 'android' ? insets.top : 0 }
          ]}
        >
          <TouchableOpacity
            onPress={handleGoBack}
            style={styles.headerBackButton}
          >
            <ChevronLeft size={22} color={Colors.light.textSecondary} />
          </TouchableOpacity>
          <Text style={styles.headerTitleText}>
            {challenge_id ? 'Challenge Review' : 'Daily Flashcards'}
          </Text>
          <Text style={styles.headerProgressText}>
            {totalItems > 0 ? `${currentIndex + 1}/${totalItems}` : '0/0'}
          </Text>
        </View>

        <View style={styles.progressBarOuterContainer}>
          <View
            style={[
              styles.progressBarInner,
              { width: `${progressPercentage}%` }
            ]}
          />
        </View>

        <ScrollView
          contentContainerStyle={styles.scrollContentContainer}
          showsVerticalScrollIndicator={false}
        >
          <View style={styles.flashcardDisplayArea}>
            {currentItem && currentItem.item_type === 'word' && (
              <WordReviewCard
                item={currentItem}
                isFlipped={isCardFlipped}
                onFlip={() => setIsCardFlipped(!isCardFlipped)}
              />
            )}
            {currentItem && currentItem.item_type === 'grammar' && (
              <GrammarReviewCard
                item={currentItem}
                isFlipped={isCardFlipped}
                onFlip={() => setIsCardFlipped(!isCardFlipped)}
              />
            )}
            {!currentItem && isSessionActive && (
              <ActivityIndicator
                style={{ marginTop: 50 }}
                color={Colors.light.primary}
              />
            )}
          </View>

          {currentItem && (
            <>
              <View style={styles.ratingButtonsRow}>
                <TouchableOpacity
                  style={[
                    styles.ratingButton,
                    { backgroundColor: Colors.light.flashcardButtonHardBg }
                  ]}
                  onPress={() => handleAssessment('hard')}
                >
                  <IconX size={20} color={Colors.light.error} />
                  <Text
                    style={[
                      styles.ratingButtonText,
                      { color: Colors.light.error }
                    ]}
                  >
                    Hard
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[
                    styles.ratingButton,
                    { backgroundColor: Colors.light.flashcardButtonMediumBg }
                  ]}
                  onPress={() => handleAssessment('medium')}
                >
                  <IconMedium size={20} color={Colors.light.warning} />
                  <Text
                    style={[
                      styles.ratingButtonText,
                      { color: Colors.light.warning }
                    ]}
                  >
                    Medium
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[
                    styles.ratingButton,
                    { backgroundColor: Colors.light.flashcardButtonEasyBg }
                  ]}
                  onPress={() => handleAssessment('easy')}
                >
                  <IconEasy size={20} color={Colors.light.success} />
                  <Text
                    style={[
                      styles.ratingButtonText,
                      { color: Colors.light.success }
                    ]}
                  >
                    Easy
                  </Text>
                </TouchableOpacity>
              </View>
              <View style={styles.learningTipContainer}>
                <LearningTipCard
                  tipDescription={learningTipExample}
                  iconType="mascot"
                />
              </View>
            </>
          )}
        </ScrollView>
      </SafeAreaView>
    </LinearGradient>
  )
}

const styles = StyleSheet.create({
  gradientBackgroundFull: { flex: 1 },
  container: { flex: 1 },
  containerCentered: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20
  },
  centeredContentMessage: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 20
  },
  loadingText: {
    fontFamily: 'Inter-Medium',
    fontSize: 16,
    color: Colors.light.textSecondary,
    marginTop: 12
  },
  customHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 15,
    paddingBottom: 10
  },
  headerBackButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: Colors.light.cardBackground,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 2,
    marginRight: 10
  },
  headerTitleText: {
    flex: 1,
    fontFamily: 'Inter-Bold',
    fontSize: 20,
    color: Colors.light.flashcardTermText
  },
  headerProgressText: {
    fontFamily: 'Inter-Bold',
    fontSize: 15,
    color: Colors.light.flashcardTermText,
    minWidth: 40,
    textAlign: 'right'
  },
  progressBarOuterContainer: {
    height: 8,
    backgroundColor: Colors.common.black + '15',
    borderRadius: 4,
    marginHorizontal: 24,
    marginBottom: 24,
    marginTop: 14
  },
  progressBarInner: {
    height: '100%',
    backgroundColor: Colors.light.flashcardProgressBarFill,
    borderRadius: 4
  },
  scrollContentContainer: {
    flexGrow: 1,
    paddingHorizontal: 24,
    paddingBottom: 20
  },
  flashcardDisplayArea: {
    width: '100%',
    aspectRatio: 1 / 1,
    maxHeight: 380,
    marginBottom: 24,
    alignSelf: 'center'
  },
  ratingButtonsRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 24,
    gap: 12
  },
  ratingButton: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: 16,
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    minHeight: 70,
    shadowColor: Colors.light.shadowSubtle,
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 1
  },
  ratingButtonText: {
    fontSize: 12,
    fontFamily: 'Inter-SemiBold',
    marginTop: 4
  },
  learningTipContainer: {
    marginBottom: Platform.OS === 'ios' ? 10 : 60
  },
  completionMessageTitle: {
    fontFamily: 'Inter-Bold',
    fontSize: 22,
    color: Colors.light.text,
    textAlign: 'center',
    marginBottom: 12
  },
  errorMessageText: {
    fontFamily: 'Inter-Medium',
    fontSize: 18,
    color: Colors.light.error,
    textAlign: 'center',
    marginBottom: 20
  },
  retryButton: {
    backgroundColor: Colors.light.primary,
    paddingVertical: 12,
    paddingHorizontal: 30,
    borderRadius: 25
  },
  retryButtonText: {
    color: Colors.light.primaryContent,
    fontFamily: 'Inter-SemiBold',
    fontSize: 15
  },
  backToHubButton: {
    backgroundColor: Colors.common.white,
    borderWidth: 1,
    borderColor: Colors.light.primary,
    paddingVertical: 12,
    paddingHorizontal: 30,
    borderRadius: 25
  },
  backToHubButtonText: {
    color: Colors.light.primary,
    fontFamily: 'Inter-SemiBold',
    fontSize: 15
  }
})

```
src/app/(auth)/_layout.tsx
```
import React from 'react'
import { Stack } from 'expo-router'
import { StyleSheet } from 'react-native'
import { Colors } from '@constants/Colors'
import { SafeAreaView } from 'react-native-safe-area-context'

export default function AuthLayout(): React.ReactElement {
  return (
    <SafeAreaView style={styles.safeArea} edges={['top', 'bottom']}>
      <Stack screenOptions={{ headerShown: false }} />
    </SafeAreaView>
  )
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: Colors.light.background
  }
})

```
src/app/(auth)/forgot-password.tsx
```
import React, { useState, useEffect } from 'react'
import {
  View,
  Text,
  TextInput,
  Pressable,
  ActivityIndicator,
  TouchableOpacity,
  ScrollView
} from 'react-native'
import { useRouter } from 'expo-router'
import { Colors } from '@constants/Colors'
import { ChevronLeft } from 'lucide-react-native'
import authStyles from './_styles/authStyles'
import { useDispatch } from 'react-redux'
import { AppDispatch } from '@store/store'
import { requestPasswordResetThunk } from '@features/auth/authActions'

export default function ForgotPasswordScreen() {
  const router = useRouter()
  const dispatch = useDispatch<AppDispatch>()
  const [email, setEmail] = useState('')
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    let timer: NodeJS.Timeout | null = null
    if (error) {
      timer = setTimeout(() => {
        setError(null)
      }, 5000)
    }
    return () => {
      if (timer) clearTimeout(timer)
    }
  }, [error])

  const handleResetRequest = async () => {
    setError(null)
    if (!email.trim()) {
      setError('Please enter your email address.')
      return
    }
    if (!/\S+@\S+\.\S+/.test(email.trim())) {
      setError('Please enter a valid email address.')
      return
    }
    setIsLoading(true)
    try {
      await dispatch(requestPasswordResetThunk({ email: email.trim() }))
      router.push(`/(auth)/reset-password?email=${encodeURIComponent(email)}`)
    } catch (err: any) {
      console.error('Forgot Password thunk failed:', err)
      const errorMessage =
        err?.message ||
        err?.data?.error ||
        err?.data?.message ||
        'Could not send reset instructions. Please try again later.'
      setError(errorMessage)
    } finally {
      setIsLoading(false)
    }
  }

  const handleGoBack = () => {
    if (router.canGoBack()) {
      router.back()
    } else {
      router.replace('/(auth)/login')
    }
  }

  const isButtonDisabled = isLoading

  return (
    <ScrollView
      contentContainerStyle={authStyles.scrollContainer}
      keyboardShouldPersistTaps="handled"
    >
      <View style={authStyles.innerContainer}>
        <View style={authStyles.headerContainer}>
          <TouchableOpacity
            onPress={handleGoBack}
            style={authStyles.backButton}
          >
            <ChevronLeft size={28} color={Colors.light.text} />
          </TouchableOpacity>
        </View>

        <View style={authStyles.titleContainer}>
          <Text style={authStyles.title}>Reset Password</Text>
          <Text style={authStyles.subtitle}>
            Enter your email. We'll send instructions if an account exists.
          </Text>
        </View>

        {/* Messages */}
        <View style={authStyles.messageContainer}>
          {error && <Text style={authStyles.errorText}>{error}</Text>}
        </View>

        {/* Form */}
        <View style={authStyles.formContainer}>
          <View style={authStyles.inputGroup}>
            <Text style={authStyles.label}>Email</Text>
            <TextInput
              style={[authStyles.input, isLoading && authStyles.inputDisabled]}
              placeholder="Enter your Email"
              value={email}
              onChangeText={setEmail}
              keyboardType="email-address"
              autoCapitalize="none"
              editable={!isLoading}
              placeholderTextColor={Colors.light.textTertiary}
              onSubmitEditing={handleResetRequest}
              returnKeyType="send"
            />
          </View>
        </View>

        {/* Footer */}
        <View style={authStyles.footerContainer}>
          <Pressable
            style={({ pressed }) => [
              authStyles.actionButton,
              isButtonDisabled && authStyles.buttonDisabled,
              pressed && !isButtonDisabled && authStyles.actionButtonPressed
            ]}
            onPress={handleResetRequest}
            disabled={isButtonDisabled}
          >
            {isLoading ? (
              <ActivityIndicator color={Colors.common.white} />
            ) : (
              <Text style={authStyles.actionButtonText}>Send Instructions</Text>
            )}
          </Pressable>
        </View>
      </View>
    </ScrollView>
  )
}

```
src/app/(auth)/login.tsx
```
import React, { useState, useEffect, useCallback, useRef } from 'react'
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  ActivityIndicator,
  Pressable,
  TouchableOpacity,
  ScrollView,
  Platform
} from 'react-native'
import { useSelector, useDispatch } from 'react-redux'
import { FontAwesome } from '@expo/vector-icons'
import {
  GoogleSignin,
  statusCodes
} from '@react-native-google-signin/google-signin'
import {
  loginUserThunk,
  loginWithSocialThunk,
  clearAuthError
} from '@features/auth/authActions'
import { selectAuthStatus, selectAuthError } from '@features/auth/authSelectors'
import { AppDispatch } from '@store/store'
import { Colors } from '@constants/Colors'
import authStyles from './_styles/authStyles'
import { ChevronLeft, Eye, EyeOff } from 'lucide-react-native'
import {
  Link,
  useLocalSearchParams,
  useRouter,
  useSegments,
  usePathname
} from 'expo-router'

GoogleSignin.configure({
  webClientId: process.env.EXPO_PUBLIC_GOOGLE_WEB_CLIENT_ID,
  iosClientId: process.env.EXPO_PUBLIC_GOOGLE_IOS_CLIENT_ID,
  offlineAccess: false
})

const LoginView = () => {
  const dispatch = useDispatch<AppDispatch>()
  const router = useRouter()
  const params = useLocalSearchParams<{ redirect?: string }>()

  const status = useSelector(selectAuthStatus)
  const rawError = useSelector(selectAuthError)

  const passwordInputRef = useRef<TextInput>(null)

  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [isPasswordVisible, setIsPasswordVisible] = useState(false)
  const [localError, setLocalError] = useState<string | null>(null)

  const isLoading = status === 'loading'
  const displayError = rawError || localError

  const handleLoginSubmit = useCallback(async () => {
    if (isLoading) return
    dispatch(clearAuthError())
    setLocalError(null)
    if (!email.trim() || !password) return
    try {
      await dispatch(loginUserThunk({ email: email.trim(), password }))
    } catch (error) {
      console.error('Login thunk failed:', error)
    }
  }, [email, password, dispatch, isLoading])

  const handleGoogleLoginPress = useCallback(async () => {
    dispatch(clearAuthError())
    setLocalError(null)
    try {
      await GoogleSignin.hasPlayServices({ showPlayServicesUpdateDialog: true })
      const response = await GoogleSignin.signIn()
      if (response.type === 'cancelled') return

      const { idToken, accessToken } = await GoogleSignin.getTokens()
      if (idToken || accessToken) {
        await dispatch(
          loginWithSocialThunk({
            provider: 'google',
            access_token: accessToken || idToken
          })
        )
      }
    } catch (error: any) {
      if (error.code === statusCodes.SIGN_IN_CANCELLED) {
      } else if (error.code === statusCodes.IN_PROGRESS) {
      } else if (error.code === statusCodes.PLAY_SERVICES_NOT_AVAILABLE) {
        setLocalError('Google Play Services not available or outdated')
      } else {
        setLocalError('Google sign-in failed. Please try again.')
      }
    }
  }, [dispatch])

  const handleAppleLoginPress = useCallback(() => {
    dispatch(clearAuthError())
    setLocalError(null)
    setLocalError('Apple Sign-In is not yet implemented.')
  }, [dispatch])

  const handleFacebookLoginPress = useCallback(() => {
    dispatch(clearAuthError())
    setLocalError(null)
    setLocalError('Facebook Sign-In is not yet implemented.')
  }, [dispatch])

  useEffect(() => {
    setLocalError(null)
  }, [email, password])

  useEffect(() => {
    let timer: NodeJS.Timeout
    if (displayError) {
      timer = setTimeout(() => {
        dispatch(clearAuthError())
        setLocalError(null)
      }, 5000)
    }
    return () => clearTimeout(timer)
  }, [displayError, dispatch])

  const togglePasswordVisibility = useCallback(
    () => setIsPasswordVisible(v => !v),
    []
  )

  const handleGoBack = () => {
    const defaultRedirect = '/(main)/(tabs)/'
    const redirectParams =
      params.redirect && decodeURIComponent(params.redirect)
    const redirectPath =
      redirectParams && !redirectParams.startsWith('/(auth)/')
        ? redirectParams
        : defaultRedirect
    router.replace(redirectPath)
  }

  const renderSocialButton = useCallback(
    (
      provider: 'google' | 'apple' | 'facebook',
      onPress: () => void,
      disabled: boolean = false
    ) => {
      const iconName = provider === 'facebook' ? 'facebook-f' : provider
      const brandColors = {
        google: '#DB4437',
        apple: '#000',
        facebook: '#1877F2'
      }
      const pressedColors = {
        google: '#c33d2e',
        apple: '#333',
        facebook: '#166fe5'
      }
      return (
        <Pressable
          style={({ pressed }) => [
            authStyles.socialButton,
            (disabled || isLoading) && authStyles.buttonDisabled,
            pressed &&
              !(disabled || isLoading) && {
                backgroundColor: pressedColors[provider]
              },
            !pressed && { backgroundColor: brandColors[provider] }
          ]}
          onPress={onPress}
          disabled={disabled || isLoading}
        >
          <FontAwesome
            name={iconName as any}
            size={20}
            color={Colors.light.primaryContent}
          />
        </Pressable>
      )
    },
    [isLoading]
  )

  return (
    <ScrollView
      contentContainerStyle={authStyles.scrollContainer}
      keyboardShouldPersistTaps="handled"
    >
      <View style={authStyles.innerContainer}>
        <View style={authStyles.headerContainer}>
          <TouchableOpacity
            onPress={handleGoBack}
            style={authStyles.backButton}
          >
            <ChevronLeft size={28} color={Colors.light.text} />
          </TouchableOpacity>
        </View>

        <View style={authStyles.titleContainer}>
          <Text style={authStyles.title}>Let's Sign you in.</Text>
          <Text style={authStyles.subtitle}>Welcome back</Text>
        </View>

        {/* Error Message */}
        <Text style={authStyles.errorText}>{displayError}</Text>

        {/* Form */}
        <View style={authStyles.formContainer}>
          <View style={authStyles.inputGroup}>
            <Text style={authStyles.label}>Username or Email</Text>
            <TextInput
              style={[authStyles.input, isLoading && authStyles.inputDisabled]}
              placeholder="Enter Username or Email"
              value={email}
              onChangeText={setEmail}
              keyboardType="email-address"
              autoCapitalize="none"
              editable={!isLoading}
              returnKeyType="next"
              onSubmitEditing={() => passwordInputRef.current?.focus()}
              placeholderTextColor={Colors.light.textTertiary}
            />
          </View>

          <View style={authStyles.inputGroup}>
            <Text style={authStyles.label}>Password</Text>
            <View
              style={[
                authStyles.passwordInputWrapper,
                isLoading && styles.inputWrapperDisabled
              ]}
            >
              <TextInput
                ref={passwordInputRef}
                style={[
                  authStyles.input,
                  authStyles.passwordInputOnly,
                  isLoading && authStyles.inputDisabled
                ]}
                placeholder="Enter Password"
                value={password}
                onChangeText={setPassword}
                secureTextEntry={!isPasswordVisible}
                editable={!isLoading}
                returnKeyType="go"
                onSubmitEditing={handleLoginSubmit}
                placeholderTextColor={Colors.light.textTertiary}
              />
              <TouchableOpacity
                onPress={togglePasswordVisibility}
                disabled={isLoading}
                style={authStyles.passwordVisibilityButton}
              >
                {isPasswordVisible ? (
                  <EyeOff size={20} color={Colors.light.textSecondary} />
                ) : (
                  <Eye size={20} color={Colors.light.textSecondary} />
                )}
              </TouchableOpacity>
            </View>
            <Link href="/(auth)/forgot-password" asChild>
              <Pressable
                disabled={isLoading}
                style={styles.forgotPasswordButton}
              >
                <Text
                  style={[
                    authStyles.linkText,
                    isLoading && authStyles.linkDisabled
                  ]}
                >
                  Forgot Password?
                </Text>
              </Pressable>
            </Link>
          </View>
        </View>

        {/* Social Logins */}
        <View style={styles.socialLoginsSection}>
          <View style={styles.orSeparatorContainer}>
            <View style={styles.orSeparatorLine} />
            <Text style={styles.orSeparatorText}>or continue with</Text>
            <View style={styles.orSeparatorLine} />
          </View>
          <View style={styles.socialLoginContainer}>
            {renderSocialButton('google', handleGoogleLoginPress, isLoading)}
            {renderSocialButton('apple', handleAppleLoginPress, isLoading)}
            {renderSocialButton(
              'facebook',
              handleFacebookLoginPress,
              isLoading
            )}
          </View>
        </View>

        {/* Actions */}
        <View style={[authStyles.footerContainer, styles.loginFooterContainer]}>
          <Pressable
            style={({ pressed }) => [
              authStyles.actionButton,
              isLoading && authStyles.buttonDisabled,
              pressed && !isLoading && authStyles.actionButtonPressed
            ]}
            onPress={handleLoginSubmit}
            disabled={isLoading}
          >
            {isLoading ? (
              <ActivityIndicator color={Colors.common.white} />
            ) : (
              <Text style={authStyles.actionButtonText}>Login</Text>
            )}
          </Pressable>
          <View style={styles.registerLinkContainer}>
            <Text style={styles.footerText}>Don't have an account? </Text>
            <Link href="/(auth)/signup" asChild>
              <Pressable disabled={isLoading}>
                <Text
                  style={[
                    authStyles.linkTextBold,
                    isLoading && authStyles.linkDisabled
                  ]}
                >
                  Register
                </Text>
              </Pressable>
            </Link>
          </View>
        </View>
      </View>
    </ScrollView>
  )
}

export default LoginView

const styles = StyleSheet.create({
  forgotPasswordButton: {
    alignSelf: 'flex-end',
    marginTop: 8,
    paddingVertical: 4
  },
  socialLoginsSection: { gap: 20, marginTop: 10 },
  orSeparatorContainer: { flexDirection: 'row', alignItems: 'center' },
  orSeparatorLine: { flex: 1, height: 1, backgroundColor: Colors.light.border },
  orSeparatorText: {
    marginHorizontal: 12,
    fontSize: 14,
    fontFamily: 'Inter-Medium',
    color: Colors.light.textSecondary
  },
  socialLoginContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    gap: 20
  },
  socialButton: {
    width: 50,
    height: 50,
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center'
  },
  loginFooterContainer: { gap: 20 },
  registerLinkContainer: { flexDirection: 'row', alignItems: 'center' },
  footerText: {
    fontSize: 14,
    fontFamily: 'Inter-Regular',
    color: Colors.light.textSecondary
  },
  inputWrapperDisabled: { borderColor: Colors.light.border, opacity: 0.7 }
})

```
src/app/(auth)/reset-password.tsx
```
import React, { useState, useEffect, useRef } from 'react'
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  Pressable,
  ActivityIndicator,
  TouchableOpacity,
  ScrollView,
  Keyboard,
  TextInputKeyPressEventData,
  Platform
} from 'react-native'
import { useLocalSearchParams, useRouter } from 'expo-router'
import { Colors } from '@constants/Colors'
import { ChevronLeft, Eye, EyeOff } from 'lucide-react-native'
import authStyles from './_styles/authStyles'
import { useDispatch } from 'react-redux'
import { AppDispatch } from '@store/store'
import {
  verifyResetTokenThunk,
  executePasswordResetThunk
} from '@features/auth/authActions'
import { showPlatformAlert } from '@lib/platformAlert'

const OTP_LENGTH = 6

export default function ResetPasswordScreen() {
  const router = useRouter()
  const dispatch = useDispatch<AppDispatch>()
  const params = useLocalSearchParams<{ email: string }>()

  const emailParam = params.email && decodeURIComponent(params.email)

  const otpInputs = useRef<Array<TextInput | null>>([])
  const confirmPasswordInputRef = useRef<TextInput>(null)

  const [step, setStep] = useState<'verify' | 'reset'>('verify')
  const [otpDigits, setOtpDigits] = useState<string[]>(
    Array(OTP_LENGTH).fill('')
  )
  const [verificationCode, setVerificationCode] = useState('')
  const [password, setPassword] = useState('')
  const [confirmPassword, setConfirmPassword] = useState('')
  const [isPasswordVisible, setIsPasswordVisible] = useState(false)
  const [isConfirmPasswordVisible, setIsConfirmPasswordVisible] =
    useState(false)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const handleOtpChange = (index: number, value: string) => {
    if (value.length > 1) {
      const pastedDigits = value.replace(/[^0-9]/g, '').slice(0, OTP_LENGTH)
      const newOtpState = Array(OTP_LENGTH).fill('')
      let lastFilledIndex = -1

      for (let i = 0; i < pastedDigits.length; i++) {
        newOtpState[i] = pastedDigits[i]
        lastFilledIndex = i
      }

      setOtpDigits(newOtpState)
      setVerificationCode(pastedDigits)

      const focusIndex =
        lastFilledIndex < OTP_LENGTH - 1 ? lastFilledIndex + 1 : lastFilledIndex
      if (otpInputs.current[focusIndex]) {
        if (Platform.OS === 'android') {
          setTimeout(() => otpInputs.current[focusIndex]?.focus(), 50)
        } else {
          otpInputs.current[focusIndex]?.focus()
        }
      }
      if (lastFilledIndex === OTP_LENGTH - 1) {
        Keyboard.dismiss()
      }
      return
    }

    const digit = value.replace(/[^0-9]/g, '')
    const newOtpDigits = [...otpDigits]
    newOtpDigits[index] = digit

    if (otpDigits[index] !== digit) {
      setOtpDigits(newOtpDigits)
      const fullCode = newOtpDigits.join('')
      setVerificationCode(fullCode)

      if (digit && index < OTP_LENGTH - 1) {
        otpInputs.current[index + 1]?.focus()
      }

      if (digit && index === OTP_LENGTH - 1) {
        Keyboard.dismiss()
      }
    }
  }

  const handleOtpKeyPress = (
    index: number,
    event: TextInputKeyPressEventData
  ) => {
    if (event.key === 'Backspace' && !otpDigits[index] && index > 0) {
      otpInputs.current[index - 1]?.focus()
    }
  }

  const handleVerifyTokenPress = async () => {
    setError(null)
    Keyboard.dismiss()

    if (
      verificationCode.length !== OTP_LENGTH ||
      !/^\d{6}$/.test(verificationCode)
    ) {
      setError('Verification code must be 6 digits.')
      return
    }

    setIsLoading(true)
    try {
      await dispatch(
        verifyResetTokenThunk({ token: verificationCode, email: emailParam })
      )
      setStep('reset')
      setError(null)
    } catch (err: any) {
      console.error('Token verification failed:', err)
      const errorMessage =
        err?.message ||
        err?.data?.error ||
        err?.data?.message ||
        'Invalid or expired verification code.'
      setError(errorMessage)
      setOtpDigits(Array(OTP_LENGTH).fill(''))
      setVerificationCode('')
      otpInputs.current[0]?.focus()
    } finally {
      setIsLoading(false)
    }
  }

  const handlePasswordSubmit = async () => {
    setError(null)

    if (step !== 'reset' || !verificationCode) {
      console.error('Attempted password reset without verified token.')
      setError('Please verify the code first.')
      setStep('verify')
      return
    }

    if (!password || !confirmPassword) {
      setError('Please enter and confirm your new password.')
      return
    }
    if (password !== confirmPassword) {
      setError('Passwords do not match.')
      return
    }
    if (password.length < 6) {
      setError('Password must be at least 6 characters long.')
      return
    }

    setIsLoading(true)
    try {
      const result = await dispatch(
        executePasswordResetThunk({
          email: emailParam,
          token: verificationCode,
          new_password: password
        })
      )

      showPlatformAlert(
        'Password Reset Successful',
        result.message || 'Your password has been updated. You can now log in.',
        [{ text: 'OK', onPress: () => router.replace('/(auth)/login') }]
      )
    } catch (err: any) {
      console.error('Password Reset submission failed:', err)
      const errorMessage =
        err?.message ||
        err?.data?.error ||
        err?.data?.message ||
        'Could not reset password. Please try again later.'
      setError(errorMessage)
    } finally {
      setIsLoading(false)
    }
  }

  useEffect(() => {
    let timer: NodeJS.Timeout | null = null
    if (error) {
      timer = setTimeout(() => setError(null), 5000)
    }
    return () => {
      if (timer) clearTimeout(timer)
    }
  }, [error])

  const handleGoBack = () => {
    router.replace('/(auth)/login')
  }
  const togglePasswordVisibility = () => setIsPasswordVisible(prev => !prev)
  const toggleConfirmPasswordVisibility = () =>
    setIsConfirmPasswordVisible(prev => !prev)

  const isFormDisabled = isLoading
  const isVerifyButtonDisabled =
    isLoading || verificationCode.length !== OTP_LENGTH

  return (
    <ScrollView
      contentContainerStyle={authStyles.scrollContainer}
      keyboardShouldPersistTaps="handled"
    >
      <View style={authStyles.innerContainer}>
        <View style={authStyles.headerContainer}>
          <TouchableOpacity
            onPress={handleGoBack}
            style={authStyles.backButton}
          >
            <ChevronLeft size={28} color={Colors.light.text} />
          </TouchableOpacity>
        </View>

        <View style={authStyles.titleContainer}>
          <Text style={authStyles.title}>
            {step === 'verify' ? 'Verify Code' : 'Set New Password'}
          </Text>
          <Text style={authStyles.subtitle}>
            {step === 'verify'
              ? `Enter the 6-digit code sent to "${emailParam}"`
              : 'Enter and confirm your new password.'}
          </Text>
        </View>

        <View style={authStyles.messageContainer}>
          {error && <Text style={authStyles.errorText}>{error}</Text>}
        </View>

        {step === 'verify' && (
          <View style={styles.otpContainer}>
            {otpDigits.map((digit, index) => (
              <TextInput
                key={index}
                ref={ref => {
                  otpInputs.current[index] = ref
                }}
                style={[
                  authStyles.input,
                  styles.otpInput,
                  isFormDisabled && authStyles.inputDisabled
                ]}
                value={digit}
                onChangeText={value => handleOtpChange(index, value)}
                onKeyPress={({ nativeEvent }) =>
                  handleOtpKeyPress(index, nativeEvent)
                }
                keyboardType="number-pad"
                editable={!isFormDisabled}
                placeholderTextColor={Colors.light.textTertiary}
                selectTextOnFocus
                autoFocus={index === 0}
              />
            ))}
          </View>
        )}

        {step === 'reset' && (
          <View style={[authStyles.formContainer, { gap: 20 }]}>
            <View style={authStyles.inputGroup}>
              <Text style={authStyles.label}>New Password</Text>
              <View
                style={[
                  authStyles.passwordInputWrapper,
                  isFormDisabled && styles.inputWrapperDisabled
                ]}
              >
                <TextInput
                  style={[
                    authStyles.input,
                    authStyles.passwordInputOnly,
                    isFormDisabled && authStyles.inputDisabled
                  ]}
                  placeholder="Enter New Password (min. 6 chars)"
                  value={password}
                  onChangeText={setPassword}
                  secureTextEntry={!isPasswordVisible}
                  editable={!isFormDisabled}
                  placeholderTextColor={Colors.light.textTertiary}
                  returnKeyType="next"
                  onSubmitEditing={() =>
                    confirmPasswordInputRef.current?.focus()
                  }
                  blurOnSubmit={false}
                />
                <TouchableOpacity
                  onPress={togglePasswordVisibility}
                  style={authStyles.passwordVisibilityButton}
                  disabled={isFormDisabled}
                >
                  {isPasswordVisible ? (
                    <EyeOff size={20} color={Colors.light.textSecondary} />
                  ) : (
                    <Eye size={20} color={Colors.light.textSecondary} />
                  )}
                </TouchableOpacity>
              </View>
            </View>
            <View style={authStyles.inputGroup}>
              <Text style={authStyles.label}>Confirm New Password</Text>
              <View
                style={[
                  authStyles.passwordInputWrapper,
                  isFormDisabled && styles.inputWrapperDisabled
                ]}
              >
                <TextInput
                  ref={confirmPasswordInputRef}
                  style={[
                    authStyles.input,
                    authStyles.passwordInputOnly,
                    isFormDisabled && authStyles.inputDisabled
                  ]}
                  placeholder="Confirm New Password"
                  value={confirmPassword}
                  onChangeText={setConfirmPassword}
                  secureTextEntry={!isConfirmPasswordVisible}
                  editable={!isFormDisabled}
                  placeholderTextColor={Colors.light.textTertiary}
                  onSubmitEditing={handlePasswordSubmit}
                  returnKeyType="done"
                />
                <TouchableOpacity
                  onPress={toggleConfirmPasswordVisibility}
                  style={authStyles.passwordVisibilityButton}
                  disabled={isFormDisabled}
                >
                  {isConfirmPasswordVisible ? (
                    <EyeOff size={20} color={Colors.light.textSecondary} />
                  ) : (
                    <Eye size={20} color={Colors.light.textSecondary} />
                  )}
                </TouchableOpacity>
              </View>
            </View>
          </View>
        )}

        <View style={authStyles.footerContainer}>
          {step === 'verify' && (
            <Pressable
              style={({ pressed }) => [
                authStyles.actionButton,
                isVerifyButtonDisabled && authStyles.buttonDisabled,
                pressed &&
                  !isVerifyButtonDisabled &&
                  authStyles.actionButtonPressed
              ]}
              onPress={handleVerifyTokenPress}
              disabled={isVerifyButtonDisabled}
            >
              {isLoading ? (
                <ActivityIndicator color={Colors.common.white} />
              ) : (
                <Text style={authStyles.actionButtonText}>Verify Code</Text>
              )}
            </Pressable>
          )}
          {step === 'reset' && (
            <Pressable
              style={({ pressed }) => [
                authStyles.actionButton,
                isFormDisabled && authStyles.buttonDisabled,
                pressed && !isFormDisabled && authStyles.actionButtonPressed
              ]}
              onPress={handlePasswordSubmit}
              disabled={isFormDisabled}
            >
              {isLoading ? (
                <ActivityIndicator color={Colors.common.white} />
              ) : (
                <Text style={authStyles.actionButtonText}>Reset Password</Text>
              )}
            </Pressable>
          )}
        </View>
      </View>
    </ScrollView>
  )
}

const styles = StyleSheet.create({
  inputWrapperDisabled: {
    borderColor: Colors.light.borderSubtle,
    backgroundColor: Colors.light.backgroundSecondary,
    opacity: 0.7
  },
  otpContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    width: '100%',
    paddingHorizontal: 5,
    marginBottom: 20
  },
  otpInput: {
    width: 48,
    height: 52,
    textAlign: 'center',
    fontSize: 20,
    paddingHorizontal: 0
  }
})

```
src/app/(auth)/signup.tsx
```
import React, { useState, useEffect, useCallback, useRef } from 'react'
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  Pressable,
  ActivityIndicator,
  ScrollView,
  TouchableOpacity
} from 'react-native'
import { Link, useRouter } from 'expo-router'
import { Colors } from '@constants/Colors'
import { ChevronLeft, Eye, EyeOff } from 'lucide-react-native'
import { FontAwesome } from '@expo/vector-icons'
import authStyles from './_styles/authStyles'
import { useDispatch, useSelector } from 'react-redux'
import { AppDispatch } from '@store/store'
import {
  registerUserThunk,
  clearAuthError,
  loginWithSocialThunk
} from '@features/auth/authActions'
import {
  selectAuthStatus,
  selectAuthError,
  selectIsAuthenticated
} from '@features/auth/authSelectors'
import { useAuthRequest } from 'expo-auth-session/providers/google'

export default function SignupScreen() {
  const router = useRouter()
  const dispatch = useDispatch<AppDispatch>()
  const authStatus = useSelector(selectAuthStatus)
  const authError = useSelector(selectAuthError)
  const isAuthenticated = useSelector(selectIsAuthenticated)

  const passwordInputRef = useRef<TextInput>(null)
  const confirmPasswordInputRef = useRef<TextInput>(null)

  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [confirmPassword, setConfirmPassword] = useState('')
  const [isPasswordVisible, setIsPasswordVisible] = useState(false)
  const [isConfirmPasswordVisible, setIsConfirmPasswordVisible] =
    useState(false)
  const [localError, setLocalError] = useState<string | null>(null)

  const isLoading = authStatus === 'loading'
  const displayError = authError || localError

  const [googleRequest, googleResponse, promptAsyncGoogle] = useAuthRequest({
    iosClientId: process.env.EXPO_PUBLIC_GOOGLE_IOS_CLIENT_ID,
    androidClientId: process.env.EXPO_PUBLIC_GOOGLE_ANDROID_CLIENT_ID,
    webClientId: process.env.EXPO_PUBLIC_GOOGLE_WEB_CLIENT_ID
  })

  useEffect(() => {
    let timer: NodeJS.Timeout | null = null
    if (displayError) {
      if (localError) setLocalError(null)
      timer = setTimeout(() => {
        if (authError) dispatch(clearAuthError())
      }, 5000)
    }
    return () => {
      if (timer) clearTimeout(timer)
    }
  }, [displayError, authError, localError, dispatch])

  useEffect(() => {
    setLocalError(null)
  }, [email, password, confirmPassword])

  useEffect(() => {
    if (
      googleResponse?.type === 'success' &&
      googleResponse.authentication?.accessToken
    ) {
      dispatch(clearAuthError())
      setLocalError(null)
      dispatch(
        loginWithSocialThunk({
          provider: 'google',
          access_token: googleResponse.authentication.accessToken
        })
      ).catch(err => {
        console.error('Social Login Thunk Error (Signup):', err)
      })
    } else if (googleResponse?.type === 'error') {
      console.error('Google Auth Error (Signup):', googleResponse.error)
      dispatch(clearAuthError())
      setLocalError('Google sign-in failed. Please try again.')
    }
  }, [googleResponse, dispatch])

  const handleRegister = useCallback(async () => {
    if (isLoading) return

    setLocalError(null)
    if (authError) dispatch(clearAuthError())

    if (!email.trim() || !password || !confirmPassword) {
      return
    }
    if (!/\S+@\S+\.\S+/.test(email.trim())) {
      setLocalError('Please enter a valid email address.')
      return
    }
    if (password.length < 6) {
      setLocalError('Password must be at least 6 characters long.')
      return
    }
    if (password !== confirmPassword) {
      setLocalError('Passwords do not match.')
      return
    }

    try {
      await dispatch(
        registerUserThunk({ email: email.trim(), password: password })
      )
    } catch (err: any) {
      console.error('Registration thunk failed:', err)
    }
  }, [email, password, confirmPassword, authError, dispatch])

  const handleGoogleLoginPress = useCallback(() => {
    dispatch(clearAuthError())
    setLocalError(null)
    if (googleRequest) {
      promptAsyncGoogle()
    } else {
      setLocalError('Google Sign-In is not available right now.')
    }
  }, [googleRequest, promptAsyncGoogle, dispatch])

  const handleAppleLoginPress = useCallback(() => {
    dispatch(clearAuthError())
    setLocalError('Apple Sign-In is not yet implemented.')
  }, [dispatch])

  const handleFacebookLoginPress = useCallback(() => {
    dispatch(clearAuthError())
    setLocalError('Facebook Sign-In is not yet implemented.')
  }, [dispatch])

  const handleGoBack = () => {
    if (router.canGoBack()) {
      router.back()
    } else {
      router.replace('/(auth)/login')
    }
  }
  const togglePasswordVisibility = () => setIsPasswordVisible(prev => !prev)
  const toggleConfirmPasswordVisibility = () =>
    setIsConfirmPasswordVisible(prev => !prev)

  const renderSocialButton = useCallback(
    (
      provider: 'google' | 'apple' | 'facebook',
      onPress: () => void,
      disabled: boolean = false
    ) => {
      const iconName = provider === 'facebook' ? 'facebook-f' : provider
      const brandColors = {
        google: '#DB4437',
        apple: '#000000',
        facebook: '#1877F2'
      }
      const pressedColors = {
        google: '#c33d2e',
        apple: '#333333',
        facebook: '#166fe5'
      }
      return (
        <Pressable
          style={({ pressed }) => [
            authStyles.socialButton,
            (disabled || isLoading) && authStyles.buttonDisabled,
            pressed &&
              !(disabled || isLoading) && {
                backgroundColor: pressedColors[provider]
              },
            !pressed && { backgroundColor: brandColors[provider] }
          ]}
          onPress={onPress}
          disabled={disabled || isLoading}
        >
          <FontAwesome
            name={iconName as any}
            size={20}
            color={Colors.light.primaryContent}
          />
        </Pressable>
      )
    },
    [isLoading]
  )

  return (
    <ScrollView
      contentContainerStyle={authStyles.scrollContainer}
      keyboardShouldPersistTaps="handled"
    >
      <View style={authStyles.innerContainer}>
        <View style={authStyles.headerContainer}>
          <TouchableOpacity
            onPress={handleGoBack}
            style={authStyles.backButton}
          >
            <ChevronLeft size={28} color={Colors.light.text} />
          </TouchableOpacity>
        </View>

        <View style={authStyles.titleContainer}>
          <Text style={authStyles.title}>Create Account</Text>
          <Text style={authStyles.subtitle}>
            Join us and start your journey!
          </Text>
        </View>

        <View style={authStyles.messageContainer}>
          {displayError && (
            <Text style={authStyles.errorText}>{displayError}</Text>
          )}
        </View>

        <View style={authStyles.formContainer}>
          <View style={authStyles.inputGroup}>
            <Text style={authStyles.label}>Email</Text>
            <TextInput
              style={[authStyles.input, isLoading && authStyles.inputDisabled]}
              placeholder="Enter Email"
              value={email}
              onChangeText={setEmail}
              keyboardType="email-address"
              autoCapitalize="none"
              editable={!isLoading}
              placeholderTextColor={Colors.light.textTertiary}
              returnKeyType="next"
              onSubmitEditing={() => passwordInputRef.current?.focus()}
              blurOnSubmit={false}
            />
          </View>
          <View style={authStyles.inputGroup}>
            <Text style={authStyles.label}>Password</Text>
            <View
              style={[
                authStyles.passwordInputWrapper,
                isLoading && styles.inputWrapperDisabled
              ]}
            >
              <TextInput
                ref={passwordInputRef}
                style={[
                  authStyles.input,
                  authStyles.passwordInputOnly,
                  isLoading && authStyles.inputDisabled
                ]}
                placeholder="Enter Password (min. 6 chars)"
                value={password}
                onChangeText={setPassword}
                secureTextEntry={!isPasswordVisible}
                editable={!isLoading}
                placeholderTextColor={Colors.light.textTertiary}
                returnKeyType="next"
                onSubmitEditing={() => confirmPasswordInputRef.current?.focus()}
                blurOnSubmit={false}
              />
              <TouchableOpacity
                onPress={togglePasswordVisibility}
                style={authStyles.passwordVisibilityButton}
                disabled={isLoading}
              >
                {isPasswordVisible ? (
                  <EyeOff size={20} color={Colors.light.textSecondary} />
                ) : (
                  <Eye size={20} color={Colors.light.textSecondary} />
                )}
              </TouchableOpacity>
            </View>
          </View>
          <View style={authStyles.inputGroup}>
            <Text style={authStyles.label}>Confirm Password</Text>
            <View
              style={[
                authStyles.passwordInputWrapper,
                isLoading && styles.inputWrapperDisabled
              ]}
            >
              <TextInput
                ref={confirmPasswordInputRef}
                style={[
                  authStyles.input,
                  authStyles.passwordInputOnly,
                  isLoading && authStyles.inputDisabled
                ]}
                placeholder="Confirm Password"
                value={confirmPassword}
                onChangeText={setConfirmPassword}
                secureTextEntry={!isConfirmPasswordVisible}
                editable={!isLoading}
                placeholderTextColor={Colors.light.textTertiary}
                onSubmitEditing={handleRegister}
                returnKeyType="go"
              />
              <TouchableOpacity
                onPress={toggleConfirmPasswordVisibility}
                style={authStyles.passwordVisibilityButton}
                disabled={isLoading}
              >
                {isConfirmPasswordVisible ? (
                  <EyeOff size={20} color={Colors.light.textSecondary} />
                ) : (
                  <Eye size={20} color={Colors.light.textSecondary} />
                )}
              </TouchableOpacity>
            </View>
          </View>
        </View>

        <View style={styles.socialLoginsSection}>
          <View style={styles.orSeparatorContainer}>
            <View style={styles.orSeparatorLine} />
            <Text style={styles.orSeparatorText}>or continue with</Text>
            <View style={styles.orSeparatorLine} />
          </View>
          <View style={styles.socialLoginContainer}>
            {renderSocialButton(
              'google',
              handleGoogleLoginPress,
              !googleRequest || isLoading
            )}
            {renderSocialButton('apple', handleAppleLoginPress, isLoading)}
            {renderSocialButton(
              'facebook',
              handleFacebookLoginPress,
              isLoading
            )}
          </View>
        </View>

        <View
          style={[authStyles.footerContainer, styles.signupFooterContainer]}
        >
          <Pressable
            style={({ pressed }) => [
              authStyles.actionButton,
              isLoading && authStyles.buttonDisabled,
              pressed && !isLoading && authStyles.actionButtonPressed
            ]}
            onPress={handleRegister}
            disabled={isLoading}
          >
            {isLoading ? (
              <ActivityIndicator color={Colors.common.white} />
            ) : (
              <Text style={authStyles.actionButtonText}>Register</Text>
            )}
          </Pressable>
          <View style={styles.loginLinkContainer}>
            <Text style={styles.footerText}>Already have an account? </Text>
            <Link href="/(auth)/login" asChild>
              <Pressable disabled={isLoading}>
                <Text
                  style={[
                    authStyles.linkTextBold,
                    isLoading && authStyles.linkDisabled
                  ]}
                >
                  Log In
                </Text>
              </Pressable>
            </Link>
          </View>
        </View>
      </View>
    </ScrollView>
  )
}

const styles = StyleSheet.create({
  signupFooterContainer: { gap: 20 },
  loginLinkContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center'
  },
  footerText: {
    fontSize: 14,
    fontFamily: 'Inter-Regular',
    color: Colors.light.textSecondary
  },
  inputWrapperDisabled: {},
  socialLoginsSection: { gap: 20, marginTop: 10 },
  orSeparatorContainer: { flexDirection: 'row', alignItems: 'center' },
  orSeparatorLine: { flex: 1, height: 1, backgroundColor: Colors.light.border },
  orSeparatorText: {
    marginHorizontal: 12,
    fontSize: 14,
    fontFamily: 'Inter-Medium',
    color: Colors.light.textSecondary
  },
  socialLoginContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    gap: 20
  },
  socialButton: {
    width: 50,
    height: 50,
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1,
    borderColor: Colors.light.border
  }
})

```
src/app/(auth)/_styles/authStyles.ts
```typescript
import { StyleSheet, Platform } from 'react-native'
import { Colors } from '@constants/Colors'

const authStyles = StyleSheet.create({
  scrollContainer: {
    flexGrow: 1,
    justifyContent: 'center',
    backgroundColor: Colors.light.background
  },
  innerContainer: {
    paddingHorizontal: 24,
    paddingVertical: Platform.OS === 'ios' ? 20 : 30,
    width: '100%',
    maxWidth: 420,
    alignSelf: 'center',
    gap: 20
  },
  headerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    minHeight: 40
  },
  backButton: {
    padding: 8,
    marginLeft: -8
  },
  titleContainer: {},
  title: {
    fontSize: 28,
    fontFamily: 'Inter-Bold',
    color: Colors.light.text,
    marginBottom: 8
  },
  subtitle: {
    fontSize: 17,
    fontFamily: 'Inter-Regular',
    color: Colors.light.textSecondary,
    lineHeight: 24
  },
  messageContainer: {
    minHeight: 20,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 10
  },
  errorText: {
    color: Colors.light.error,
    textAlign: 'center',
    fontFamily: 'Inter-Medium',
    fontSize: 14,
    lineHeight: 18
  },
  successText: {
    color: Colors.light.success,
    textAlign: 'center',
    fontFamily: 'Inter-Medium',
    fontSize: 14,
    lineHeight: 18
  },
  formContainer: {
    gap: 18
  },
  inputGroup: {
    width: '100%'
  },
  label: {
    fontSize: 14,
    fontFamily: 'Inter-Medium',
    color: Colors.light.textSecondary,
    marginBottom: 8
  },
  input: {
    height: 52,
    paddingHorizontal: 16,
    borderRadius: 10,
    fontSize: 16,
    backgroundColor: Colors.light.inputBackground,
    color: Colors.light.text,
    fontFamily: 'Inter-Regular',
    borderWidth: 1,
    borderColor: Colors.light.inputBorder
  },
  inputFocused: {
    borderColor: Colors.light.inputBorderFocused
  },
  inputDisabled: {
    backgroundColor: Colors.light.backgroundSecondary,
    color: Colors.light.textTertiary,
    borderColor: Colors.light.borderSubtle
  },
  passwordInputWrapper: {
    flexDirection: 'row',
    alignItems: 'center',
    borderRadius: 10,
    borderWidth: 1,
    borderColor: Colors.light.inputBorder,
    backgroundColor: Colors.light.inputBackground
  },
  passwordInputWrapperFocused: {
    borderColor: Colors.light.inputBorderFocused
  },
  passwordInputOnly: {
    flex: 1,
    borderWidth: 0,
    height: 50,
    backgroundColor: Colors.common.transparent,
    paddingLeft: 16,
    paddingRight: 0
  },
  passwordVisibilityButton: {
    padding: 14
  },
  linkText: {
    color: Colors.light.textLink,
    fontSize: 14,
    fontFamily: 'Inter-Medium'
  },
  linkTextBold: {
    color: Colors.light.textLink,
    fontSize: 14,
    fontFamily: 'Inter-SemiBold'
  },
  linkDisabled: {
    opacity: 0.6
  },
  footerContainer: {
    width: '100%',
    alignItems: 'center',
    marginTop: 15,
    gap: 15
  },
  actionButton: {
    width: '100%',
    height: 52,
    backgroundColor: Colors.common.gray[900],
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 3,
    elevation: 2
  },
  actionButtonPressed: {
    backgroundColor: Colors.common.gray[800]
  },
  actionButtonText: {
    color: Colors.light.primaryContent,
    fontSize: 16,
    fontFamily: 'Inter-SemiBold'
  },
  buttonDisabled: {
    backgroundColor: Colors.light.buttonDisabledBackground,
    shadowOpacity: 0,
    elevation: 0
  },
  socialButton: {
    width: 50,
    height: 50,
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center'
  },
  orSeparatorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    width: '100%',
    marginVertical: 10
  },
  orSeparatorLine: { flex: 1, height: 1, backgroundColor: Colors.light.border },
  orSeparatorText: {
    marginHorizontal: 12,
    fontSize: 13,
    fontFamily: 'Inter-Regular',
    color: Colors.light.textSecondary
  }
})

export default authStyles

```
src/constants/Colors.ts
```typescript
const teinte = {
  purple: '#7C3AED',
  blue: '#3B82F6',
  pink: '#EC4899',
  green: '#10B981',
  yellow: '#F59E0B',
  orange: '#F97316',
  red: '#EF4444'
}

const gray = {
  50: '#F9FAFB',
  100: '#F3F4F6',
  200: '#E5E7EB',
  300: '#D1D5DB',
  400: '#9CA3AF',
  500: '#6B7280',
  600: '#4B5563',
  700: '#374151',
  800: '#1F2937',
  900: '#11182C'
}

const common = {
  white: '#FFFFFF',
  black: '#000000',
  transparent: 'transparent'
}

const shadow = {
  subtle: `rgba(${common.black}, 0.05)`,
  soft: `rgba(${common.black}, 0.1)`,
  medium: `rgba(${common.black}, 0.15)`,
  strong: `rgba(${common.black}, 0.2)`,
  legacyDark: 'rgba(0,0,0,0.7)'
}

const teinteBackgrounds = {
  purple: '#F3E8FF',
  blue: '#DBEAFE',
  pink: '#FCE7F3',
  green: '#D1FAE5',
  yellow: '#FEF9C3',
  orange: '#FFF7ED',
  red: '#FEE2E2'
}

const lightTheme = {
  primary: teinte.green,
  primaryContent: common.white,
  primaryLight: teinteBackgrounds.green,

  secondary: teinte.blue,
  secondaryContent: common.white,
  secondaryLight: teinteBackgrounds.blue,

  accent: teinte.pink,
  accentContent: common.white,
  accentLight: teinteBackgrounds.pink,

  background: common.white,
  backgroundSecondary: gray[100],
  backgroundTertiary: gray[50],
  backgroundOverlay: `rgba(${common.black}, 0.4)`,

  text: gray[800],
  textSecondary: gray[500],
  textTertiary: gray[400],
  textPlaceholder: gray[300],
  textDisabled: gray[300],
  textInverted: common.white,
  textLink: teinte.blue,

  border: gray[200],
  borderStrong: gray[300],
  borderSubtle: gray[100],
  inputBorder: gray[300],
  inputBorderFocused: teinte.green,

  success: teinte.green,
  successContent: common.white,
  successBackground: teinteBackgrounds.green,

  warning: teinte.yellow,
  warningContent: gray[800],
  warningBackground: teinteBackgrounds.yellow,

  error: teinte.red,
  errorContent: common.white,
  errorBackground: teinteBackgrounds.red,

  info: teinte.blue,
  infoContent: common.white,
  infoBackground: teinteBackgrounds.blue,

  cardBackground: common.white,
  cardBackgroundSubtle: gray[50],
  inputBackground: common.white,
  buttonDisabledBackground: gray[200],
  buttonDisabledContent: gray[400],

  shadowSubtle: shadow.subtle,
  shadowSoft: shadow.soft,
  shadowMedium: shadow.medium,
  shadowStrong: shadow.strong,

  accentOrange: teinte.orange,
  accentOrangeLight: teinteBackgrounds.orange,
  accentYellow: teinte.yellow,
  accentYellowLight: teinteBackgrounds.yellow,
  accentBlue: teinte.blue,
  accentBlueLight: teinteBackgrounds.blue,
  accentGreen: teinte.green,
  accentGreenLight: teinteBackgrounds.green,

  screenBackgroundGradientFrom: teinteBackgrounds.purple,
  screenBackgroundGradientTo: teinteBackgrounds.blue,

  homeHeaderPoints: teinte.yellow,
  homeHeaderLives: teinte.pink,
  streakDayActive: teinte.green,
  streakDayCurrent: teinte.purple,
  streakDayFuture: gray[200],
  streakDayBroken: teinte.red,
  dailyGoalProgress: teinte.blue,
  dailyGoalTrack: gray[100],

  moduleFlashcardBg: teinteBackgrounds.pink,
  moduleQuizBg: teinteBackgrounds.green,
  moduleNewWordsBg: teinteBackgrounds.yellow,

  tabBarBackground: common.white,
  tabBarActive: teinte.purple,
  tabBarInactive: gray[500],
  tabIconBackgroundActive: teinte.purple + '1A',
  tabIconBackgroundInactive: gray[100],

  flashcardGradientFrom: teinteBackgrounds.pink,
  flashcardGradientTo: teinteBackgrounds.purple,
  flashcardProgressBarFill: teinte.pink,
  flashcardIconBgFront: teinteBackgrounds.pink,
  flashcardIconBgBack: teinteBackgrounds.blue,
  flashcardLangCircleFrBg: teinteBackgrounds.blue,
  flashcardLangCircleFrText: teinte.blue,
  flashcardLangCircleEnBg: teinteBackgrounds.red,
  flashcardLangCircleEnText: teinte.red,
  flashcardAudioButtonFrontBg: teinteBackgrounds.pink,
  flashcardAudioButtonFrontIcon: teinte.pink,
  flashcardAudioButtonBackBg: teinteBackgrounds.blue,
  flashcardAudioButtonBackIcon: teinte.blue,
  flashcardButtonHardBg: teinteBackgrounds.red,
  flashcardButtonMediumBg: teinteBackgrounds.yellow,
  flashcardButtonEasyBg: teinteBackgrounds.green,
  flashcardButtonHardIcon: teinte.red,
  flashcardButtonMediumIcon: teinte.yellow,
  flashcardButtonEasyIcon: teinte.green,
  flashcardButtonText: gray[900],
  flashcardTermText: gray[900],
  flashcardInstructionText: gray[500],
  flashcardPronunciationText: teinte.blue,
  flashcardLangCircleFI: teinte.purple + '33',
  flashcardLangTextFI: teinte.purple,
  flashcardLangCircleEN: teinte.blue + '33',
  flashcardLangTextEN: teinte.blue,
  flashcardAudioButton: teinte.purple,
  flashcardTipBackground: common.white,

  quizScreenGradientFrom: teinteBackgrounds.blue,
  quizScreenGradientTo: '#E0E7FF',
  quizQuestionCardBg: common.white,
  quizOptionBg: common.white,
  quizOptionBorder: gray[200],
  quizOptionSelectedBorder: teinte.blue,
  quizOptionSelectedBg: teinte.blue + '26',
  quizCorrectBg: teinte.green + '26',
  quizCorrectBorder: teinte.green,
  quizIncorrectBg: teinte.red + '26',
  quizIncorrectBorder: teinte.red,
  quizSubmitButtonBg: teinte.blue,
  quizNextButtonBg: teinte.green,

  fillBlankScreenGradientFrom: teinteBackgrounds.green,
  fillBlankScreenGradientTo: '#A7F3D0',
  fillBlankInputBg: common.white,
  fillBlankInputBorder: gray[200],
  fillBlankInputFocusedBorder: teinte.green,
  fillBlankOptionSelectedBorder: teinte.green,
  fillBlankOptionSelectedBg: teinte.green + '33',
  fillBlankSubmitButtonBg: teinte.green,
  fillBlankNextButtonBg: teinte.blue
}

const darkTheme = {}

export const Colors = {
  common: {
    ...common,
    gray
  },
  light: lightTheme,
  dark: darkTheme
}

```
src/constants/appStorage.ts
```typescript

```
src/constants/navigation.ts
```typescript
import {
  LucideIcon,
  Home,
  Book,
  User,
  BicepsFlexed,
  Settings
} from 'lucide-react-native'

export interface NavItem {
  name: string
  path:
    | `/${string}/`
    | `/${string}/${string}/`
    | `/${string}/${string}/${string}/`
  icon: LucideIcon
  targetSegment: string | null
  protected?: boolean
  isTabItem: boolean
}

export const navItems: NavItem[] = [
  {
    name: 'Home',
    path: '/(main)/(tabs)/',
    icon: Home,
    targetSegment: 'index',
    isTabItem: true
  },
  {
    name: 'Reader',
    path: '/(main)/(tabs)/reader',
    icon: Book,
    targetSegment: 'reader',
    isTabItem: true
  },
  {
    name: 'Practice',
    path: '/(main)/(tabs)/exercises',
    icon: BicepsFlexed,
    targetSegment: 'exercises',
    isTabItem: true
  },
  {
    name: 'Profile',
    path: '/(main)/(tabs)/profile',
    icon: User,
    targetSegment: 'profile',
    protected: true,
    isTabItem: true
  },
  {
    name: 'Settings',
    path: '/(main)/settings/',
    icon: Settings,
    targetSegment: 'settings',
    protected: true,
    isTabItem: false
  }
]

```
src/features/progress/progressActions.ts
```typescript
// src/features/progress/progressActions.ts
import { createAsyncThunk } from '@reduxjs/toolkit'
import { apiClient } from '@lib/api'
import { AppDispatch } from '@store/store'
import { ApiError } from '@lib/ApiError'
import { ProgressSummary } from './types'

// Thunk for fetching progress summary
export const fetchProgressThunk = createAsyncThunk<
  ProgressSummary, // Return type
  void, // Argument type
  { dispatch: AppDispatch; rejectValue: string }
>('progress/fetch', async (_, { dispatch, rejectWithValue }) => {
  try {
    const response = await apiClient.get<ProgressSummary>(
      '/me/progress',
      dispatch
    )
    return response
  } catch (error: any) {
    let message = 'Failed to fetch progress summary. Please try again later.'
    if (error instanceof ApiError) {
      // You could customize message based on error.status or error.data
      // e.g., if (error.status === 403) message = "You don't have permission."
      message =
        error.data?.detail || error.data?.message || error.message || message
    } else if (error.message) {
      message = error.message
    }
    return rejectWithValue(message)
  }
})

```
src/features/progress/progressSlice.ts
```typescript
// src/features/progress/progressSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit'
import { ProgressState, ProgressSummary } from './types'
import { fetchProgressThunk } from './progressActions'
import { RootState } from '@/store/store'
import { ApiStatusType } from '@lib/api.d'

const initialState: ProgressState = {
  summary: null,
  status: 'idle',
  error: null
}

const progressSlice = createSlice({
  name: 'progress',
  initialState,
  reducers: {
    clearProgress(state) {
      // e.g., on logout
      state.summary = null
      state.status = 'idle'
      state.error = null
    }
  },
  extraReducers: builder => {
    builder
      .addCase(fetchProgressThunk.pending, state => {
        state.status = 'loading'
        state.error = null
      })
      .addCase(
        fetchProgressThunk.fulfilled,
        (state, action: PayloadAction<ProgressSummary>) => {
          state.status = 'succeeded'
          state.summary = action.payload
        }
      )
      .addCase(fetchProgressThunk.rejected, (state, action) => {
        state.status = 'failed'
        state.error = action.payload ?? 'Unknown error'
      })
  }
})

export const { clearProgress } = progressSlice.actions
export default progressSlice.reducer

// Selectors
export const selectProgressSummary = (
  state: RootState
): ProgressSummary | null => state.progress.summary
export const selectProgressStatus = (state: RootState): ApiStatusType =>
  state.progress.status

```
src/features/progress/types.ts
```typescript
import type { ApiStatusType } from '@lib/api.d'

export interface StreakInfo {
  current_streak_days: number
  longest_streak_days: number
  last_activity_date?: string | null
}

export interface WeeklyActivityDay {
  day: 'Mon' | 'Tue' | 'Wed' | 'Thu' | 'Fri' | 'Sat' | 'Sun'
  minutes: number
}

export interface CategoryProgress {
  category: string
  time_spent_minutes: number
}

export interface ProgressSummary {
  streak: StreakInfo
  level: number
  progress_to_next_level: number
  total_study_time_minutes: number
  learned_words_count: number
  learning_words_count: number
  articles_read_count: number
  exercises_completed_count: number
  achievements_earned_count: number
  weekly_activity: WeeklyActivityDay[]
  category_progress: CategoryProgress[]
}

export interface ProgressState {
  summary: ProgressSummary | null
  status: ApiStatusType
  error: string | null
}

```
src/features/achievements/achievementsActions.ts
```typescript
// src/features/achievements/achievementsActions.ts
import { createAsyncThunk } from '@reduxjs/toolkit'
import { apiClient } from '@lib/api'
import { AppDispatch } from '@store/store'
import { ApiError } from '@lib/ApiError'
import { EarnedAchievement, AchievementListResponse } from './types'

// Thunk for fetching earned achievements list
export const fetchEarnedAchievementsThunk = createAsyncThunk<
  EarnedAchievement[], // Return type
  void, // Argument type
  { dispatch: AppDispatch; rejectValue: string }
>('achievements/fetchEarned', async (_, { dispatch, rejectWithValue }) => {
  try {
    // Assuming the API returns { "achievements": [...] }
    const response = await apiClient.get<AchievementListResponse>(
      '/me/achievements',
      dispatch
    )
    return response.achievements
  } catch (error: any) {
    let message = 'Failed to fetch earned achievements. Please try again.'
    if (error instanceof ApiError) {
      message =
        error.data?.detail || error.data?.message || error.message || message
    } else if (error.message) {
      message = error.message
    }
    return rejectWithValue(message)
  }
})

```
src/features/achievements/achievementsSlice.ts
```typescript
// src/features/achievements/achievementsSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit'
import { AchievementsState, EarnedAchievement } from './types'
import { fetchEarnedAchievementsThunk } from './achievementsActions'
import { ApiStatusType } from '@lib/api.d'
import { RootState } from '@/store/store'

const initialState: AchievementsState = {
  earnedAchievements: [],
  status: 'idle',
  error: null
}

const achievementsSlice = createSlice({
  name: 'achievements',
  initialState,
  reducers: {
    clearAchievements(state) {
      // e.g., on logout
      state.earnedAchievements = []
      state.status = 'idle'
      state.error = null
    }
  },
  extraReducers: builder => {
    builder
      .addCase(fetchEarnedAchievementsThunk.pending, state => {
        state.status = 'loading'
        state.error = null
      })
      .addCase(
        fetchEarnedAchievementsThunk.fulfilled,
        (state, action: PayloadAction<EarnedAchievement[]>) => {
          state.status = 'succeeded'
          state.earnedAchievements = action.payload
        }
      )
      .addCase(fetchEarnedAchievementsThunk.rejected, (state, action) => {
        state.status = 'failed'
        state.error = action.payload ?? 'Unknown error'
      })
  }
})

export const { clearAchievements } = achievementsSlice.actions
export default achievementsSlice.reducer

// Selectors
export const selectEarnedAchievements = (
  state: RootState
): EarnedAchievement[] => state.achievements.earnedAchievements
export const selectAchievementsStatus = (state: RootState): ApiStatusType =>
  state.achievements.status

```
src/features/achievements/types.ts
```typescript
// src/features/achievements/types.ts
import { ApiStatusType } from '@lib/api.d'

// Assuming a structure for the detailed achievement info
export interface AchievementDetails {
  achievement_id: string
  name: string
  description: string
  icon_name?: string | null // Name for an icon component
  points?: number
  // Add other detail fields like criteria, category etc.
}

// Structure for an earned achievement entry from the API list
export interface EarnedAchievement {
  achievement_id: string
  earned_at: string // ISO Date string
  details?: AchievementDetails | null // Populated by the list endpoint
}

// Structure for the earned achievements list API response
export interface AchievementListResponse {
  achievements: EarnedAchievement[]
  // Add pagination details if applicable
}

// Redux state for this slice
export interface AchievementsState {
  earnedAchievements: EarnedAchievement[] // List of earned achievements
  status: ApiStatusType // Status for LISTING earned achievements
  error: string | null
}

```
src/features/auth/authActionTypes.ts
```typescript
import { User } from './types'

export const LOGIN_REQUEST = 'auth/LOGIN_REQUEST'
export const LOGIN_SUCCESS = 'auth/LOGIN_SUCCESS'
export const LOGIN_FAILURE = 'auth/LOGIN_FAILURE'

export const SOCIAL_LOGIN_REQUEST = 'auth/SOCIAL_LOGIN_REQUEST'
export const SOCIAL_LOGIN_SUCCESS = 'auth/SOCIAL_LOGIN_SUCCESS'
export const SOCIAL_LOGIN_FAILURE = 'auth/SOCIAL_LOGIN_FAILURE'

export const REGISTER_REQUEST = 'auth/REGISTER_REQUEST'
export const REGISTER_FAILURE = 'auth/REGISTER_FAILURE'

export const FORGOT_PASSWORD_REQUEST = 'auth/FORGOT_PASSWORD_REQUEST'
export const FORGOT_PASSWORD_SUCCESS = 'auth/FORGOT_PASSWORD_SUCCESS'
export const FORGOT_PASSWORD_FAILURE = 'auth/FORGOT_PASSWORD_FAILURE'

export const VERIFY_RESET_TOKEN_REQUEST = 'auth/VERIFY_RESET_TOKEN_REQUEST'
export const VERIFY_RESET_TOKEN_SUCCESS = 'auth/VERIFY_RESET_TOKEN_SUCCESS'
export const VERIFY_RESET_TOKEN_FAILURE = 'auth/VERIFY_RESET_TOKEN_FAILURE'

export const RESET_PASSWORD_REQUEST = 'auth/RESET_PASSWORD_REQUEST'
export const RESET_PASSWORD_SUCCESS = 'auth/RESET_PASSWORD_SUCCESS'
export const RESET_PASSWORD_FAILURE = 'auth/RESET_PASSWORD_FAILURE'

export const INITIALIZE_AUTH_REQUEST = 'auth/INITIALIZE_AUTH_REQUEST'
export const INITIALIZE_AUTH_SUCCESS = 'auth/INITIALIZE_AUTH_SUCCESS'
export const INITIALIZE_AUTH_FAILURE = 'auth/INITIALIZE_AUTH_FAILURE'

export const SET_REFRESHED_TOKENS = 'auth/SET_REFRESHED_TOKENS'

export const LOGOUT_USER = 'auth/LOGOUT_USER'

export const CLEAR_AUTH_ERROR = 'auth/CLEAR_AUTH_ERROR'

export const SET_INITIAL_TOKENS = 'auth/SET_INITIAL_TOKENS'

interface UserAuthenticationSuccessPayload {
  userId: string
  entities: { users: { [key: string]: User } }
}
interface SetRefreshedTokensPayload {
  accessToken: string
  refreshToken: string
  expiresAt: number
}

export interface LoginRequestAction {
  type: typeof LOGIN_REQUEST
}
export interface LoginSuccessAction {
  type: typeof LOGIN_SUCCESS
  payload: UserAuthenticationSuccessPayload
}
export interface LoginFailureAction {
  type: typeof LOGIN_FAILURE
  payload: string
}

export interface SocialLoginRequestAction {
  type: typeof SOCIAL_LOGIN_REQUEST
}
export interface SocialLoginSuccessAction {
  type: typeof SOCIAL_LOGIN_SUCCESS
  payload: UserAuthenticationSuccessPayload
}
export interface SocialLoginFailureAction {
  type: typeof SOCIAL_LOGIN_FAILURE
  payload: string
}

export interface RegisterRequestAction {
  type: typeof REGISTER_REQUEST
}
export interface RegisterFailureAction {
  type: typeof REGISTER_FAILURE
  payload: string
}

export interface ForgotPasswordRequestAction {
  type: typeof FORGOT_PASSWORD_REQUEST
}
export interface ForgotPasswordSuccessAction {
  type: typeof FORGOT_PASSWORD_SUCCESS
  payload: string
}
export interface ForgotPasswordFailureAction {
  type: typeof FORGOT_PASSWORD_FAILURE
  payload: string
}

export interface VerifyResetTokenRequestAction {
  type: typeof VERIFY_RESET_TOKEN_REQUEST
}
export interface VerifyResetTokenSuccessAction {
  type: typeof VERIFY_RESET_TOKEN_SUCCESS
}
export interface VerifyResetTokenFailureAction {
  type: typeof VERIFY_RESET_TOKEN_FAILURE
  payload: string
}

export interface ResetPasswordRequestAction {
  type: typeof RESET_PASSWORD_REQUEST
}
export interface ResetPasswordSuccessAction {
  type: typeof RESET_PASSWORD_SUCCESS
  payload: string
}
export interface ResetPasswordFailureAction {
  type: typeof RESET_PASSWORD_FAILURE
  payload: string
}

export interface InitializeAuthRequestAction {
  type: typeof INITIALIZE_AUTH_REQUEST
}
export interface InitializeAuthSuccessAction {
  type: typeof INITIALIZE_AUTH_SUCCESS
  payload?: { newUserData?: UserAuthenticationSuccessPayload } | null
}
export interface InitializeAuthFailureAction {
  type: typeof INITIALIZE_AUTH_FAILURE
  payload?: string | null
}

export interface SetRefreshedTokensAction {
  type: typeof SET_REFRESHED_TOKENS
  payload: SetRefreshedTokensPayload
}
export interface LogoutUserAction {
  type: typeof LOGOUT_USER
}
export interface ClearAuthErrorAction {
  type: typeof CLEAR_AUTH_ERROR
}

export type AuthAction =
  | LoginRequestAction
  | LoginSuccessAction
  | LoginFailureAction
  | SocialLoginRequestAction
  | SocialLoginSuccessAction
  | SocialLoginFailureAction
  | RegisterRequestAction
  | RegisterFailureAction
  | InitializeAuthRequestAction
  | InitializeAuthSuccessAction
  | InitializeAuthFailureAction
  | SetRefreshedTokensAction
  | LogoutUserAction
  | ClearAuthErrorAction

```
src/features/auth/authActions.ts
```typescript
import * as actionTypes from './authActionTypes'
import type {
  User,
  LoginResponse,
  SocialLoginPayload,
  RegisterPayload,
  ForgotPasswordPayload,
  ResetPasswordPayload,
  RawSignupApiResponse,
  VerifyResetTokenPayload
} from './types'
import { normalize } from 'normalizr'
import { USER_SCHEMA } from '@entities/schemas'
import {
  apiClient,
  resetTokenRefreshFailure,
  signalAuthInitialized
} from '@lib/api'
import { RootState, AppDispatch, AppThunk } from '@store/store'
import * as tokenStorage from '@lib/tokenStorage'
import { router } from 'expo-router'
import { ApiError } from '@lib/ApiError'
import { GoogleSignin } from '@react-native-google-signin/google-signin'

export const loginRequest = (): actionTypes.LoginRequestAction => ({
  type: actionTypes.LOGIN_REQUEST
})
export const loginSuccess = (
  payload: actionTypes.LoginSuccessAction['payload']
): actionTypes.LoginSuccessAction => ({
  type: actionTypes.LOGIN_SUCCESS,
  payload
})
export const loginFailure = (
  error: string
): actionTypes.LoginFailureAction => ({
  type: actionTypes.LOGIN_FAILURE,
  payload: error
})

export const socialLoginRequest = (): actionTypes.SocialLoginRequestAction => ({
  type: actionTypes.SOCIAL_LOGIN_REQUEST
})
export const socialLoginSuccess = (
  payload: actionTypes.SocialLoginSuccessAction['payload']
): actionTypes.SocialLoginSuccessAction => ({
  type: actionTypes.SOCIAL_LOGIN_SUCCESS,
  payload
})
export const socialLoginFailure = (
  error: string
): actionTypes.SocialLoginFailureAction => ({
  type: actionTypes.SOCIAL_LOGIN_FAILURE,
  payload: error
})

export const registerRequest = (): actionTypes.RegisterRequestAction => ({
  type: actionTypes.REGISTER_REQUEST
})
export const registerFailure = (
  error: string
): actionTypes.RegisterFailureAction => ({
  type: actionTypes.REGISTER_FAILURE,
  payload: error
})

export const forgotPasswordRequest =
  (): actionTypes.ForgotPasswordRequestAction => ({
    type: actionTypes.FORGOT_PASSWORD_REQUEST
  })
export const forgotPasswordSuccess = (
  message: string
): actionTypes.ForgotPasswordSuccessAction => ({
  type: actionTypes.FORGOT_PASSWORD_SUCCESS,
  payload: message
})
export const forgotPasswordFailure = (
  error: string
): actionTypes.ForgotPasswordFailureAction => ({
  type: actionTypes.FORGOT_PASSWORD_FAILURE,
  payload: error
})
export const verifyResetTokenRequest =
  (): actionTypes.VerifyResetTokenRequestAction => ({
    type: actionTypes.VERIFY_RESET_TOKEN_REQUEST
  })
export const verifyResetTokenSuccess =
  (): actionTypes.VerifyResetTokenSuccessAction => ({
    type: actionTypes.VERIFY_RESET_TOKEN_SUCCESS
  })
export const verifyResetTokenFailure = (
  error: string
): actionTypes.VerifyResetTokenFailureAction => ({
  type: actionTypes.VERIFY_RESET_TOKEN_FAILURE,
  payload: error
})
export const resetPasswordRequest =
  (): actionTypes.ResetPasswordRequestAction => ({
    type: actionTypes.RESET_PASSWORD_REQUEST
  })
export const resetPasswordSuccess = (
  message: string
): actionTypes.ResetPasswordSuccessAction => ({
  type: actionTypes.RESET_PASSWORD_SUCCESS,
  payload: message
})
export const resetPasswordFailure = (
  error: string
): actionTypes.ResetPasswordFailureAction => ({
  type: actionTypes.RESET_PASSWORD_FAILURE,
  payload: error
})

export const initializeAuthRequest =
  (): actionTypes.InitializeAuthRequestAction => ({
    type: actionTypes.INITIALIZE_AUTH_REQUEST
  })
export const initializeAuthSuccess = (
  payload?: actionTypes.InitializeAuthSuccessAction['payload']
): actionTypes.InitializeAuthSuccessAction => ({
  type: actionTypes.INITIALIZE_AUTH_SUCCESS,
  payload
})
export const initializeAuthFailure = (
  error?: string | null
): actionTypes.InitializeAuthFailureAction => ({
  type: actionTypes.INITIALIZE_AUTH_FAILURE,
  payload: error
})
export const setRefreshedTokens = (
  payload: actionTypes.SetRefreshedTokensAction['payload']
): actionTypes.SetRefreshedTokensAction => ({
  type: actionTypes.SET_REFRESHED_TOKENS,
  payload
})
export const logoutUserSuccess = (): actionTypes.LogoutUserAction => ({
  type: actionTypes.LOGOUT_USER
})
export const clearAuthError = (): actionTypes.ClearAuthErrorAction => ({
  type: actionTypes.CLEAR_AUTH_ERROR
})
export const setInitialTokens = (
  payload: actionTypes.SetInitialTokensAction['payload']
): actionTypes.SetInitialTokensAction => ({
  type: actionTypes.SET_INITIAL_TOKENS,
  payload
})

export const loginUserThunk =
  (credentials: { email: string; password: string }): AppThunk<Promise<void>> =>
  async (dispatch: AppDispatch) => {
    dispatch(loginRequest())
    try {
      const loginData = await apiClient.post<LoginResponse>(
        '/auth/login/email',
        credentials,
        dispatch
      )
      const expiresAt = Date.now() + loginData.expires_in * 1000
      console.log('Login Data:', expiresAt)
      await tokenStorage.setStoredTokens(
        loginData.access_token,
        loginData.refresh_token,
        expiresAt
      )
      const normalizedUser = normalize(loginData.user, USER_SCHEMA)
      dispatch(
        loginSuccess({
          userId: loginData.user.id,
          entities: normalizedUser.entities as {
            users: { [key: string]: User }
          }
        })
      )
      resetTokenRefreshFailure()
    } catch (error: any) {
      let message = 'Login failed. Please check your credentials.'
      if (error instanceof ApiError) {
        message =
          error.data?.detail || error.data?.message || error.message || message
      } else if (error.message) {
        message = error.message
      }
      dispatch(loginFailure(message))
      throw error
    }
  }

export const loginWithSocialThunk =
  (payload: SocialLoginPayload): AppThunk<Promise<void>> =>
  async (dispatch: AppDispatch) => {
    dispatch(socialLoginRequest())
    try {
      const loginData = await apiClient.post<LoginResponse>(
        '/auth/login/social',
        payload,
        dispatch
      )
      const expiresAt = Date.now() + loginData.expires_in * 1000
      console.log('Login Data:', expiresAt)
      await tokenStorage.setStoredTokens(
        loginData.access_token,
        loginData.refresh_token,
        expiresAt
      )
      const normalizedUser = normalize(loginData.user, USER_SCHEMA)
      dispatch(
        socialLoginSuccess({
          userId: loginData.user.id,
          entities: normalizedUser.entities as {
            users: { [key: string]: User }
          }
        })
      )
      resetTokenRefreshFailure()
    } catch (error: any) {
      let message = 'Social login failed. Please try again.'
      if (error instanceof ApiError) {
        message =
          error.data?.detail || error.data?.message || error.message || message
      } else if (error.message) {
        message = error.message
      }
      dispatch(socialLoginFailure(message))
      throw error
    }
  }

export const registerUserThunk =
  (payload: RegisterPayload): AppThunk<Promise<void>> =>
  async (dispatch: AppDispatch) => {
    dispatch(registerRequest())
    try {
      const response = await apiClient.post<RawSignupApiResponse>(
        '/auth/register',
        payload,
        dispatch
      )

      const expiresAt = Date.now() + response.expires_in * 1000
      console.log('Login Data:', expiresAt)
      await tokenStorage.setStoredTokens(
        response.access_token,
        response.refresh_token,
        expiresAt
      )
      const normalizedUser = normalize(response.user, USER_SCHEMA)
      dispatch(
        loginSuccess({
          userId: response.user.id,
          entities: normalizedUser.entities as {
            users: { [key: string]: User }
          }
        })
      )
      resetTokenRefreshFailure()
    } catch (error: any) {
      let message = 'Registration failed. Please try again.'
      if (error instanceof ApiError) {
        message =
          error.data?.detail || error.data?.message || error.message || message
      } else if (error.message) {
        message = error.message
      }
      dispatch(registerFailure(message))
      throw error
    }
  }

export const requestPasswordResetThunk =
  (payload: ForgotPasswordPayload): AppThunk<Promise<{ message: string }>> =>
  async (dispatch: AppDispatch) => {
    dispatch(forgotPasswordRequest())
    try {
      const response = await apiClient.post<{ message: string }>(
        '/auth/forgot-password',
        payload,
        dispatch
      )
      dispatch(forgotPasswordSuccess(response.message))
      return response
    } catch (error: any) {
      let message = 'Could not send reset instructions. Please try again later.'
      if (error instanceof ApiError) {
        message =
          error.data?.detail || error.data?.message || error.message || message
      } else if (error.message) {
        message = error.message
      }
      dispatch(forgotPasswordFailure(message))
      throw error
    }
  }

export const verifyResetTokenThunk =
  (payload: VerifyResetTokenPayload): AppThunk<Promise<void>> =>
  async (dispatch: AppDispatch) => {
    dispatch(verifyResetTokenRequest())
    try {
      await apiClient.post<void>('/auth/verify-reset-token', payload, dispatch)
      dispatch(verifyResetTokenSuccess())
    } catch (error: any) {
      let message = 'Invalid or expired verification code.'
      if (error instanceof ApiError) {
        message =
          error.data?.detail || error.data?.message || error.message || message
      } else if (error.message) {
        message = error.message
      }
      dispatch(verifyResetTokenFailure(message))
      throw error
    }
  }

export const executePasswordResetThunk =
  (payload: ResetPasswordPayload): AppThunk<Promise<{ message: string }>> =>
  async (dispatch: AppDispatch) => {
    dispatch(resetPasswordRequest())
    try {
      const response = await apiClient.post<{ message: string }>(
        '/auth/reset-password',
        payload,
        dispatch
      )
      dispatch(resetPasswordSuccess(response.message))
      return response
    } catch (error: any) {
      let message = 'Password reset failed. Please try again.'
      if (error instanceof ApiError) {
        message =
          error.data?.detail || error.data?.message || error.message || message
      } else if (error.message) {
        message = error.message
      }
      dispatch(resetPasswordFailure(message))
      throw error
    }
  }

export const logoutUser = (): AppThunk => async dispatch => {
  if ((await GoogleSignin.getCurrentUser()) !== null) {
    try {
      await GoogleSignin.revokeAccess()
      await GoogleSignin.signOut()
    } catch (error) {
      console.error('Error during Google Sign-out:', error)
    }
  }
  await tokenStorage.removeStoredTokens()

  dispatch(logoutUserSuccess())

  router.replace('/(auth)/login')
}

export const initializeAuthThunk =
  (): AppThunk<Promise<void>> => async (dispatch: AppDispatch) => {
    try {
      dispatch(initializeAuthRequest())
      const storedData = await tokenStorage.getStoredTokens()
      const { token, refreshToken, expiresAt } = storedData

      if (token && refreshToken && expiresAt && expiresAt > Date.now()) {
        dispatch(initializeAuthSuccess())
      } else {
        let reason = 'No valid tokens found in storage.'
        if (token || refreshToken) {
          reason = 'Stored tokens found but invalid/expired.'
          await tokenStorage.removeStoredTokens()
          dispatch(initializeAuthFailure(reason))
          console.log(`InitializeAuth: ${reason}`)
          return
        }

        // User have not logged in
        dispatch(initializeAuthFailure(null))
      }
    } finally {
      signalAuthInitialized()
    }
  }

```
src/features/auth/authReducer.ts
```typescript
import * as actionTypes from './authActionTypes'
import { AuthState } from './types'
import { AuthAction } from './authActionTypes'

const initialState: AuthState = {
  userId: null,
  initialAuthChecked: false,
  status: 'idle',
  error: null
}

const authReducer = (state = initialState, action: AuthAction): AuthState => {
  switch (action.type) {
    case actionTypes.LOGIN_REQUEST:
    case actionTypes.SOCIAL_LOGIN_REQUEST:
    case actionTypes.REGISTER_REQUEST:
      return {
        ...initialState,
        ...state,
        status: 'loading',
        error: null
      }

    case actionTypes.INITIALIZE_AUTH_REQUEST:
      return {
        ...state,
        status: 'loading',
        initialAuthChecked: false,
        error: null
      }

    case actionTypes.LOGIN_SUCCESS:
    case actionTypes.SOCIAL_LOGIN_SUCCESS:
      return {
        ...state,
        userId: action.payload.userId,
        status: 'succeeded',
        initialAuthChecked: true,
        error: null
      }

    case actionTypes.INITIALIZE_AUTH_SUCCESS:
      return {
        ...state,
        userId: action.payload?.newUserData?.userId || state.userId,
        initialAuthChecked: true,
        status: 'succeeded',
        error: null
      }

    case actionTypes.SET_REFRESHED_TOKENS:
      return {
        ...state,
        status: 'succeeded',
        error: null
      }

    case actionTypes.LOGIN_FAILURE:
    case actionTypes.SOCIAL_LOGIN_FAILURE:
    case actionTypes.REGISTER_FAILURE:
    case actionTypes.INITIALIZE_AUTH_FAILURE:
      return {
        ...state,
        status:
          action.type === actionTypes.INITIALIZE_AUTH_FAILURE
            ? 'sessionInvalid'
            : 'failed',
        initialAuthChecked: true,
        error: action.payload
      }

    case actionTypes.LOGOUT_USER:
      return {
        ...initialState,
        initialAuthChecked: true
      }

    case actionTypes.CLEAR_AUTH_ERROR:
      return {
        ...state,
        error: null
      }

    default:
      return state
  }
}

export default authReducer

```
src/features/auth/authSelectors.ts
```typescript
import { RootState } from '@store/store'
import { User, AuthState } from './types'

export const selectIsAuthenticated = (state: RootState): boolean => {
  return !!state.auth.userId && state.auth.status === 'succeeded'
}
export const selectAuthenticatedUserId = (state: RootState): string | null =>
  state.auth.userId

export const selectUser = (state: RootState): User | null => {
  const userId = state.auth.userId
  if (userId && state.entities.users) {
    return state.entities.users[userId] || null
  }
  return null
}
export const selectAuthStatus = (state: RootState): AuthState['status'] =>
  state.auth.status
export const selectAuthError = (state: RootState): string | null =>
  state.auth.error
export const selectInitialAuthChecked = (state: RootState): boolean =>
  state.auth.initialAuthChecked

```
src/features/auth/types.ts
```typescript
import type { ApiStatusType } from '@lib/api.d'

export interface User {
  id: string
  email: string
  name?: string | null
  avatarUrl?: string
  learningLanguage?: string
}

export interface AuthState {
  userId: string | null
  initialAuthChecked: boolean
  status: ApiStatusType | 'sessionInvalid'
  error: string | null
}

export interface LoginResponse {
  access_token: string
  refresh_token: string
  token_type: string
  expires_in: number
  user: User
}

export interface RawSignupApiResponse {
  access_token: string
  refresh_token: string
  token_type: string
  expires_in: number
  user: User
}

export interface SocialLoginPayload {
  provider: string
  access_token: string
}

export interface RegisterPayload {
  email: string
  password: string
}

export interface ForgotPasswordPayload {
  email: string
}

export interface VerifyResetTokenPayload {
  email: string
  token: string
}

export interface ResetPasswordPayload {
  email: string
  token: string
  new_password: string
}

```
src/features/savedItems/savedItemsActions.ts
```typescript
import { createAsyncThunk } from '@reduxjs/toolkit'
import { apiClient } from '@lib/api'
import { normalize } from 'normalizr'
import { SAVED_ITEM_ARRAY_SCHEMA } from '@entities/schemas'
import { AppDispatch } from '@store/store'
import { ApiError } from '@lib/ApiError'
import type {
  ApiSavedItem,
  SaveItemPayload,
  UnsaveItemPayload,
  SavedItemReference
} from './types'

export const fetchSavedItemsThunk = createAsyncThunk<
  {
    result: Array<string | { item_id: string; item_type: string }>
    entities: any
  },
  { itemType?: string } | void,
  { dispatch: AppDispatch; rejectValue: string }
>('savedItems/fetch', async (args, { dispatch, rejectWithValue }) => {
  try {
    const endpoint = args?.itemType
      ? `/me/saved-items?type=${args.itemType}`
      : '/me/saved-items'
    const response = await apiClient.get<{ items: ApiSavedItem[] }>(
      endpoint,
      dispatch
    )

    const normalizedData = normalize(response.items, SAVED_ITEM_ARRAY_SCHEMA)
    const savedItemReferences: SavedItemReference[] = response.items.map(
      apiItem => ({
        item_id: apiItem.item_id,
        item_type: apiItem.item_type,
        saved_at: apiItem.saved_at,
        notes: apiItem.notes
      })
    )

    return { result: savedItemReferences, entities: normalizedData.entities }
  } catch (error: any) {
    let message = 'Failed to fetch saved items. Please try again.'
    if (error instanceof ApiError) {
      message =
        error.data?.detail || error.data?.message || error.message || message
    } else if (error.message) {
      message = error.message
    }
    return rejectWithValue(message)
  }
})

export const saveItemThunk = createAsyncThunk<
  { message: string; item_id: string; item_type: string },
  SaveItemPayload,
  {
    dispatch: AppDispatch
    rejectValue: { message: string; item_id: string; item_type: string }
  }
>('savedItems/save', async (payload, { dispatch, rejectWithValue }) => {
  try {
    const response = await apiClient.post<{ message: string }>(
      '/me/saved-items',
      payload,
      dispatch
    )
    return {
      ...response,
      item_id: payload.item_id,
      item_type: payload.item_type
    }
  } catch (error: any) {
    let message = 'Failed to save item. Please try again.'
    if (error instanceof ApiError) {
      message =
        error.data?.detail || error.data?.message || error.message || message
    } else if (error.message) {
      message = error.message
    }
    return rejectWithValue({
      message,
      item_id: payload.item_id,
      item_type: payload.item_type
    })
  }
})

export const unsaveItemThunk = createAsyncThunk<
  { item_id: string; item_type: string },
  UnsaveItemPayload,
  {
    dispatch: AppDispatch
    rejectValue: { message: string; item_id: string; item_type: string }
  }
>('savedItems/unsave', async (payload, { dispatch, rejectWithValue }) => {
  try {
    await apiClient.delete<void>(
      `/me/saved-items/${payload.item_type}/${payload.item_id}`,
      dispatch
    )
    return { item_id: payload.item_id, item_type: payload.item_type }
  } catch (error: any) {
    let message = 'Failed to unsave item. Please try again.'
    if (error instanceof ApiError) {
      message =
        error.data?.detail || error.data?.message || error.message || message
    } else if (error.message) {
      message = error.message
    }
    return rejectWithValue({
      message,
      item_id: payload.item_id,
      item_type: payload.item_type
    })
  }
})

```
src/features/savedItems/savedItemsSlice.ts
```typescript
import { createSlice, PayloadAction } from '@reduxjs/toolkit'
import type { SavedItemsState, SavedItemReference, ApiSavedItem } from './types'
import {
  fetchSavedItemsThunk,
  saveItemThunk,
  unsaveItemThunk
} from './savedItemsActions'
import type { RootState } from '@/store/store'
import type { ApiStatusType } from '@lib/api.d'
import { Article } from '@features/articles/types'

const initialState: SavedItemsState = {
  items: [],
  status: 'idle',
  error: null
}

const savedItemsSlice = createSlice({
  name: 'savedItems',
  initialState,
  reducers: {
    clearSavedItems(state) {
      // e.g., on logout
      state.items = []
      state.status = 'idle'
      state.error = null
    }
  },
  extraReducers: builder => {
    builder
      // Fetching List
      .addCase(fetchSavedItemsThunk.pending, state => {
        state.status = 'loading'
        state.error = null // Clear previous list errors
      })
      .addCase(
        fetchSavedItemsThunk.fulfilled,
        (
          state,
          action: PayloadAction<{ result: SavedItemReference[]; entities: any }>
        ) => {
          state.status = 'succeeded'
          state.items = action.payload.result // Correct: stores array of SavedItemReference
        }
      )
      .addCase(fetchSavedItemsThunk.rejected, (state, action) => {
        state.status = 'failed'
        state.error = action.payload ?? 'Unknown error'
      })
      // Saving Item (Optional: Optimistic update or just refetch list after)
      .addCase(saveItemThunk.pending, (state, action) => {
        // Optional: Indicate saving state for the specific item
        console.log('Saving item pending:', action.meta.arg.item_id)
      })
      .addCase(saveItemThunk.fulfilled, (state, action) => {
        console.log('Item saved:', action.payload.item_id)
        const newItemRef: SavedItemReference = {
          item_id: action.payload.item_id,
          item_type: action.payload.item_type,
          saved_at: new Date().toISOString() // Placeholder, ideally from server
        }
        // Add if not already present (idempotency)
        if (
          !state.items.find(
            i =>
              i.item_id === newItemRef.item_id &&
              i.item_type === newItemRef.item_type
          )
        ) {
          state.items.unshift(newItemRef) // Add to beginning
        }
      })
      .addCase(saveItemThunk.rejected, (state, action) => {
        console.error('Save item failed:', action.payload)
        // Show error via component's local state or a global system
      })
      // Unsacing Item (Remove item from list if successful)
      .addCase(unsaveItemThunk.pending, (state, action) => {
        console.log('Unsacing item pending:', action.meta.arg.item_id)
      })
      .addCase(unsaveItemThunk.fulfilled, (state, action) => {
        console.log('Item unsaved:', action.payload.item_id)
        // Remove the item from the local Redux list
        state.items = state.items.filter(
          item =>
            !(
              item.item_id === action.payload.item_id &&
              item.item_type === action.payload.item_type
            )
        )
      })
      .addCase(unsaveItemThunk.rejected, (state, action) => {
        console.error('Unsave item failed:', action.payload)
        // Show error via component's local state or a global system
      })
  }
})

export const { clearSavedItems } = savedItemsSlice.actions
export default savedItemsSlice.reducer

// Add Selectors
export const selectSavedItemReferences = (
  state: RootState
): SavedItemReference[] => state.savedItems.items
export const selectSavedItemsStatus = (state: RootState): ApiStatusType =>
  state.savedItems.status
export const selectIsItemSaved = (
  state: RootState,
  itemType: string,
  itemId: string
): boolean => {
  return state.savedItems.items.some(
    // This correctly checks if the reference exists
    item => item.item_type === itemType && item.item_id === itemId
  )
}
export const selectHydratedSavedArticles = (state: RootState): Article[] => {
  const savedArticleRefs = state.savedItems.items.filter(
    // items are SavedItemReference[]
    ref => ref.item_type === 'ArticleVersion'
  )
  const articlesById = state.entities.articles || {}

  return savedArticleRefs
    .map(ref => articlesById[ref.item_id]) // ref.item_id is the correct article UUID
    .filter(article => !!article) as Article[]
}

```
src/features/savedItems/types.ts
```typescript
import { ApiStatusType } from '@lib/api.d'
import { Article } from '@features/articles/types'

export interface BaseWordSnippet {
  id: string
  word_fi: string
  basic_definition_en?: string
  part_of_speech?: string
}

export interface SavedItemReference {
  item_id: string
  item_type: 'ArticleVersion' | 'BaseWord' | string
  saved_at: string
  notes?: string | null
}
export interface ApiSavedItem {
  item_id: string
  item_type: 'ArticleVersion' | 'BaseWord' | string
  saved_at: string
  notes?: string | null
  item_details?: Article | BaseWordSnippet | null // This is what the API provides
}

export interface SaveItemPayload {
  item_type: string
  item_id: string
  notes?: string
}

export interface UnsaveItemPayload {
  item_type: string
  item_id: string
}

export interface SavedItemsState {
  items: SavedItemReference[]
  status: ApiStatusType
  error: string | null
}

export interface BaseWordSnippet {
  id: string
  word_fi: string
  basic_definition_en?: string
  part_of_speech?: string
}

```
src/features/challenges/challengesSlice.ts
```typescript
// src/features/challenges/challengesSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit'
import { apiClient } from '@lib/api'
import type { AppDispatch, RootState } from '@store/store'
import type {
  ChallengesState,
  DailyChallenge,
  DailyChallengeApiResponse
} from './types'
import { ApiError } from '@lib/ApiError'
import type { ApiStatusType } from '@lib/api.d'

const initialState: ChallengesState = {
  currentDailyChallenge: null,
  status: 'idle',
  error: null,
  updateStatus: 'idle',
  updateError: null
}

// --- POLLING HELPER ---
const POLLING_INTERVAL_MS = 3000
const MAX_POLLING_ATTEMPTS = 30 // 30 seconds timeout

async function pollForReadyResponse<T>(
  endpoint: string,
  dispatch: AppDispatch
): Promise<T> {
  let attempts = 0
  while (attempts < MAX_POLLING_ATTEMPTS) {
    const { response, body } = await apiClient.getWithResponse<T>(
      endpoint,
      dispatch
    )

    if (response.status === 200) {
      return body
    }

    if (response.status === 202) {
      console.log(
        `[Polling] Received 202 for ${endpoint}. Waiting ${POLLING_INTERVAL_MS}ms. Attempt ${
          attempts + 1
        }/${MAX_POLLING_ATTEMPTS}`
      )
      await new Promise(resolve => setTimeout(resolve, POLLING_INTERVAL_MS))
      attempts++
    } else {
      throw new ApiError(
        `Unexpected status code ${response.status} during polling.`,
        response.status,
        body
      )
    }
  }
  throw new Error(
    'Challenge generation timed out. Please try again in a moment.'
  )
}

// --- THUNKS ---
export const fetchDailyChallengeThunk = createAsyncThunk<
  DailyChallenge, // We will transform the API response to this type before fulfilling
  { date?: string } | void,
  { dispatch: AppDispatch; rejectValue: string }
>('challenges/fetchDaily', async (args, { dispatch, rejectWithValue }) => {
  try {
    const queryParams = args?.date ? `?date=${args.date}` : ''
    const endpoint = `/me/challenges/daily${queryParams}`

    // Poll for the API response which has the `sections_json` field
    const apiResponse = await pollForReadyResponse<DailyChallengeApiResponse>(
      endpoint,
      dispatch
    )

    // Transform the API response to match our state's structure
    const challengeForState: DailyChallenge = {
      ...apiResponse,
      sections: apiResponse.sections_json // Rename the field
    }

    return challengeForState
  } catch (error: any) {
    const message =
      error instanceof ApiError
        ? error.data?.detail || error.message
        : error.message || 'Failed to fetch daily challenge.'
    return rejectWithValue(message)
  }
})

export const updateDailyChallengeStatusThunk = createAsyncThunk<
  DailyChallenge,
  {
    challengeId: string
    newStatus: 'started' | 'in_progress' | 'completed' | 'skipped'
  },
  { dispatch: AppDispatch; rejectValue: string }
>(
  'challenges/updateStatus',
  async ({ challengeId, newStatus }, { dispatch, rejectWithValue }) => {
    try {
      // Assuming the PUT response might also use sections_json. If so, we transform it.
      // If it returns the final state shape directly, no transform is needed here.
      // Let's assume it returns the same API shape for consistency.
      const apiResponse = await apiClient.put<DailyChallengeApiResponse>(
        `/me/challenges/${challengeId}/status`,
        { new_status: newStatus },
        dispatch
      )
      const challengeForState: DailyChallenge = {
        ...apiResponse,
        sections: apiResponse.sections_json
      }
      return challengeForState
    } catch (error: any) {
      const message =
        error instanceof ApiError
          ? error.data?.detail || error.message
          : error.message || 'Failed to update challenge status.'
      return rejectWithValue(message)
    }
  }
)

const challengesSlice = createSlice({
  name: 'challenges',
  initialState,
  reducers: {
    clearDailyChallenge(state) {
      state.currentDailyChallenge = null
      state.status = 'idle'
      state.error = null
    },
    markChallengeSectionCompleted(
      state,
      action: PayloadAction<{ sectionArrayIndex: number }>
    ) {
      if (
        state.currentDailyChallenge &&
        state.currentDailyChallenge.sections.length >
          action.payload.sectionArrayIndex &&
        action.payload.sectionArrayIndex >= 0
      ) {
        state.currentDailyChallenge.sections =
          state.currentDailyChallenge.sections.map((section, index) => {
            if (index === action.payload.sectionArrayIndex) {
              return { ...section, is_completed: true }
            }
            return section
          })
      }
    }
  },
  extraReducers: builder => {
    builder
      .addCase(fetchDailyChallengeThunk.pending, state => {
        state.status = 'loading'
        state.error = null
      })
      .addCase(
        fetchDailyChallengeThunk.fulfilled,
        (state, action: PayloadAction<DailyChallenge>) => {
          // The payload is already in the correct `DailyChallenge` shape with `sections`
          state.currentDailyChallenge = {
            ...action.payload,
            sections: action.payload.sections.map(s => ({
              ...s,
              is_completed: s.is_completed || false // Ensure client-side flag is present
            }))
          }
          state.status = 'succeeded'
        }
      )
      .addCase(fetchDailyChallengeThunk.rejected, (state, action) => {
        state.status = 'failed'
        state.error = action.payload ?? 'Unknown error.'
      })
      .addCase(updateDailyChallengeStatusThunk.pending, state => {
        state.updateStatus = 'loading'
        state.updateError = null
      })
      .addCase(
        updateDailyChallengeStatusThunk.fulfilled,
        (state, action: PayloadAction<DailyChallenge>) => {
          // Payload is also the correct shape here
          state.currentDailyChallenge = action.payload
          state.updateStatus = 'succeeded'
        }
      )
      .addCase(updateDailyChallengeStatusThunk.rejected, (state, action) => {
        state.updateStatus = 'failed'
        state.updateError = action.payload ?? 'Unknown error.'
      })
  }
})

export const { clearDailyChallenge, markChallengeSectionCompleted } =
  challengesSlice.actions
export default challengesSlice.reducer

export const selectCurrentDailyChallenge = (
  state: RootState
): DailyChallenge | null => state.challenges.currentDailyChallenge
export const selectDailyChallengeFetchStatus = (
  state: RootState
): ApiStatusType => state.challenges.status
export const selectDailyChallengeFetchError = (
  state: RootState
): string | null => state.challenges.error
export const selectDailyChallengeUpdateStatus = (
  state: RootState
): ApiStatusType => state.challenges.updateStatus

```
src/features/challenges/types.ts
```typescript
import type { ApiStatusType } from '@lib/api.d'
import type { ReviewItem } from '@features/reviews/types'
import type { LessonData, LessonExercise } from '@features/lessons/types'

export interface ChallengeSectionBase {
  type: string
  title: string
  is_completed?: boolean
}

export interface ChallengeNSRSection extends ChallengeSectionBase {
  type: 'spaced_repetition_review'
  items: Array<{
    item_id: string
    item_type: 'word' | 'grammar' | string
    display_text: string
  }>
}

export interface ChallengeLessonSection extends ChallengeSectionBase {
  type: 'targeted_weakness_practice' | 'lesson_practice'
  lesson_details: LessonData
}

export interface ChallengeContextualPracticeSection
  extends ChallengeSectionBase {
  type: 'contextual_practice'
  exercises: LessonExercise[]
}

export type ChallengeSection =
  | ChallengeNSRSection
  | ChallengeLessonSection
  | ChallengeContextualPracticeSection

export interface DailyChallengeApiResponse {
  user_id: string
  challenge_date: string
  challenge_id: string
  title: string
  sections_json: ChallengeSection[]
  status:
    | 'generated'
    | 'started'
    | 'in_progress'
    | 'completed'
    | 'skipped'
    | string
  message?: string
  estimated_total_time_minutes?: number
  total_reward_points?: number
}

export interface DailyChallenge
  extends Omit<DailyChallengeApiResponse, 'sections_json'> {
  sections: ChallengeSection[]
}

export interface ChallengesState {
  currentDailyChallenge: DailyChallenge | null
  status: ApiStatusType
  error: string | null
  updateStatus: ApiStatusType
  updateError: string | null
}

```
src/features/articles/articlesActionTypes.ts
```typescript
export const FETCH_ARTICLES_REQUEST = "articles/FETCH_LIST_REQUEST";
export const FETCH_ARTICLES_SUCCESS = "articles/FETCH_LIST_SUCCESS";
export const FETCH_ARTICLES_FAILURE = "articles/FETCH_LIST_FAILURE";

// --- Action Types for Adding/Removing from Lists (Optional, can reuse FETCH_SUCCESS with meta) ---
// Let's stick to FETCH_SUCCESS and handle removal logic in the reducer based on meta/options for now.
// If adding/removing involved *separate* API calls resulting in a single item, we'd add types like:
// export const ADD_ARTICLE_SUCCESS = 'articles/ADD_SINGLE_SUCCESS';
// export const REMOVE_ARTICLE_SUCCESS = 'articles/REMOVE_SINGLE_SUCCESS'; // This signals removal *after* API success

// --- Action Types for SINGLE Article Retrieval ---
export const FETCH_SINGLE_ARTICLE_REQUEST = "articles/FETCH_SINGLE_REQUEST";
export const FETCH_SINGLE_ARTICLE_SUCCESS = "articles/FETCH_SINGLE_SUCCESS";
export const FETCH_SINGLE_ARTICLE_FAILURE = "articles/FETCH_SINGLE_FAILURE";

// --- Action Shape Interfaces ---
import { Article } from "./types";

interface FetchArticlesFailurePayload {
  message: string;
  status?: number;
}
interface FetchArticleByIdFailurePayload {
  message: string;
  status?: number;
}

export interface FetchArticlesRequestAction {
  type: typeof FETCH_ARTICLES_REQUEST;
}
export interface FetchArticlesSuccessAction {
  type: typeof FETCH_ARTICLES_SUCCESS;
  payload: Article[];
}
export interface FetchArticlesFailureAction {
  type: typeof FETCH_ARTICLES_FAILURE;
  payload: FetchArticlesFailurePayload;
}

export interface FetchArticleByIdRequestAction {
  type: typeof FETCH_ARTICLE_BY_ID_REQUEST;
}
export interface FetchArticleByIdSuccessAction {
  type: typeof FETCH_ARTICLE_BY_ID_SUCCESS;
  payload: Article;
} // Single article
export interface FetchArticleByIdFailureAction {
  type: typeof FETCH_ARTICLE_BY_ID_FAILURE;
  payload: FetchArticleByIdFailurePayload;
}

export interface ClearArticlesErrorAction {
  type: typeof CLEAR_ARTICLES_ERROR;
}

// Union type
export type ArticlesAction =
  | FetchArticlesRequestAction
  | FetchArticlesSuccessAction
  | FetchArticlesFailureAction
  | FetchArticleByIdRequestAction
  | FetchArticleByIdSuccessAction
  | FetchArticleByIdFailureAction
  | ClearArticlesErrorAction;


```
src/features/articles/articlesActions.ts
```typescript
import { ARTICLE_ARRAY, ARTICLE_SCHEMA_SINGLE } from '@entities/schemas'
import * as actionTypes from './articlesActionTypes'
import { withPaginationList } from '@pagination/actions'
import { createApiRequestThunk } from '@pagination/apiRequestThunkFactory'
import { selectArticlePagination } from './articlesSelectors' // Need selectors
import { ThunkAction } from 'redux-thunk' // Or use RTK types
import { RootState } from '@store/store'

// --- Action Creator for fetching Article LIST ---
export const fetchArticles = (
  paginationKey: string, // Renamed from ownerId for clarity if it's a general key
  options?: {
    reset?: boolean
    fetchNext?: boolean
    fetchPolicy?: FetchPolicy // Add fetchPolicy
    forceRefresh?: boolean // Add forceRefresh
  }
) => {
  // Create the specific API request thunk for articles
  const apiRequestThunk = createApiRequestThunk({
    types: [
      actionTypes.FETCH_ARTICLES_REQUEST,
      actionTypes.FETCH_ARTICLES_SUCCESS,
      actionTypes.FETCH_ARTICLES_FAILURE
    ],
    // Adapt endpoint based on ownerId (e.g., /users/{ownerId}/articles or /articles?ownerId=...)
    endpoint: `/news/articles`, // Adjust as needed
    verb: 'GET',
    schema: ARTICLE_ARRAY, // Use your defined normalizr schema
    transform: [res => res.articles] // Extract data if nested
  })

  // Use the HOC
  return withPaginationList<RootState>({
    apiRequestFunction: apiRequestThunk,
    getStatePaginationData: selectArticlePagination,
    paginationKey: paginationKey, // Use the dynamic key
    pageSize: 10 // Specific page size for articles
  })(options) // Pass options like { reset: true } or { fetchNext: true }
}

// --- Action Creator for fetching a SINGLE Article ---
export const fetchSingleArticle = (
  articleId: string,
  cb?: (err: Error | null, res?: any) => void
): ThunkAction<Promise<any>, RootState, unknown, any> => {
  const apiRequestThunk = createApiRequestThunk({
    types: [
      actionTypes.FETCH_SINGLE_ARTICLE_REQUEST,
      actionTypes.FETCH_SINGLE_ARTICLE_SUCCESS,
      actionTypes.FETCH_SINGLE_ARTICLE_FAILURE
    ],
    endpoint: `/news/articles/${articleId}`,
    verb: 'GET',
    schema: ARTICLE_SCHEMA_SINGLE, // Use your defined normalizr schema
    transform: [res => res],
    cb
  })
  // No pagination HOC needed, just dispatch the API request thunk directly
  // Pass an empty meta object or define specific meta if needed for the single fetch reducer logic
  return apiRequestThunk({
    meta: { entityName: 'articles', itemId: articleId }
  })
}

```
src/features/articles/articlesReducer.ts
```typescript
// src/features/articles/articlesReducer.ts
import { paginate } from "@pagination/reducer";
import * as actionTypes from "./articlesActionTypes";

export const articlePaginationReducer = paginate({
  requestTypes: [actionTypes.FETCH_ARTICLES_REQUEST],
  successTypes: [actionTypes.FETCH_ARTICLES_SUCCESS],
  failureTypes: [actionTypes.FETCH_ARTICLES_FAILURE],
  // Define how to get the key from article list actions
  mapActionToKey: (action) => action.meta?.paginationKey,
  // Specify the field in the normalized response that holds the array of IDs/keys
  resultField: "result",
  // Specify the ID field within the result items if they are objects (used by uniqueObjectsConcatOrder)
  idField: "id", // Assuming your normalized articles have an 'id' field
});

// If you had other article-specific state (e.g., current single article view),
// you could combine reducers here. For now, just exporting the pagination part.
// export default combineReducers({
//    pagination: articlePaginationReducer,
//    // otherArticleState: otherReducer,
// });
// For simplicity with the root reducer structure, we export directly:
export default articlePaginationReducer;


```
src/features/articles/articlesSelectors.ts
```typescript
import { RootState } from "@store/store";

export const selectArticlePagination = (state: RootState) =>
  state.pagination.articlePagination;


```
src/features/articles/types.ts
```typescript
import type { ApiStatusType } from '@lib/api.d'
import type { MediaMetadata } from '@features/media/types'

export type ArticleType = {
  id: string
  title: string
  publication_date: string
  difficulty_score: ArticleDifficulty
  thumbnail?: MediaMetadata
  brand: ArticleBrand
  tags: string[]
  paragraphs: ArticleParagraph[]
}

export interface Article extends ArticleType {}

export type VocabularyType = {
  word: string
  translation: string
  example: string
}

export interface ArticlesState {
  items: ArticleType[]
  status: ApiStatusType
  error: string | null
  lastFetched: number | null
}

export interface ArticleDifficulty {
  Float64: number
  Valid: boolean
}

export interface ArticleBrand {
  source_identifier: string
  display_name: string
  navigation_bg_color_hex?: string
  navigation_text_color_hex?: string
  navigation_active_color_hex?: string
}

export interface ArticleParagraph {
  paragraph_id: string
  paragraph_index: number
  original_text_fi: string
  translation_en: string
  audio_url?: string | null
}

export interface BaseWordDetail {
  base_word_id: string
  word_fi: string
  part_of_speech: string
  primary_translation_en: string
  cefr_level?: string // Optional as not all words might have it
  pronunciation_ipa?: string
  secondary_translations_en?: string[]
  frequency_score?: number | null
  related_lemmas?: {
    antonyms?: string[]
    synonyms?: string[]
  }
}

export interface InflectedFormDetails {
  case?: string | null
  mood?: string | null
  tense?: string | null
  voice?: string | null
  number?: string | null
  person?: string | null
  clitics?: string[]
}

export interface WordOccurrence {
  occurrence_id: string
  base_word_id: string
  grammar_id?: string | null
  occurrence_type: 'word_contextual' | string // "word_contextual" or other types
  original_token_phrase: string
  start_char_offset: number
  end_char_offset: number
  sentence_text_fi: string
  inflected_form_details?: InflectedFormDetails | null
  specific_explanation_en?: string | null
  is_kpt_change_example?: boolean
  base_word_detail: BaseWordDetail
}

export interface GrammarDetail {
  grammar_id: string
  name_fi: string
  name_en: string
  explanation_en: string
  example_fi?: string
  example_translation_en?: string
  category: string
  cefr_level?: string
  example_structures?: string[]
  common_mistakes_en?: string
  related_concepts?: {
    contrasts_with?: string[]
    often_used_with?: string[]
  }
  notes?: string
}

export interface GrammarOccurrence {
  occurrence_id: string
  base_word_id?: string | null
  grammar_id: string
  occurrence_type: 'grammar_contextual' | string
  original_token_phrase: string
  start_char_offset: number
  end_char_offset: number
  sentence_text_fi: string
  sentence_translation_en: string
  specific_explanation_en?: string | null
  grammar_detail: GrammarDetail
}

export interface ArticleParagraph {
  paragraph_id: string
  paragraph_index: number
  original_text_fi: string
  translation_en: string
  audio_url?: string | null
  word_occurrences?: WordOccurrence[]
  grammar_occurrences?: GrammarOccurrence[]
}

```
src/features/reads/readsActions.ts
```typescript
import { createAsyncThunk } from '@reduxjs/toolkit'
import { apiClient } from '@lib/api'
import { AppDispatch } from '@store/store'
import { ApiError } from '@lib/ApiError'
import { ReadArticle, ReadArticleListResponse, MarkReadPayload } from './types'

// Thunk for fetching read articles list
export const fetchReadsThunk = createAsyncThunk<
  ReadArticle[], // Return type
  void, // Argument type
  { dispatch: AppDispatch; rejectValue: string }
>('reads/fetch', async (_, { dispatch, rejectWithValue }) => {
  try {
    // Assuming the API returns { "articles": [...] }
    const response = await apiClient.get<ReadArticleListResponse>(
      '/me/reads',
      dispatch
    )
    return response.articles
  } catch (error: any) {
    let message = 'Failed to fetch read articles. Please try again.'
    if (error instanceof ApiError) {
      message =
        error.data?.detail || error.data?.message || error.message || message
    } else if (error.message) {
      message = error.message
    }
    return rejectWithValue(message)
  }
})

// Thunk for marking an article as read
export const markArticleReadThunk = createAsyncThunk<
  { message: string; article_version_id: string }, // Return type
  MarkReadPayload, // Argument type
  {
    dispatch: AppDispatch
    rejectValue: { message: string; article_version_id: string }
  }
>('reads/markRead', async (payload, { dispatch, rejectWithValue }) => {
  try {
    const response = await apiClient.post<{ message: string }>(
      '/me/reads',
      payload,
      dispatch
    )
    return { ...response, article_version_id: payload.article_version_id }
  } catch (error: any) {
    let message = 'Failed to mark article as read. Please try again.'
    if (error instanceof ApiError) {
      message =
        error.data?.detail || error.data?.message || error.message || message
    } else if (error.message) {
      message = error.message
    }
    return rejectWithValue({
      message,
      article_version_id: payload.article_version_id
    })
  }
})

```
src/features/reads/readsSlice.ts
```typescript
// src/features/reads/readsSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit'
import { ReadsState, ReadArticle } from './types'
import { fetchReadsThunk, markArticleReadThunk } from './readsActions'
import { RootState } from '@/store/store'
import { ApiStatusType } from '@lib/api.d'

const initialState: ReadsState = {
  readArticles: [],
  status: 'idle',
  error: null,
  markReadStatus: {},
  markReadError: {}
}

const readsSlice = createSlice({
  name: 'reads',
  initialState,
  reducers: {
    clearReads(state) {
      // e.g., on logout
      state.readArticles = []
      state.status = 'idle'
      state.error = null
      state.markReadStatus = {}
      state.markReadError = {}
    }
  },
  extraReducers: builder => {
    builder
      // Fetching List
      .addCase(fetchReadsThunk.pending, state => {
        state.status = 'loading'
        state.error = null
      })
      .addCase(
        fetchReadsThunk.fulfilled,
        (state, action: PayloadAction<ReadArticle[]>) => {
          state.status = 'succeeded'
          state.readArticles = action.payload
        }
      )
      .addCase(fetchReadsThunk.rejected, (state, action) => {
        state.status = 'failed'
        state.error = action.payload ?? 'Unknown error'
      })
      // Marking as Read
      .addCase(markArticleReadThunk.pending, (state, action) => {
        const articleId = action.meta.arg.article_version_id
        state.markReadStatus[articleId] = 'loading'
        state.markReadError[articleId] = null
      })
      .addCase(markArticleReadThunk.fulfilled, (state, action) => {
        const articleId = action.payload.article_version_id
        state.markReadStatus[articleId] = 'succeeded'
        // Optional: Add to list immediately if not already there,
        // but usually relying on a refetch of the list is simpler.
        // If optimistic update needed:
        // const exists = state.readArticles.some(a => a.article_version_id === articleId);
        // if (!exists) { state.readArticles.unshift({ article_version_id: articleId, read_at: new Date().toISOString() }); }
      })
      .addCase(markArticleReadThunk.rejected, (state, action) => {
        const articleId = action.meta.arg.article_version_id
        state.markReadStatus[articleId] = 'failed'
        state.markReadError[articleId] =
          action.payload?.message ?? 'Unknown error'
      })
  }
})

export const { clearReads } = readsSlice.actions
export default readsSlice.reducer

// Selectors
export const selectAllReadArticles = (state: RootState): ReadArticle[] =>
  state.reads.readArticles
export const selectReadsListStatus = (state: RootState): ApiStatusType =>
  state.reads.status
export const selectIsArticleRead = (
  state: RootState,
  articleVersionId: string
): boolean => {
  return state.reads.readArticles.some(
    a => a.article_version_id === articleVersionId
  )
}
export const selectMarkReadStatus = (
  state: RootState,
  articleVersionId: string
): ApiStatusType | undefined => state.reads.markReadStatus[articleVersionId]

```
src/features/reads/types.ts
```typescript
import { ApiStatusType } from '@lib/api.d'
import { ArticleBrand } from '@features/articles/types' // Assuming Brand is needed

// Snippet of article details returned by the Reads API
interface ArticleDetailsSnippet {
  id: string // This is the ArticleVersion ID
  title: string
  publication_date: string
  brand?: ArticleBrand | null
  thumbnail?: {
    // Assuming thumbnail info is included
    serve_base_url: string
    variants: { [key: string]: { path: string } } // Simplified variants needed for URL
    media_id: string
  } | null
  // Add other snippet fields if provided (e.g., difficulty)
}

// Structure for a single read entry from the API list
export interface ReadArticle {
  article_version_id: string
  read_at: string // ISO Date string
  article_details?: ArticleDetailsSnippet | null // Populated by the list endpoint
}

// Structure for the reads list API response
export interface ReadArticleListResponse {
  articles: ReadArticle[]
  // Add pagination details if applicable
}

// Structure for POST request payload
export interface MarkReadPayload {
  article_version_id: string
}

// Redux state for this slice
export interface ReadsState {
  readArticles: ReadArticle[] // List of read articles
  status: ApiStatusType
  error: string | null
  // Optional: Track status for marking as read
  markReadStatus: { [articleVersionId: string]: ApiStatusType }
  markReadError: { [articleVersionId: string]: string | null }
}

```
src/features/lessons/lessonsSlice.ts
```typescript
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit'
import { apiClient } from '@lib/api'
import type { AppDispatch, RootState } from '@store/store'
import type {
  LessonsState,
  LessonData,
  KieloSuggestedLessonsApiResponse
} from './types'
import { ApiError } from '@lib/ApiError'
import type { ApiStatusType } from '@lib/api.d'

const POLLING_INTERVAL_MS = 3000
const MAX_POLLING_ATTEMPTS = 30

async function pollForReadyResponse<T>(
  endpoint: string,
  dispatch: AppDispatch
): Promise<T> {
  let attempts = 0
  while (attempts < MAX_POLLING_ATTEMPTS) {
    const { response, body } = await apiClient.getWithResponse<T>(
      endpoint,
      dispatch
    )

    if (response.status === 200) {
      return body
    }

    if (response.status === 202) {
      console.log(
        `[Polling] Received 202 for ${endpoint}. Waiting ${POLLING_INTERVAL_MS}ms. Attempt ${
          attempts + 1
        }/${MAX_POLLING_ATTEMPTS}`
      )
      await new Promise(resolve => setTimeout(resolve, POLLING_INTERVAL_MS))
      attempts++
    } else {
      throw new ApiError(
        `Unexpected status code ${response.status} during polling.`,
        response.status,
        body
      )
    }
  }
  throw new Error('Lesson generation timed out. Please try again in a moment.')
}

const initialState: LessonsState = {
  suggestedLessons: [],
  suggestedLessonsStatus: 'idle',
  suggestedLessonsError: null
}

export const fetchSuggestedLessonsThunk = createAsyncThunk<
  LessonData[],
  { max_suggestions?: number } | void,
  { dispatch: AppDispatch; rejectValue: string }
>('lessons/fetchSuggested', async (args, { dispatch, rejectWithValue }) => {
  try {
    const queryParams = args?.max_suggestions
      ? `?max_suggestions=${args.max_suggestions}`
      : ''
    const endpoint = `/me/lessons/targeted${queryParams}`
    const response =
      await pollForReadyResponse<KieloSuggestedLessonsApiResponse>(
        endpoint,
        dispatch
      )
    return response.suggested_lessons
  } catch (error: any) {
    const message =
      error instanceof ApiError
        ? error.data?.detail || error.message
        : error.message || 'Failed to fetch suggested lessons.'
    return rejectWithValue(message)
  }
})

const lessonsSlice = createSlice({
  name: 'lessons',
  initialState,
  reducers: {
    clearCurrentLesson(state) {
      state.currentLessonData = null
      state.currentLessonStatus = 'idle'
      state.currentLessonError = null
    },
    clearSuggestedLessons(state) {
      state.suggestedLessons = []
      state.suggestedLessonsStatus = 'idle'
      state.suggestedLessonsError = null
    }
  },
  extraReducers: builder => {
    builder
      .addCase(fetchSuggestedLessonsThunk.pending, state => {
        state.suggestedLessonsStatus = 'loading'
        state.suggestedLessonsError = null
      })
      .addCase(
        fetchSuggestedLessonsThunk.fulfilled,
        (state, action: PayloadAction<LessonData[]>) => {
          state.suggestedLessons = action.payload
          state.suggestedLessonsStatus = 'succeeded'
        }
      )
      .addCase(fetchSuggestedLessonsThunk.rejected, (state, action) => {
        state.suggestedLessonsStatus = 'failed'
        state.suggestedLessonsError = action.payload ?? 'Unknown error.'
      })
  }
})

export const { clearCurrentLesson, clearSuggestedLessons } =
  lessonsSlice.actions
export default lessonsSlice.reducer

export const selectSuggestedLessons = (state: RootState): LessonData[] =>
  state.lessons.suggestedLessons
export const selectSuggestedLessonsStatus = (state: RootState): ApiStatusType =>
  state.lessons.suggestedLessonsStatus
export const selectCurrentLessonStatus = (state: RootState): ApiStatusType =>
  state.lessons.currentLessonStatus
export const selectCurrentLessonError = (state: RootState): string | null =>
  state.lessons.currentLessonError

```
src/features/lessons/types.ts
```typescript
import type { ApiStatusType } from '@lib/api.d'

export interface KLearnExerciseOption {
  id: string
  text: string
  is_correct?: boolean
}

export interface KLearnExerciseBase {
  exercise_type: string
  prompt?: string
  item_id_fk: string
  item_type_fk: 'word' | 'grammar' | string
}

export interface KLearnGrammarRuleExplanationExercise
  extends KLearnExerciseBase {
  exercise_type: 'grammar_rule_explanation'
  prompt: string
}

export interface KLearnFillInTheBlankExercise extends KLearnExerciseBase {
  exercise_type: 'fill_in_the_blank'
  prompt: string
  sentence_with_blank: string
  correct_answer: string
  options: string[] | null
  explanation?: string
}

export interface KLearnFlashcardExercise extends KLearnExerciseBase {
  exercise_type: 'flashcard'
  prompt: string
  answer_text: string
}

export interface KLearnMCTranslationExercise extends KLearnExerciseBase {
  exercise_type: 'multiple_choice_translation'
  prompt: string
  source_phrase: string
  source_language?: string
  target_language?: string
  correct_translation: string
  distractor_translations: string[]
  explanation?: string
}

export interface WordScrambleItem {
  text: string
  is_correct_target_word?: boolean
}

export interface KLearnSentenceConstructionExercise extends KLearnExerciseBase {
  exercise_type: 'sentence_construction'
  prompt: string
  scrambled_words: WordScrambleItem[]
  correct_sentence: string
  translation_prompt_en?: string
  explanation?: string
}

export interface KLearnIdentifyTheConceptExercise extends KLearnExerciseBase {
  exercise_type: 'identify_the_concept'
  prompt: string
  sentence_fi: string
  options: KLearnExerciseOption[]
  correct_concept_id: string
  explanation?: string
}

export type LessonExercise =
  | KLearnGrammarRuleExplanationExercise
  | KLearnFillInTheBlankExercise
  | KLearnFlashcardExercise
  | KLearnMCTranslationExercise
  | KLearnSentenceConstructionExercise
  | KLearnIdentifyTheConceptExercise

export interface LessonData {
  lesson_id: string
  user_id: string
  lesson_title: string
  description: string
  exercises: LessonExercise[]
  estimated_duration_minutes: number
  related_concept_id: string
  related_concept_type: string
}

export interface LessonsState {
  suggestedLessons: LessonData[]
  suggestedLessonsStatus: ApiStatusType
  suggestedLessonsError: string | null
}

export interface KieloSuggestedLessonsApiResponse {
  user_id: string
  suggested_lessons: LessonData[]
}

```
src/features/vocabulary/types.ts
```typescript
import { ApiStatusType } from '@lib/api.d'

// Assuming a structure for BaseWord included in the response
interface BaseWordSnippet {
  id: string
  word_fi: string
  // Add other relevant snippet details like part_of_speech, basic_definition_en
}

// Structure for a single vocabulary entry from the API list
export type VocabularyStatus = 'New' | 'Learning' | 'Known' | 'Ignored'

export interface UserVocabularyEntry {
  base_word_id: string
  status: VocabularyStatus
  last_reviewed_at?: string | null // ISO Date string
  created_at: string
  updated_at: string
  base_word?: BaseWordSnippet | null // Populated by the list endpoint
}

// Structure for the vocabulary list API response
export interface VocabularyListResponse {
  vocabulary: UserVocabularyEntry[]
  // Add pagination details if your API supports it
}

// Structure for PUT request payload
export interface UpdateVocabularyPayload {
  base_word_id: string
  status: VocabularyStatus
}

// Redux state for this slice
export interface VocabularyState {
  entries: UserVocabularyEntry[] // The list of vocabulary entries
  status: ApiStatusType
  error: string | null
  // Optional: Track status for individual word updates
  updateStatus: { [baseWordId: string]: Status }
  updateError: { [baseWordId: string]: string | null }
}

```
src/features/vocabulary/vocabularyActions.ts
```typescript
import { createAsyncThunk } from '@reduxjs/toolkit'
import { apiClient } from '@lib/api'
import { AppDispatch } from '@store/store'
import {
  UserVocabularyEntry,
  VocabularyListResponse,
  UpdateVocabularyPayload
} from './types'
import { ApiError } from '@lib/ApiError'

// Thunk for fetching vocabulary list
export const fetchVocabularyThunk = createAsyncThunk<
  UserVocabularyEntry[], // Return type (the array of entries)
  { status?: VocabularyStatus } | void, // Argument (optional status filter)
  { dispatch: AppDispatch; rejectValue: string }
>('vocabulary/fetch', async (args, { dispatch, rejectWithValue }) => {
  try {
    const endpoint = args?.status
      ? `/me/vocabulary?status=${args.status}`
      : '/me/vocabulary'
    // Assuming the API returns { "vocabulary": [...] }
    const response = await apiClient.get<VocabularyListResponse>(
      endpoint,
      dispatch
    )
    return response.vocabulary
  } catch (error: any) {
    let message = 'Failed to fetch vocabulary. Please try again.'
    if (error instanceof ApiError) {
      message =
        error.data?.detail || error.data?.message || error.message || message
    } else if (error.message) {
      message = error.message
    }
    return rejectWithValue(message)
  }
})

// Thunk for updating a word's status
export const updateVocabularyStatusThunk = createAsyncThunk<
  UserVocabularyEntry, // Return the updated entry on success
  UpdateVocabularyPayload, // Argument
  {
    dispatch: AppDispatch
    rejectValue: { message: string; base_word_id: string }
  }
>('vocabulary/updateStatus', async (payload, { dispatch, rejectWithValue }) => {
  try {
    // API returns the updated UserVocabularyEntry
    const updatedEntry = await apiClient.put<UserVocabularyEntry>(
      '/me/vocabulary',
      payload,
      dispatch
    )
    return updatedEntry
  } catch (error: any) {
    let message = 'Failed to update vocabulary status. Please try again.'
    if (error instanceof ApiError) {
      message =
        error.data?.detail || error.data?.message || error.message || message
    } else if (error.message) {
      message = error.message
    }
    return rejectWithValue({ message, base_word_id: payload.base_word_id })
  }
})

```
src/features/vocabulary/vocabularySlice.ts
```typescript
// src/features/vocabulary/vocabularySlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit'
import { VocabularyState, UserVocabularyEntry } from './types'
import {
  fetchVocabularyThunk,
  updateVocabularyStatusThunk
} from './vocabularyActions'
import { ApiStatusType } from '@lib/api.d'
import { RootState } from '@/store/store'

const initialState: VocabularyState = {
  entries: [],
  status: 'idle',
  error: null,
  updateStatus: {},
  updateError: {}
}

const vocabularySlice = createSlice({
  name: 'vocabulary',
  initialState,
  reducers: {
    clearVocabulary(state) {
      // e.g., on logout
      state.entries = []
      state.status = 'idle'
      state.error = null
      state.updateStatus = {}
      state.updateError = {}
    }
  },
  extraReducers: builder => {
    builder
      // Fetching List
      .addCase(fetchVocabularyThunk.pending, state => {
        state.status = 'loading'
        state.error = null
      })
      .addCase(
        fetchVocabularyThunk.fulfilled,
        (state, action: PayloadAction<UserVocabularyEntry[]>) => {
          state.status = 'succeeded'
          state.entries = action.payload
        }
      )
      .addCase(fetchVocabularyThunk.rejected, (state, action) => {
        state.status = 'failed'
        state.error = action.payload ?? 'Unknown error'
      })
      // Updating Status
      .addCase(updateVocabularyStatusThunk.pending, (state, action) => {
        const baseWordId = action.meta.arg.base_word_id
        state.updateStatus[baseWordId] = 'loading'
        state.updateError[baseWordId] = null
      })
      .addCase(
        updateVocabularyStatusThunk.fulfilled,
        (state, action: PayloadAction<UserVocabularyEntry>) => {
          const updatedEntry = action.payload
          state.updateStatus[updatedEntry.base_word_id] = 'succeeded'
          // Update the entry in the list
          const index = state.entries.findIndex(
            e => e.base_word_id === updatedEntry.base_word_id
          )
          if (index !== -1) {
            state.entries[index] = updatedEntry
          } else {
            // Optionally add it if it wasn't in the list (e.g., first time interaction)
            state.entries.push(updatedEntry)
          }
        }
      )
      .addCase(updateVocabularyStatusThunk.rejected, (state, action) => {
        const baseWordId = action.meta.arg.base_word_id
        state.updateStatus[baseWordId] = 'failed'
        state.updateError[baseWordId] =
          action.payload?.message ?? 'Unknown error'
      })
  }
})

export const { clearVocabulary } = vocabularySlice.actions
export default vocabularySlice.reducer

// Selectors
export const selectAllVocabulary = (state: RootState): UserVocabularyEntry[] =>
  state.vocabulary.entries
export const selectVocabularyListStatus = (state: RootState): ApiStatusType =>
  state.vocabulary.status
export const selectVocabularyUpdateStatus = (
  state: RootState,
  baseWordId: string
): StaApiStatusTypetus | undefined => state.vocabulary.updateStatus[baseWordId]
export const selectVocabularyEntry = (
  state: RootState,
  baseWordId: string
): UserVocabularyEntry | undefined => {
  return state.vocabulary.entries.find(e => e.base_word_id === baseWordId)
}

```
src/features/entities/entityActions.ts
```typescript
// src/features/entities/entityActions.ts
import { createAsyncThunk } from '@reduxjs/toolkit'
import { RootState, AppDispatch } from '@store/store'
import { apiClient } from '@lib/api'
import { normalize, Schema } from 'normalizr'
import { FetchPolicy } from '@pagination/types' // Assuming FetchPolicy is defined here or move definition
import { ApiError } from '@lib/ApiError'
import {
  selectEntity,
  selectEntityLastFetchedTimestamp,
  selectEntityLoadingStatus
} from './entitySelectors' // Assuming selectors are in the same feature folder

// Define a reasonable stale threshold (e.g., 5 minutes)
export const DEFAULT_STALE_THRESHOLD_MS = 5 * 60 * 1000

export interface FetchEntityByIdParams {
  entityType: keyof Omit<RootState['entities'], '_meta'> // e.g., 'articles', 'users'
  id: string
  endpoint: string // Full endpoint, e.g., `/news/articles/${id}`
  schema: Schema // Normalizr schema for the single entity
  fetchPolicy?: FetchPolicy
  forceRefresh?: boolean // To explicitly bypass cache checks
  staleThresholdMs?: number // Override default staleness
}

// Thunk return type: Normalized data, or null if cache is hit and no network call made
// The entities part of the payload will be handled by entitiesReducer.
// The result part (the ID) can be useful for some callers.
export const fetchEntityByIdIfNeededThunk = createAsyncThunk<
  { result: string | number; entities: Record<string, any> } | null,
  FetchEntityByIdParams,
  { state: RootState; dispatch: AppDispatch; rejectValue: string }
>(
  'entities/fetchByIdIfNeeded', // This action type prefix is used by entitiesReducer
  async (params, { getState, dispatch, rejectWithValue }) => {
    const {
      entityType,
      id,
      endpoint,
      schema,
      fetchPolicy = 'cache-first',
      forceRefresh = false,
      staleThresholdMs = DEFAULT_STALE_THRESHOLD_MS
    } = params

    const state = getState()
    const existingEntity = selectEntity(state, entityType, id)
    const lastFetchedAt = selectEntityLastFetchedTimestamp(
      state,
      entityType,
      id
    )
    const currentLoadingStatus = selectEntityLoadingStatus(
      state,
      entityType,
      id
    )

    if (currentLoadingStatus === 'pending' && !forceRefresh) {
      console.log(
        `[Cache] Fetch for ${entityType}:${id} already in progress. Skipping.`
      )
      // If we want the caller to await the existing promise, this gets more complex.
      // For now, thunk effectively no-ops if already pending. Hook using this should reflect loading.
      return null
    }

    const isStale =
      !lastFetchedAt || Date.now() - lastFetchedAt > staleThresholdMs

    // Decision to use cache or fetch:
    let shouldFetchNetwork = false

    if (forceRefresh) {
      shouldFetchNetwork = true
    } else {
      switch (fetchPolicy) {
        case 'cache-first':
          if (!existingEntity || isStale) {
            shouldFetchNetwork = true
          } else {
            console.log(
              `[Cache] Fresh entity ${entityType}:${id} found. Policy: ${fetchPolicy}.`
            )
          }
          break
        case 'cache-and-network':
          shouldFetchNetwork = true // Always fetch, UI uses cache first
          if (existingEntity)
            console.log(
              `[Cache] Entity ${entityType}:${id} found, will also fetch network. Policy: ${fetchPolicy}.`
            )
          else
            console.log(
              `[API] Entity ${entityType}:${id} not in cache, fetching. Policy: ${fetchPolicy}.`
            )
          break
        case 'network-only':
          shouldFetchNetwork = true
          break
        case 'cache-only':
          if (!existingEntity) {
            console.warn(
              `[Cache] Entity ${entityType}:${id} not found with cache-only policy.`
            )
            // Optionally reject or return an indicator of cache miss
            return rejectWithValue(
              `Entity ${entityType}:${id} not found in cache (cache-only).`
            )
          }
          if (isStale) {
            console.warn(
              `[Cache] Entity ${entityType}:${id} is stale with cache-only policy.`
            )
            // Decide: return stale data or reject? For now, let hook return stale data.
            // Thunk itself doesn't "return" the cached data, the hook/selector does.
          }
          shouldFetchNetwork = false // Do not fetch from network
          break
        default: // Defaults to cache-first
          if (!existingEntity || isStale) shouldFetchNetwork = true
          break
      }
    }

    if (!shouldFetchNetwork) {
      // If existingEntity is present, it will be used by the component via selector.
      // If not, and policy was cache-only, an error might have been thrown or selector returns undefined.
      return null // Thunk action is complete, no network call made or needed based on policy.
    }

    console.log(
      `[API] Fetching entity ${entityType}:${id}. Endpoint: ${endpoint}. Stale: ${isStale}, Force: ${forceRefresh}, Policy: ${fetchPolicy}`
    )
    try {
      const rawData = await apiClient.get<any>(endpoint, dispatch)

      if (!rawData && rawData !== null) {
        // API returned undefined, or empty response where data was expected
        console.warn(
          `[API] No data returned for ${entityType}:${id} from ${endpoint}.`
        )
        // This might mean the entity was deleted on the backend.
        // Dispatch an action to remove it from the local cache if desired.
        // For now, the fulfilled action will have empty entities for this ID.
        // entitiesReducer could interpret this as a signal to remove if payload is { result: id, entities: { [entityType]: { [id]: undefined } } }
        return { result: id, entities: { [entityType]: { [id]: undefined } } } // Signal no data / potential removal
      }
      if (rawData === null && schema) {
        // API explicitly returned null (e.g. resource not found, but not an error status)
        console.log(
          `[API] Null data returned for ${entityType}:${id} from ${endpoint}. Entity may not exist.`
        )
        return { result: id, entities: { [entityType]: { [id]: null } } } // Signal explicit null
      }

      // Ensure dataToNormalize is the actual entity object, not an array or nested structure,
      // as this thunk is for fetching a SINGLE entity by ID.
      // The rawData from apiClient.get should be the direct object.
      const dataToNormalize = rawData

      const normalized = normalize(
        dataToNormalize
          ? { ...dataToNormalize, _lastFetchedAt: Date.now() }
          : null, // Add timestamp only if data exists
        schema
      )

      // Ensure entities object is not undefined even if normalization result is minimal
      const entities = normalized.entities || { [entityType]: {} }
      if (!entities[entityType] && dataToNormalize) {
        // If schema didn't produce this type but data existed
        entities[entityType] = {} // Ensure the entity type key exists
      }
      if (dataToNormalize === null && !entities[entityType]?.[id]) {
        // If API returned null, ensure the entity is set to null in the entities map
        if (!entities[entityType]) entities[entityType] = {}
        entities[entityType][id] = null
      }

      return { result: normalized.result as string | number, entities }
    } catch (error: any) {
      let message = `Failed to fetch ${entityType}:${id}.`
      if (error instanceof ApiError) {
        message =
          error.data?.detail || error.data?.message || error.message || message
      } else if (error.message) {
        message = error.message
      }
      console.error(`[API] Error fetching ${entityType}:${id}:`, message, error)
      return rejectWithValue(message)
    }
  }
  // Removed the 'condition' option for multiple inflight requests here.
  // The 'loadingById' status check at the beginning of the thunk serves a similar purpose.
  // For more advanced inflight request management, a dedicated system or RTK Query is better.
)

// You would also update your entitiesReducer to use these actual action types:
// fetchEntityByIdIfNeededThunk.pending.type
// fetchEntityByIdIfNeededThunk.fulfilled.type
// fetchEntityByIdIfNeededThunk.rejected.type

```
src/features/entities/entitySelectors.ts
```typescript
// src/features/entities/entitySelectors.ts (or wherever you keep them)
import { RootState } from '@store/store'
import { User } from '@features/auth/types' // Example type
import { Article } from '@features/articles/types' // Example type

// Generic selector for any entity type
export const selectEntity = <T extends { _lastFetchedAt?: number }>(
  state: RootState,
  entityType: keyof Omit<RootState['entities'], '_meta'>, // Exclude _meta from entityType choices
  id: string | undefined | null
): T | undefined => {
  if (!id || !state.entities[entityType]) {
    return undefined
  }
  return state.entities[entityType][id] as T | undefined
}

// Example specific selectors (can be built with createSelector for memoization)
export const selectUserById = (
  state: RootState,
  userId: string | undefined | null
): User | undefined => selectEntity<User>(state, 'users', userId)

export const selectArticleById = (
  state: RootState,
  articleId: string | undefined | null
): Article | undefined => selectEntity<Article>(state, 'articles', articleId)

// Meta Selectors
export const selectEntityMeta = (
  state: RootState,
  entityType: keyof RootState['entities']['_meta']
) => state.entities._meta[entityType]

export const selectEntityLoadingStatus = (
  state: RootState,
  entityType: keyof RootState['entities']['_meta'],
  id: string | undefined | null
): 'idle' | 'pending' | 'succeeded' | 'failed' => {
  if (!id) return 'idle'
  return state.entities._meta[entityType]?.loadingById[id] || 'idle'
}

export const selectEntityError = (
  state: RootState,
  entityType: keyof RootState['entities']['_meta'],
  id: string | undefined | null
): string | null => {
  if (!id) return null
  return state.entities._meta[entityType]?.errorById[id] || null
}

export const selectEntityLastFetchedTimestamp = (
  state: RootState,
  entityType: keyof RootState['entities']['_meta'],
  id: string | undefined | null
): number | null => {
  if (!id) return null
  return state.entities._meta[entityType]?.lastFetchedById[id] || null
}

export const selectEntityTypeLastFetchedListTimestamp = (
  state: RootState,
  entityType: keyof RootState['entities']['_meta']
): number | null => {
  return state.entities._meta[entityType]?.lastFetchedListAt || null
}

```
src/features/reviews/reviewsSlice.ts
```typescript
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit'
import { apiClient } from '@lib/api'
import type { AppDispatch, RootState } from '@store/store'
import type {
  ReviewsState,
  ReviewItem,
  ReviewOutcomePayload,
  FetchReviewsApiResponse
} from './types'
import { ApiError } from '@lib/ApiError'

const initialState: ReviewsState = {
  items: [],
  status: 'idle',
  error: null,
  nextBatchAvailableAt: null,
  currentItemIndex: -1
}

export const fetchReviewsThunk = createAsyncThunk<
  FetchReviewsApiResponse,
  { limit?: number } | void,
  { dispatch: AppDispatch; rejectValue: string }
>('reviews/fetchReviews', async (args, { dispatch, rejectWithValue }) => {
  try {
    const queryParams = args?.limit ? `?limit=${args.limit}` : ''
    const response = await apiClient.get<FetchReviewsApiResponse>(
      `/me/reviews${queryParams}`,
      dispatch
    )
    return response
  } catch (error: any) {
    let message = 'Failed to fetch review items.'
    if (error instanceof ApiError) {
      message =
        error.data?.detail || error.data?.message || error.message || message
    } else if (error.message) {
      message = error.message
    }
    return rejectWithValue(message)
  }
})

export const reportReviewOutcomeThunk = createAsyncThunk<
  { itemId: string; itemType: string },
  { item: ReviewItem; outcome: ReviewOutcomePayload },
  { dispatch: AppDispatch; rejectValue: { message: string; itemId: string } }
>(
  'reviews/reportOutcome',
  async ({ item, outcome }, { dispatch, rejectWithValue }) => {
    const { item_id: itemId, item_type: itemType } = item
    let endpoint = ''

    if (itemType === 'word') {
      endpoint = `/me/vocabulary/${itemId}/review-outcome`
    } else if (itemType === 'grammar') {
      endpoint = `/me/grammar-concepts/${itemId}/review-outcome`
    } else {
      return rejectWithValue({
        message: `Unsupported item type: ${itemType}`,
        itemId
      })
    }

    try {
      await apiClient.put<void>(endpoint, outcome, dispatch)
      return { itemId, itemType }
    } catch (error: any) {
      let message = 'Failed to report review outcome.'
      if (error instanceof ApiError) {
        message =
          error.data?.detail || error.data?.message || error.message || message
      } else if (error.message) {
        message = error.message
      }
      return rejectWithValue({ message, itemId })
    }
  }
)

const reviewsSlice = createSlice({
  name: 'reviews',
  initialState,
  reducers: {
    startReviewSession(state) {
      if (state.items.length > 0) {
        state.currentItemIndex = 0
      } else {
        state.currentItemIndex = -1
      }
      state.status = state.items.length > 0 ? 'succeeded' : 'idle'
    },
    advanceReviewItem(state) {
      if (state.currentItemIndex < state.items.length - 1) {
        state.currentItemIndex += 1
      } else {
        state.currentItemIndex = -1
      }
    },
    clearReviews(state) {
      state.items = []
      state.status = 'idle'
      state.error = null
      state.nextBatchAvailableAt = null
      state.currentItemIndex = -1
    }
  },
  extraReducers: builder => {
    builder
      .addCase(fetchReviewsThunk.pending, state => {
        state.status = 'loading'
        state.error = null
      })
      .addCase(
        fetchReviewsThunk.fulfilled,
        (state, action: PayloadAction<FetchReviewsApiResponse>) => {
          state.items = action.payload.items_to_review
          state.nextBatchAvailableAt = action.payload.next_batch_available_at
          state.status = 'succeeded'
          state.error = null
          if (state.items.length > 0) {
            state.currentItemIndex = 0
          } else {
            state.currentItemIndex = -1
          }
        }
      )
      .addCase(fetchReviewsThunk.rejected, (state, action) => {
        state.status = 'failed'
        state.error = action.payload ?? 'Unknown error fetching reviews.'
        state.items = []
        state.currentItemIndex = -1
      })
      .addCase(reportReviewOutcomeThunk.pending, (state, action) => {})
      .addCase(reportReviewOutcomeThunk.fulfilled, (state, action) => {})
      .addCase(reportReviewOutcomeThunk.rejected, (state, action) => {})
  }
})

export const { startReviewSession, advanceReviewItem, clearReviews } =
  reviewsSlice.actions
export default reviewsSlice.reducer

export const selectAllReviewItems = (state: RootState): ReviewItem[] =>
  state.reviews.items
export const selectCurrentReviewItem = (
  state: RootState
): ReviewItem | undefined => {
  if (
    state.reviews.currentItemIndex >= 0 &&
    state.reviews.items.length > state.reviews.currentItemIndex
  ) {
    return state.reviews.items[state.reviews.currentItemIndex]
  }
  return undefined
}
export const selectReviewStatus = (state: RootState): ApiStatusType =>
  state.reviews.status
export const selectReviewError = (state: RootState): string | null =>
  state.reviews.error
export const selectNextBatchAvailableAt = (state: RootState): string | null =>
  state.reviews.nextBatchAvailableAt
export const selectCurrentReviewItemIndex = (state: RootState): number =>
  state.reviews.currentItemIndex
export const selectTotalReviewItemsCount = (state: RootState): number =>
  state.reviews.items.length
export const selectIsReviewSessionActive = (state: RootState): boolean =>
  state.reviews.currentItemIndex !== -1 && state.reviews.items.length > 0

```
src/features/reviews/types.ts
```typescript
import type { ApiStatusType } from '@lib/api.d'

export interface ExampleSentencePair {
  sentence_fi: string
  translation_en?: string
}

export interface ReviewItemExerciseSnippet {
  exercise_type: 'mcq' | 'fill_blank' | string
  prompt: string
  options?: string[]
  correct_answer: string
}

export interface ReviewItem {
  item_id: string
  item_type: 'word' | 'grammar' | string
  display_text: string
  review_reason?: string | null

  primary_translation_en?: string | null
  part_of_speech?: string | null
  pronunciation_ipa?: string | null
  cefr_level?: string | null
  word_user_status?: string | null
  secondary_translations_en?: any
  related_lemmas?: any
  word_notes?: string | null
  word_examples?: ExampleSentencePair[] | null

  grammar_name_fi?: string | null
  grammar_category?: string | null
  grammar_explanation_en?: string | null
  grammar_user_status?: string | null
  example_structures?: any
  common_mistakes_en?: string | null
  related_concepts?: any
  grammar_notes?: string | null
  grammar_examples?: ExampleSentencePair[] | null

  exercise_snippet?: ReviewItemExerciseSnippet | null
}

export interface ReviewsState {
  items: ReviewItem[]
  status: ApiStatusType
  error: string | null
  nextBatchAvailableAt: string | null
  currentItemIndex: number
}

export interface ReviewOutcomePayload {
  interaction_success: boolean
  review_timestamp_client: string
  response_time_ms?: number
  review_interaction_type: string
  difficulty_assessment?: 'easy' | 'medium' | 'hard'
}

export interface FetchReviewsApiResponse {
  user_id: string
  items_to_review: ReviewItem[]
  next_batch_available_at: string | null
}

```
src/features/media/mediaSlice.ts
```typescript
// src/features/media/mediaSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit'
import { MediaState, MediaMetadata } from './types'
import { apiClient } from '@lib/api' // Your API client
import { AppDispatch, RootState } from '@store/store' // Your store types
import { ApiStatusType } from '@/lib/api.d'

const initialState: MediaState = {
  metadataById: {},
  statusById: {},
  errorById: {}
}

// Thunk to fetch media metadata if not already cached or loading/failed recently
export const fetchMediaMetadataThunk = createAsyncThunk<
  MediaMetadata, // Return type
  string, // Argument type: mediaId
  { dispatch: AppDispatch; state: RootState; rejectValue: string } // ThunkAPI config
>(
  'media/fetchMetadata',
  async (mediaId, { getState, dispatch, rejectWithValue }) => {
    const { media } = getState() // Get current media state
    const existingStatus = media.statusById[mediaId]

    // Don't refetch if already loading or succeeded recently
    // Add timestamp check later if needed for cache invalidation
    if (existingStatus === 'loading' || existingStatus === 'succeeded') {
      // If succeeded, return existing data directly to avoid dispatching fulfilled again
      if (existingStatus === 'succeeded' && media.metadataById[mediaId]) {
        // This won't actually dispatch fulfilled, but prevents API call
        // Consider just returning null or a specific status if no API call is made
        return media.metadataById[mediaId] as MediaMetadata // Return cached data
      }
      // If loading, let the existing request complete.
      // Throwing an error here might be too aggressive, maybe return a specific signal?
      // For simplicity, we let it proceed but it won't make a network call if caught by shouldFetch
      // console.log(`Fetch skipped for ${mediaId}, status: ${existingStatus}`);
      // return rejectWithValue('Fetch skipped, already loading/succeeded'); // Option
    }

    try {
      const metadata = await apiClient.get<MediaMetadata>(
        `/media/${mediaId}`, // Your metadata endpoint
        dispatch // Pass dispatch if your apiClient needs it
      )
      return metadata
    } catch (error: any) {
      const message =
        error?.data?.error || error?.message || 'Failed to fetch media metadata'
      console.error(`Error fetching metadata for ${mediaId}:`, error)
      return rejectWithValue(message)
    }
  }
  //   { // Optional: Prevent fetching if already loading/succeeded
  //     condition: (mediaId, { getState }) => {
  //       const { media } = getState() as RootState;
  //       const status = media.statusById[mediaId];
  //       if (status === 'loading' || status === 'succeeded') {
  //         console.log(`Fetch condition failed for ${mediaId}, status: ${status}`);
  //         return false; // Don't fetch
  //       }
  //       return true;
  //     },
  //   }
)

const mediaSlice = createSlice({
  name: 'media',
  initialState,
  reducers: {
    clearMediaCache(state) {
      state.metadataById = {}
      state.statusById = {}
      state.errorById = {}
    }
    // Add other reducers if needed
  },
  extraReducers: builder => {
    builder
      .addCase(fetchMediaMetadataThunk.pending, (state, action) => {
        const mediaId = action.meta.arg
        state.statusById[mediaId] = 'loading'
        state.errorById[mediaId] = null // Clear previous error
      })
      .addCase(
        fetchMediaMetadataThunk.fulfilled,
        (state, action: PayloadAction<MediaMetadata>) => {
          const mediaId = action.payload.media_id
          state.statusById[mediaId] = 'succeeded'
          state.metadataById[mediaId] = action.payload
          state.errorById[mediaId] = null
        }
      )
      .addCase(fetchMediaMetadataThunk.rejected, (state, action) => {
        const mediaId = action.meta.arg
        state.statusById[mediaId] = 'failed'
        state.metadataById[mediaId] = undefined // Clear potentially stale data
        state.errorById[mediaId] = action.payload ?? 'Unknown error'
      })
  }
})

export const { clearMediaCache } = mediaSlice.actions
export default mediaSlice.reducer

// --- Selectors ---
export const selectMediaMetadata = (
  state: RootState,
  mediaId: string
): MediaMetadata | undefined => state.media.metadataById[mediaId]
export const selectMediaStatus = (
  state: RootState,
  mediaId: string
): ApiStatusType | undefined => state.media.statusById[mediaId]
export const selectMediaError = (
  state: RootState,
  mediaId: string
): string | null | undefined => state.media.errorById[mediaId]

```
src/features/media/types.ts
```typescript
// src/features/media/types.ts
// src/features/media/types.ts
import { ApiStatusType } from '@lib/api.d'

export interface MediaVariant {
  path: string
  mime_type: string
  width?: number // Optional, for image/video
  height?: number // Optional, for image/video
  size: number // File size in bytes
  duration?: number // Optional, float, in seconds, for video/audio/gif-video
  bitrate?: string // Optional, e.g., '192k', for video/audio
  codec?: string // Optional, e.g., 'webp', 'av1', 'aac'
}

// Corresponds to the 'metadata' object in the API response (ProcessingMetadata)
export interface MediaProcessingMetadata {
  original_width?: number
  original_height?: number
  original_duration?: number // float, in seconds
  original_format?: string // e.g., 'jpeg', 'mp4', 'gif'
  original_codec?: string // e.g., 'h264', 'aac', 'gif'
  original_audio_codec?: string // e.g., 'aac'
  lqip_data_uri?: string | null // Base64 WebP Data URI
  [key: string]: any // Allow other metadata fields
}

export interface MediaMetadata {
  media_id: string
  media_type: 'Image' | 'Video' | 'Audio' | 'GIF' | 'SVG' | 'Document' // Added GIF, SVG
  processing_status: 'Queued' | 'Processing' | 'Completed' | 'Failed'
  processing_error?: string | null // Added from spec
  metadata?: MediaProcessingMetadata | null
  serve_base_url: string // Base URL like https://media.kielo.app/processed/{media_id}/
  variants: {
    [key: string]: MediaVariant // e.g., "thumb_webp", "main_av1", "original"
  }
  created_at: string
  updated_at: string
}

export interface MediaState {
  metadataById: { [mediaId: string]: MediaMetadata | undefined }
  statusById: { [mediaId: string]: ApiStatusType }
  errorById: { [mediaId: string]: string | null }
}

```
src/utils/assert.js
```javascript
/**
 * Asserts that the given condition is truthy. Useful in cases
 * where you want to narrow the type of a variable to a non-nullable.
 *
 * @example
 * const foo = getFoo()
 *  // foo is TypeOfFoo | undefined
 * assert(foo)
 *  // foo is TypeOfFoo
 *
 * @template T
 *
 * @param {T | null | undefined} condition
 * @param {string} [message]
 *
 * @returns {asserts condition}
 */
export function assertInvariant(condition = null, message = "") {
  if (condition === null || condition === undefined) {
    throw new Error(message || "Invariant assertion failed");
  }
}

```
src/utils/layoutUtils.ts
```typescript
// src/utils/layoutUtils.ts (New File)
import { findNodeHandle, UIManager, View } from 'react-native'
import React from 'react'

export interface LayoutMeasurement {
  x: number
  y: number
  width: number
  height: number
  pageX: number // Screen X
  pageY: number // Screen Y
}

export const measureNode = (
  ref: React.RefObject<View | Text>
): Promise<LayoutMeasurement> => {
  return new Promise(resolve => {
    if (ref.current) {
      const nodeHandle = findNodeHandle(ref.current)
      if (nodeHandle) {
        UIManager.measure(nodeHandle, (x, y, width, height, pageX, pageY) => {
          resolve({ x, y, width, height, pageX, pageY })
        })
      } else {
        resolve({ x: 0, y: 0, width: 0, height: 0, pageX: 0, pageY: 0 }) // Fallback
      }
    } else {
      resolve({ x: 0, y: 0, width: 0, height: 0, pageX: 0, pageY: 0 }) // Fallback
    }
  })
}

```
src/utils/string.js
```javascript
/**
 * Truncates and formats a display name.
 *
 * @param {string} fullName  the raw name (e.g. userState?.displayName)
 * @param {object} [options]
 * @param {number} [options.maxLen=12]  maximum allowed characters before truncation
 * @param {string} [options.ellipsis='']  character(s) to append on truncation
 * @returns {string}  formatted name
 */
export function nameParser(fullName, options = {}) {
  const { maxLen = 10, ellipsis = '' } = options
  if (typeof fullName !== 'string') return ''

  // Clean up whitespace
  const parts = fullName.trim().split(/\s+/).filter(Boolean)

  let result = ''

  for (let i = 0; i < parts.length; i++) {
    const word = parts[i]
    const candidate = result ? `${result} ${word}` : word

    // First word too long: slice it and append ellipsis
    if (i === 0 && word.length > maxLen) {
      const sliced = word.slice(0, maxLen)
      result = sliced + ellipsis
      break
    }

    // Adding next word would exceed maxLen? truncate now
    if (candidate.length > maxLen) {
      result = result + ellipsis
      break
    }

    // Otherwise, accept this word
    result = candidate
  }

  // Capitalize first character (if there is one)
  if (result) {
    result = result.charAt(0).toUpperCase() + result.slice(1)
  }

  return result
}

```
src/utils/textUtils.ts
```typescript
export const robustWordTokenizer = (
  text: string
): { word: string; spaceAfter: string }[] => {
  if (!text) return []
  const results: { word: string; spaceAfter: string }[] = []

  try {
    // First try to identify URLs and email addresses to preserve them
    const urlEmailRegex =
      /((?:https?:\/\/)?(?:www\.)?[\p{L}\p{N}][\p{L}\p{N}_\-]*(?:\.[\p{L}\p{N}][\p{L}\p{N}_\-]*)+(?:\/[^\s]*)?|[\p{L}\p{N}][\p{L}\p{N}._\-]*@[\p{L}\p{N}][\p{L}\p{N}_\-]*(?:\.[\p{L}\p{N}][\p{L}\p{N}_\-]*)+)(\s*)|([^\s]+)(\s*)/gu

    let match
    let lastIndex = 0
    let textToProcess = text

    // First pass: extract URLs and emails
    while ((match = urlEmailRegex.exec(text)) !== null) {
      if (match[1]) {
        // This is a URL or email
        results.push({ word: match[1], spaceAfter: match[2] || '' })
        const matchedLength = match[0].length
        const startPos = match.index
        const endPos = startPos + matchedLength
        lastIndex = endPos
      } else if (match[3]) {
        // This is other text
        // Process remaining text with our regular tokenizer
        const fragment = match[3]
        const spaces = match[4] || ''

        // Process normal words with trailing punctuation
        const wordRegex =
          /([\p{L}\p{N}\p{M}'-]+[,.'\-"]*|[^\s\p{L}\p{N}\p{M}]+)/gu
        let wordMatch
        let subResults: { word: string; spaceAfter: string }[] = []

        while ((wordMatch = wordRegex.exec(fragment)) !== null) {
          if (wordMatch[0]) {
            subResults.push({ word: wordMatch[0], spaceAfter: '' })
          }
        }

        // Add the last space to the last subresult if there are any
        if (subResults.length > 0) {
          subResults[subResults.length - 1].spaceAfter = spaces
          results.push(...subResults)
        } else {
          // Just in case something went wrong with regex
          results.push({ word: fragment, spaceAfter: spaces })
        }
      }
    }

    // If no URL/email matches were found, process the whole text with the standard tokenizer
    if (results.length === 0) {
      const wordRegex =
        /([\p{L}\p{N}\p{M}'-]+[,.'\-"]*|[^\s\p{L}\p{N}\p{M}]+)(\s*)/gu
      while ((match = wordRegex.exec(text)) !== null) {
        if (match[1]) {
          results.push({ word: match[1], spaceAfter: match[2] || '' })
        } else if (match[2]) {
          results.push({ word: '', spaceAfter: match[2] })
        }
      }
    }
  } catch (e) {
    // Fallback if Unicode properties are not supported (older JS engines, though unlikely in modern RN)
    console.warn(
      'Unicode property escapes for regex not fully supported. Falling back to simpler tokenizer.',
      e
    )

    // Modified fallback pattern to better handle URLs and trailing punctuation
    const finnishWordChars = "A-Za-z0-9_'-"
    const fallbackRegex = new RegExp(
      `((?:https?:\\/\\/)?(?:www\\.)?[${finnishWordChars}][${finnishWordChars}]*(?:\\.[${finnishWordChars}][${finnishWordChars}]*)+(?:\\/[^\\s]*)?|[${finnishWordChars}]+[,.'\-"]*|[^\\s${finnishWordChars}]+)(\\s*)`,
      'gu'
    )

    let match
    while ((match = fallbackRegex.exec(text)) !== null) {
      if (match[1]) {
        results.push({ word: match[1], spaceAfter: match[2] || '' })
      } else if (match[2]) {
        results.push({ word: '', spaceAfter: match[2] })
      }
    }
  }

  // If regex produced no results but text exists (e.g., all symbols not caught by patterns)
  if (results.length === 0 && text.length > 0) {
    return [{ word: text, spaceAfter: '' }] // Treat as a single block
  }

  return results
}

```
src/utils/url.js
```javascript
/**
 * Converts the given query params object to string.
 * Empty ('', null, undefined, []) values are ignored.
 *
 * @param {Record<string | number, unknown>} params
 *
 * @example
 * makeQueryString({
 *   a: "hello",
 *   b: "",
 *   c: null,
 *   d: [1,2],
 *   e: []
 * })
 * // returns "?a=hello&d=1&d=2"
 */
export function makeQueryString(params) {
  if (
    params === null ||
    !Object.values(params).filter((p) => Boolean(p)).length
  ) {
    return "";
  }

  const isEmptyArray = (value) =>
    Array.isArray(value) ? value.length === 0 : false;
  const isNonEmpty = (value) =>
    value !== null && value !== undefined && value !== "";

  const encodeParam = (name, value) =>
    `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;
  const encodeArray = (name, array) =>
    array
      .filter(isNonEmpty)
      .map((item) => (typeof item === "object" ? JSON.stringify(item) : item))
      .map((item) => encodeParam(name, item))
      .join("&");

  const parts = Object.entries(params)
    .filter(([_, value]) => isNonEmpty(value) && !isEmptyArray(value))
    .map(([name, value]) =>
      Array.isArray(value) ? encodeArray(name, value) : encodeParam(name, value)
    );

  return `?${parts.join("&")}`;
}

```
src/components/Collapsible.tsx
```
import { PropsWithChildren, useState } from "react";
import { StyleSheet, TouchableOpacity } from "react-native";

import { ThemedText } from "@components/ThemedText";
import { ThemedView } from "@components/ThemedView";
import { IconSymbol } from "@components/ui/IconSymbol";
import { Colors } from "@constants/Colors";
import { useColorScheme } from "@hooks/useColorScheme";

export function Collapsible({
  children,
  title,
}: PropsWithChildren & { title: string }) {
  const [isOpen, setIsOpen] = useState(false);
  const theme = useColorScheme() ?? "light";

  return (
    <ThemedView>
      <TouchableOpacity
        style={styles.heading}
        onPress={() => setIsOpen((value) => !value)}
        activeOpacity={0.8}
      >
        <IconSymbol
          name="chevron.right"
          size={18}
          weight="medium"
          color={theme === "light" ? Colors.light.icon : Colors.dark.icon}
          style={{ transform: [{ rotate: isOpen ? "90deg" : "0deg" }] }}
        />

        <ThemedText type="defaultSemiBold">{title}</ThemedText>
      </TouchableOpacity>
      {isOpen && <ThemedView style={styles.content}>{children}</ThemedView>}
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  heading: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  content: {
    marginTop: 6,
    marginLeft: 24,
  },
});


```
src/components/ExternalLink.tsx
```
import { Link } from 'expo-router';
import { openBrowserAsync } from 'expo-web-browser';
import { type ComponentProps } from 'react';
import { Platform } from 'react-native';

type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href}
      onPress={async (event) => {
        if (Platform.OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href);
        }
      }}
    />
  );
}

```
src/components/HapticTab.tsx
```
import { BottomTabBarButtonProps } from '@react-navigation/bottom-tabs';
import { PlatformPressable } from '@react-navigation/elements';
import * as Haptics from 'expo-haptics';

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    <PlatformPressable
      {...props}
      onPressIn={(ev) => {
        if (process.env.EXPO_OS === 'ios') {
          // Add a soft haptic feedback when pressing down on the tabs.
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    />
  );
}

```
src/components/HelloWave.tsx
```
import { useEffect } from "react";
import { StyleSheet } from "react-native";
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withRepeat,
  withSequence,
} from "react-native-reanimated";

import { ThemedText } from "@components/ThemedText";

export function HelloWave() {
  const rotationAnimation = useSharedValue(0);

  useEffect(() => {
    rotationAnimation.value = withRepeat(
      withSequence(
        withTiming(25, { duration: 150 }),
        withTiming(0, { duration: 150 })
      ),
      4 // Run the animation 4 times
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotationAnimation.value}deg` }],
  }));

  return (
    <Animated.View style={animatedStyle}>
      <ThemedText style={styles.text}></ThemedText>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  text: {
    fontSize: 28,
    lineHeight: 32,
    marginTop: -6,
  },
});


```
src/components/MediaRenderer.tsx
```
// src/components/MediaRenderer.tsx
// src/components/MediaRenderer.tsx
import React, { useEffect, useMemo, useState } from 'react'
import {
  View,
  Text,
  StyleSheet,
  ActivityIndicator,
  Dimensions,
  TouchableOpacity
} from 'react-native'
import { useDispatch, useSelector } from 'react-redux'
import { Image as ExpoImage, ImageStyle } from 'expo-image'
import { useVideoPlayer, VideoView, VideoSource } from 'expo-video'
import { useEvent } from 'expo'
import { useAudioPlayer, useAudioPlayerStatus } from 'expo-audio'
import Slider from '@react-native-community/slider'
import { BlurView } from 'expo-blur'
import {
  Play,
  Pause,
  AlertCircle,
  Loader2,
  FileQuestion,
  ImageOff // For SVG fallback or general image error
} from 'lucide-react-native'

import { AppDispatch, RootState } from '@store/store'
import {
  fetchMediaMetadataThunk,
  selectMediaMetadata,
  selectMediaStatus,
  selectMediaError
} from '@features/media/mediaSlice'
import { MediaMetadata } from '@features/media/types'
import { SkeletonBlock } from './skeletons/SkeletonElements'
import { Colors } from '@constants/Colors'
import {
  getBestImageUrl,
  getBestVideoUrl,
  getBestAudioUrl,
  getGifAsVideoUrl,
  getSvgUrl,
  getStaticPreviewUrl,
  getOriginalFileUrl
} from '@lib/mediaUtils' // Import new utils

interface MediaRendererProps {
  mediaId: string
  initialMimeType: string // Retain for initial AR estimate for non-image types, less critical now
}

const SCREEN_HEIGHT = Dimensions.get('window').height
const DEFAULT_AR = 4 / 3
const VIDEO_AR = 16 / 9
const TIMESTAMP_WIDTH = 50

type TimeFormatter = (sec: number) => string
const formatTime: TimeFormatter = sec => {
  const m = Math.floor(sec / 60)
  const s = Math.floor(sec % 60)
  return `${m}:${s < 10 ? '0' + s : s}`
}

export const MediaRenderer: React.FC<MediaRendererProps> = React.memo(
  ({ mediaId, initialMimeType }) => {
    const dispatch = useDispatch<AppDispatch>()
    const meta = useSelector((s: RootState) => selectMediaMetadata(s, mediaId))
    const status = useSelector((s: RootState) => selectMediaStatus(s, mediaId))
    const err = useSelector((s: RootState) => selectMediaError(s, mediaId))

    const [videoSliding, setVideoSliding] = useState(false)
    const [videoSlideValue, setVideoSlideValue] = useState(0)
    const [audioSliding, setAudioSliding] = useState(false)
    const [audioSlideValue, setAudioSlideValue] = useState(0)

    useEffect(() => {
      if (!meta && (!status || status === 'idle' || status === 'failed')) {
        // Fetch if no meta and not already successfully fetched or currently loading
        dispatch(fetchMediaMetadataThunk(mediaId))
      }
    }, [dispatch, mediaId, status, meta])

    const ar = useMemo(() => {
      if (meta?.media_type === 'Audio') return null
      if (meta?.metadata?.original_width && meta.metadata.original_height) {
        return meta.metadata.original_width / meta.metadata.original_height
      }
      if (meta?.media_type === 'Video' || meta?.media_type === 'GIF')
        return VIDEO_AR
      return DEFAULT_AR // For Image, SVG preview
    }, [meta])

    // Video player setup (used for Video and GIF)
    const videoUrl =
      meta?.media_type === 'Video'
        ? getBestVideoUrl(meta)
        : meta?.media_type === 'GIF'
        ? getGifAsVideoUrl(meta)
        : null
    const videoSource: VideoSource | null = videoUrl ? videoUrl : null
    const videoPlayer = useVideoPlayer(videoSource)
    const { status: vStat, error: vErr } = useEvent(
      videoPlayer,
      'statusChange',
      {
        status: videoPlayer?.status,
        error: videoPlayer?.error
      }
    )

    // Audio player setup
    const audioUrl = getBestAudioUrl(meta)
    const audioSource: string | null = audioUrl ? audioUrl : null
    const audioPlayer = useAudioPlayer(audioSource)
    const aStat = useAudioPlayerStatus(audioPlayer)

    const baseStyle: ImageStyle = { width: '100%', height: '100%' }
    const contStyle = [
      styles.container,
      ar && { aspectRatio: ar },
      ar && { maxHeight: SCREEN_HEIGHT * 0.8 }
    ]

    const renderLoading = () => {
      const lqip = meta?.metadata?.lqip_data_uri
      return (
        <View style={contStyle}>
          {lqip && ar ? (
            <>
              <ExpoImage
                source={{ uri: lqip }}
                style={StyleSheet.absoluteFill}
                contentFit="cover" // LQIP should cover
              />
              <BlurView
                intensity={50}
                tint="light"
                style={StyleSheet.absoluteFill}
              />
              <ActivityIndicator
                style={styles.spinner}
                size="large"
                color={Colors.light.background}
              />
            </>
          ) : (
            <SkeletonBlock
              width="100%"
              height={ar ? '100%' : 60} // Audio skeleton height
              borderRadius={8}
            />
          )}
        </View>
      )
    }

    const renderError = (
      msg: string | null,
      ctx: 'Metadata' | 'Playback' | 'Format' = 'Metadata'
    ) => (
      <View style={[styles.errorContainer, !ar && styles.audioErrorContainer]}>
        <AlertCircle
          size={ar ? 24 : 18}
          color={Colors.light.error}
          style={{ marginBottom: ar ? 8 : 4 }}
        />
        <Text style={styles.errorText}>
          {ctx} Error: {msg || 'Unknown error'}
        </Text>
      </View>
    )

    const renderInfo = (message: string) => (
      <View style={[styles.infoContainer, !ar && styles.audioInfoContainer]}>
        <Loader2
          size={ar ? 24 : 18}
          color={Colors.light.textSecondary}
          style={{ marginBottom: ar ? 8 : 4 }}
        />
        <Text style={styles.infoText}>{message}</Text>
      </View>
    )

    if (status === 'loading' || (!meta && status !== 'failed'))
      return renderLoading()
    if (status === 'failed' && !meta) return renderError(err, 'Metadata') // No meta, and metadata fetch failed

    if (!meta) return renderError('Media metadata not found.') // Should be caught by above, but defensive

    if (meta.processing_status === 'Processing')
      return renderInfo('Media is processing...')

    if (meta.processing_status === 'Failed') {
      const originalUrl = getOriginalFileUrl(meta)
      if (originalUrl) {
        // Attempt to render original if it's an image or known type
        // This is a simplified fallback. A real app might check mimeType of original.
        if (
          meta.media_type === 'Image' ||
          meta.media_type === 'SVG' ||
          meta.media_type === 'GIF'
        ) {
          return (
            <View style={contStyle}>
              <ExpoImage
                source={{ uri: originalUrl }}
                style={baseStyle}
                contentFit="contain"
              />
              <View style={styles.failedOverlay}>
                <Text style={styles.failedText}>
                  Processing failed. Showing original.
                </Text>
              </View>
            </View>
          )
        }
        // Could add similar fallbacks for video/audio if VideoView/AudioPlayer can handle original URLs
      }
      return renderError(meta.processing_error || 'Processing failed.')
    }

    // Media type specific rendering
    switch (meta.media_type) {
      case 'Image':
        const imageUrl = getBestImageUrl(meta)
        if (!imageUrl) return renderError('Image URL not available.', 'Format')
        return (
          <View style={contStyle}>
            <ExpoImage
              source={{ uri: imageUrl }}
              placeholder={{ uri: meta.metadata?.lqip_data_uri }}
              placeholderContentFit="contain"
              contentFit="contain"
              style={baseStyle}
              transition={300}
            />
          </View>
        )

      case 'SVG':
        const svgUrl = getSvgUrl(meta)
        const svgPreviewUrl = getStaticPreviewUrl(meta) // Rasterized preview
        if (svgUrl) {
          // Attempt to render main SVG, ExpoImage might handle it.
          // If not, one might need react-native-svg for direct SVG string rendering or webview.
          return (
            <View style={contStyle}>
              <ExpoImage
                source={{ uri: svgUrl }}
                placeholder={{ uri: meta.metadata?.lqip_data_uri }}
                placeholderContentFit="contain"
                contentFit="contain" // SVG should scale within bounds
                style={baseStyle}
                transition={300}
                // Add onError to fallback to rasterized preview if SVG fails
                onError={() => {
                  console.warn(
                    `ExpoImage failed to load SVG ${svgUrl}, falling back to preview.`
                  )
                  // This state change would trigger a re-render to show the preview
                  // For simplicity, this example doesn't implement local state for fallback URL
                  // but in a real app, you might set a state variable here.
                }}
              />
            </View>
          )
        } else if (svgPreviewUrl) {
          // Fallback to rasterized preview
          return (
            <View style={contStyle}>
              <ExpoImage
                source={{ uri: svgPreviewUrl }}
                placeholder={{ uri: meta.metadata?.lqip_data_uri }}
                placeholderContentFit="contain"
                contentFit="contain"
                style={baseStyle}
                transition={300}
              />
            </View>
          )
        }
        return renderError('SVG URL not available.', 'Format')

      case 'GIF': // Render GIF as video
      case 'Video':
        if (vErr) return renderError(vErr.message, 'Playback')
        if (!videoPlayer || !videoUrl)
          return renderInfo('Initializing video...')

        const isVidLoading = vStat?.isBuffering || vStat?.isLoading
        const isVidPlaying = videoPlayer.playing
        const vidPosSec = Math.floor((vStat?.positionMillis || 0) / 1000)
        const vidDurSec = Math.max(
          1,
          Math.floor((vStat?.durationMillis || 0) / 1000)
        )
        const vidSliderVal = videoSliding ? videoSlideValue : vidPosSec
        return (
          <View style={contStyle}>
            {isVidLoading && (
              <ActivityIndicator
                size="large"
                style={styles.videoSpinner}
                color={Colors.common.white}
              />
            )}
            <VideoView
              player={videoPlayer}
              style={baseStyle}
              contentFit="contain"
              allowsFullscreen
              allowsPictureInPicture
            />
            <View style={styles.controls}>
              <TouchableOpacity
                onPress={() =>
                  isVidPlaying ? videoPlayer.pause() : videoPlayer.play()
                }
                style={styles.controlBtn}
              >
                {isVidPlaying ? (
                  <Pause size={28} color="white" />
                ) : (
                  <Play size={28} color="white" />
                )}
              </TouchableOpacity>
              <Text style={styles.time}>{formatTime(vidPosSec)}</Text>
              <Slider
                style={styles.slider}
                value={vidSliderVal}
                minimumValue={0}
                maximumValue={vidDurSec}
                step={1}
                minimumTrackTintColor={Colors.light.primary}
                maximumTrackTintColor={Colors.light.border}
                thumbTintColor={Colors.light.primary}
                onSlidingStart={() => {
                  setVideoSliding(true)
                  setVideoSlideValue(vidPosSec)
                }}
                onValueChange={v => setVideoSlideValue(v)}
                onSlidingComplete={sec => {
                  videoPlayer.seekBy(sec - vidPosSec)
                  setVideoSliding(false)
                }}
                disabled={!videoPlayer || vidDurSec === 0}
              />
              <Text style={styles.time}>{formatTime(vidDurSec)}</Text>
            </View>
          </View>
        )

      case 'Audio':
        if (aStat.error) return renderError(aStat.error, 'Playback')
        if (!audioPlayer || !audioSource)
          return renderInfo('Initializing audio...')

        const isAudLoading = aStat.isBuffering || !aStat.isLoaded
        const isAudPlaying = audioPlayer.playing
        const audPosSec = Math.floor(aStat.currentTime)
        const audDurSec = Math.max(1, Math.floor(aStat.duration))
        const audSliderVal = audioSliding ? audioSlideValue : audPosSec
        return (
          <View style={[styles.container, styles.audioCtrFull]}>
            <TouchableOpacity
              onPress={() =>
                isAudPlaying ? audioPlayer.pause() : audioPlayer.play()
              }
              disabled={isAudLoading}
              style={styles.controlBtn}
            >
              {isAudLoading ? (
                <ActivityIndicator
                  size="large"
                  style={{ width: 28, height: 28 }}
                  color={Colors.light.primary}
                />
              ) : isAudPlaying ? (
                <Pause size={28} color={Colors.light.primary} />
              ) : (
                <Play size={28} color={Colors.light.primary} />
              )}
            </TouchableOpacity>
            <Text style={styles.timeA}>{formatTime(audPosSec)}</Text>
            <Slider
              style={styles.sliderA}
              value={audSliderVal}
              minimumValue={0}
              maximumValue={audDurSec}
              step={1}
              minimumTrackTintColor={Colors.light.primary}
              maximumTrackTintColor={Colors.light.border}
              thumbTintColor={Colors.light.primary}
              onSlidingStart={() => {
                setAudioSliding(true)
                setAudioSlideValue(audPosSec)
              }}
              onValueChange={v => setAudioSlideValue(v)}
              onSlidingComplete={sec => {
                audioPlayer.seekTo(sec)
                setAudioSliding(false)
              }}
              disabled={isAudLoading || audDurSec === 0}
            />
            <Text style={styles.timeA}>{formatTime(audDurSec)}</Text>
          </View>
        )

      default:
        // Fallback for 'Document' or any other unhandled types
        return renderInfo(
          `Unsupported media type: ${meta.media_type || 'Unknown'}`
        )
    }
  }
)

const styles = StyleSheet.create({
  container: {
    width: '100%',
    borderRadius: 8,
    overflow: 'hidden',
    marginBottom: 16,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: Colors.light.backgroundLight,
    alignSelf: 'center',
    position: 'relative'
  },
  spinner: { position: 'absolute' },
  videoSpinner: { position: 'absolute', zIndex: 1 },
  errorContainer: {
    borderWidth: 1,
    borderColor: Colors.light.error,
    padding: 15,
    borderRadius: 8,
    marginBottom: 16,
    alignItems: 'center',
    justifyContent: 'center',
    minHeight: 100,
    width: '100%'
  },
  audioErrorContainer: { minHeight: 60, paddingVertical: 10 },
  errorText: { color: Colors.light.error, fontSize: 14, textAlign: 'center' },
  infoContainer: {
    borderWidth: 1,
    borderColor: Colors.light.border,
    padding: 15,
    borderRadius: 8,
    marginBottom: 16,
    alignItems: 'center',
    justifyContent: 'center',
    minHeight: 100,
    width: '100%'
  },
  audioInfoContainer: { minHeight: 60, paddingVertical: 10 },
  infoText: {
    color: Colors.light.textSecondary,
    fontSize: 14,
    textAlign: 'center'
  },
  controls: {
    position: 'absolute',
    bottom: 0,
    width: '100%',
    flexDirection: 'row',
    alignItems: 'center',
    padding: 8,
    backgroundColor: 'rgba(0,0,0,0.6)'
  },
  controlBtn: { padding: 8 },
  time: {
    color: 'white',
    fontSize: 12,
    marginHorizontal: 4,
    width: TIMESTAMP_WIDTH,
    textAlign: 'center'
  },
  slider: { flex: 1, height: 30 },
  audioCtrFull: {
    width: '100%',
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 8, // Reduced horizontal padding for audio player
    paddingVertical: 12, // Standard vertical padding
    backgroundColor: Colors.common.white,
    borderWidth: 1,
    borderColor: Colors.light.border
  },
  timeA: {
    fontSize: 12,
    color: Colors.light.textSecondary,
    marginHorizontal: 4,
    width: TIMESTAMP_WIDTH,
    textAlign: 'center'
  },
  sliderA: { flex: 1, height: 30 },
  failedOverlay: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    backgroundColor: 'rgba(239, 68, 68, 0.7)', // error color with opacity
    paddingVertical: 4,
    alignItems: 'center'
  },
  failedText: {
    color: Colors.common.white,
    fontSize: 10,
    fontWeight: 'bold'
  }
})

```
src/components/ParagraphRenderer.tsx
```
import React, { useMemo, useState, useRef, useCallback } from 'react'
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Animated
} from 'react-native'
import {
  ArticleParagraph,
  WordOccurrence,
  GrammarOccurrence
} from '@features/articles/types'
import { MediaRenderer } from './MediaRenderer'
import { Colors } from '@constants/Colors'
import { X } from 'lucide-react-native'
import { robustWordTokenizer } from '@utils/textUtils'

const MEDIA_TAG_REGEX = /\[MEDIA::([^:]+)::([^\]]+)\]/
const ANIMATION_DURATION = 100

interface TappableTextSegmentProps {
  word: string
  style: any
  onPress: (
    layout: {
      pageX: number
      pageY: number
      width: number
      height: number
    } | null
  ) => void
}

const TappableTextSegment: React.FC<TappableTextSegmentProps> = React.memo(
  ({ word, style, onPress }) => {
    const textRef = useRef<Text>(null)

    const handlePress = useCallback(() => {
      if (textRef.current) {
        setTimeout(() => {
          textRef.current?.measureInWindow((pageX, pageY, width, height) =>
            onPress({ pageX, pageY, width, height })
          )
        }, 0)
      } else {
        onPress(null)
      }
    }, [word, onPress])

    return (
      <Text
        ref={textRef}
        style={style}
        onPress={handlePress}
        collapsable={false}
      >
        {word}
      </Text>
    )
  }
)

interface ParagraphRendererProps {
  paragraph: ArticleParagraph
  onWordSelect: (
    occurrence: WordOccurrence,
    paragraph: ArticleParagraph,
    layout: {
      pageX: number
      pageY: number
      width: number
      height: number
    } | null
  ) => void
  onGrammarSelect: (
    occurrence: GrammarOccurrence,
    paragraph: ArticleParagraph,
    layout: {
      pageX: number
      pageY: number
      width: number
      height: number
    } | null
  ) => void
  focusedOccurrenceId?: string | null
}

type RenderSegment =
  | {
      type: 'text_token'
      token: { word: string; spaceAfter: string }
      style: any
      key: string
    }
  | {
      type: 'highlighted_token'
      token: { word: string }
      style: any
      occurrenceData: WordOccurrence | GrammarOccurrence
      onPressLayout: (
        layout: {
          pageX: number
          pageY: number
          width: number
          height: number
        } | null
      ) => void
      key: string
    }
  | { type: 'media'; mediaId: string; mimeType: string; key: string }

export const ParagraphRenderer: React.FC<ParagraphRendererProps> = React.memo(
  ({ paragraph, onWordSelect, onGrammarSelect, focusedOccurrenceId }) => {
    const [isTranslatedViewOpen, setIsTranslatedViewOpen] = useState(false)

    const translationAnim = useRef(new Animated.Value(0)).current
    const [translationContentHeight, setTranslationContentHeight] = useState(0)

    const renderableSegments = useMemo(() => {
      const {
        original_text_fi,
        word_occurrences = [],
        grammar_occurrences = []
      } = paragraph
      if (!original_text_fi) return []

      const mediaMatch = original_text_fi.match(MEDIA_TAG_REGEX)
      if (mediaMatch && mediaMatch[1] && mediaMatch[2]) {
        return [
          {
            type: 'media',
            mediaId: mediaMatch[1],
            mimeType: mediaMatch[2],
            key: 'media-0'
          } as RenderSegment
        ]
      }

      const allOccurrences = [
        ...word_occurrences.map(occ => ({
          ...occ,
          _type: 'word' as const,
          _originalData: occ
        })),
        ...grammar_occurrences.map(occ => ({
          ...occ,
          _type: 'grammar' as const,
          _originalData: occ
        }))
      ].sort((a, b) => {
        if (a.start_char_offset !== b.start_char_offset)
          return a.start_char_offset - b.start_char_offset
        return b.end_char_offset - a.end_char_offset
      })

      const segments: RenderSegment[] = []
      let charIndex = 0
      let segmentKeyIndex = 0

      while (charIndex < original_text_fi.length) {
        let activeOccurrence: (typeof allOccurrences)[0] | null = null
        let nextInterestingIndex = original_text_fi.length

        for (const occ of allOccurrences) {
          if (occ.start_char_offset >= charIndex) {
            if (occ.start_char_offset < nextInterestingIndex) {
              nextInterestingIndex = occ.start_char_offset
              activeOccurrence =
                occ.start_char_offset === charIndex ? occ : null
            } else if (
              occ.start_char_offset === nextInterestingIndex &&
              occ.start_char_offset === charIndex
            ) {
              if (!activeOccurrence) activeOccurrence = occ
            }
          }
        }

        if (
          activeOccurrence &&
          activeOccurrence.start_char_offset === charIndex
        ) {
          const phraseContent = original_text_fi.substring(
            activeOccurrence.start_char_offset,
            activeOccurrence.end_char_offset
          )
          const tokensInHighlightedPhrase = robustWordTokenizer(phraseContent)

          const isCurrentlyFocused =
            focusedOccurrenceId === activeOccurrence.occurrence_id
          const baseHighlightStyle =
            activeOccurrence._type === 'word'
              ? styles.highlightedWord
              : styles.highlightedGrammar

          tokensInHighlightedPhrase.forEach((tokenInHighlight, tokenIndex) => {
            segments.push({
              type: 'highlighted_token',
              token: { word: tokenInHighlight.word },
              style: [
                baseHighlightStyle,
                isCurrentlyFocused &&
                  (activeOccurrence._type === 'word'
                    ? styles.focusedHighlightWord
                    : styles.focusedHighlightGrammar)
              ],
              occurrenceData: activeOccurrence._originalData,
              onPressLayout: layout => {
                if (activeOccurrence._type === 'word') {
                  onWordSelect(
                    activeOccurrence._originalData as WordOccurrence,
                    paragraph,
                    layout
                  )
                } else {
                  onGrammarSelect(
                    activeOccurrence._originalData as GrammarOccurrence,
                    paragraph,
                    layout
                  )
                }
              },
              key: `occ-${activeOccurrence.occurrence_id}-${tokenIndex}`
            })
            if (tokenInHighlight.spaceAfter) {
              segments.push({
                type: 'space_after_highlight',
                space: tokenInHighlight.spaceAfter,
                key: `occ-${activeOccurrence.occurrence_id}-${tokenIndex}-innerspace`
              })
            }
          })

          charIndex = activeOccurrence.end_char_offset

          let spaceOrPunctuationAfterOccurrence = ''
          let tempIndex = charIndex
          while (
            tempIndex < original_text_fi.length &&
            original_text_fi[tempIndex].match(/\s/)
          ) {
            spaceOrPunctuationAfterOccurrence += original_text_fi[tempIndex]
            tempIndex++
          }
          const remainingTextForPunctuation =
            original_text_fi.substring(tempIndex)
          const punctuationMatch = remainingTextForPunctuation.match(
            /^([^\s\p{L}\p{N}\p{M}'-]+)/u
          ) // Match leading punctuation
          if (punctuationMatch) {
            spaceOrPunctuationAfterOccurrence += punctuationMatch[0]
            tempIndex += punctuationMatch[0].length
          }

          if (spaceOrPunctuationAfterOccurrence) {
            segments.push({
              type: 'text_token', // Treat it as a plain text token
              token: {
                word: spaceOrPunctuationAfterOccurrence,
                spaceAfter: spaceOrPunctuationAfterOccurrence.trim() ? ' ' : ''
              }, // No further space needed for this segment
              style: styles.plainText,
              key: `text-after-occ-${activeOccurrence.occurrence_id}`
            })
            charIndex = tempIndex // Update charIndex to after this captured space/punctuation
          }
        } else {
          // No occurrence starts exactly at charIndex. This is plain text.
          // The text runs from charIndex up to nextInterestingIndex (start of next occ or end of string).
          const textContent = original_text_fi.substring(
            charIndex,
            nextInterestingIndex
          )
          if (textContent) {
            const plainTokens = robustWordTokenizer(textContent)
            plainTokens.forEach((token, tokenIndex) => {
              segments.push({
                type: 'text_token',
                token: token, // { word: "...", spaceAfter: "..." }
                style: styles.plainText,
                key: `text-${segmentKeyIndex++}-${tokenIndex}`
              })
            })
          }
          charIndex = nextInterestingIndex
        }
      }
      return segments
    }, [paragraph, focusedOccurrenceId, onWordSelect, onGrammarSelect])

    const toggleTranslation = useCallback(() => {
      const toValue = isTranslatedViewOpen ? 0 : 1
      Animated.timing(translationAnim, {
        toValue,
        duration: ANIMATION_DURATION,
        useNativeDriver: false // Animating height requires this
      }).start()
      setIsTranslatedViewOpen(!isTranslatedViewOpen) // Still need to toggle state for conditional render
    }, [isTranslatedViewOpen, translationAnim])

    const animatedTranslationStyle = {
      height: translationAnim.interpolate({
        inputRange: [0, 1],
        outputRange: [0, translationContentHeight] // Animate from 0 to measured height
      }),
      opacity: translationAnim, // Optional: fade in/out
      overflow: 'hidden' // Important for height animation
    }

    if (renderableSegments.length === 0) {
      return (
        <TouchableOpacity
          onPress={toggleTranslation}
          activeOpacity={0.7}
          style={styles.touchableParagraphWrapper}
        >
          <Text style={styles.plainText}>[Empty Paragraph]</Text>
        </TouchableOpacity>
      )
    }

    if (
      renderableSegments.length === 1 &&
      renderableSegments[0].type === 'media'
    ) {
      const mediaSegment = renderableSegments[0]
      return (
        <MediaRenderer
          mediaId={mediaSegment.mediaId}
          initialMimeType={mediaSegment.mimeType}
        />
      )
    }

    return (
      <View style={styles.paragraphOuterContainer}>
        <TouchableOpacity
          onPress={toggleTranslation}
          activeOpacity={0.8}
          style={styles.touchableParagraphWrapper}
        >
          <View style={styles.paragraphSegmentsContainer}>
            {renderableSegments.map(segment => {
              // Key generation needs to be robust
              const keySuffix =
                segment.type === 'highlighted_token'
                  ? segment.occurrenceData.occurrence_id
                  : segment.type === 'text_token'
                  ? `${segment.token.word.substring(0, 3)}-${
                      segment.token.spaceAfter.length
                    }`
                  : segment.type === 'media'
                  ? segment.mediaId
                  : Math.random().toString() // Fallback for key, should be unique

              const key = `${segment.key || segment.type}-${keySuffix}`

              if (segment.type === 'text_token') {
                return (
                  <Text key={key} style={segment.style} collapsable={false}>
                    {segment.token.word}
                    {segment.token.spaceAfter}
                  </Text>
                )
              }
              if (segment.type === 'highlighted_token') {
                return (
                  <TappableTextSegment
                    key={key}
                    word={segment.token.word} // Pass only the word
                    style={segment.style} // Style includes focus if applicable
                    onPress={segment.onPressLayout!}
                  />
                )
              }
              // 'space_after_highlight' type is no longer generated by the new logic.
              // Spaces after highlights are now part of a 'text_token'.

              if (segment.type === 'media') {
                return (
                  <MediaRenderer
                    key={key}
                    mediaId={segment.mediaId}
                    initialMimeType={segment.mimeType}
                  />
                )
              }
              return null
            })}
          </View>
        </TouchableOpacity>

        {isTranslatedViewOpen && (
          <Animated.View
            style={[styles.translationPanel, animatedTranslationStyle]}
          >
            {/* Inner view to measure the actual content height */}
            <View
              style={{
                position:
                  translationContentHeight === 0 ? 'absolute' : 'relative',
                opacity: translationContentHeight === 0 ? 0 : 1
              }} // Render off-screen initially for measurement
              onLayout={event => {
                if (event.nativeEvent.layout.height > 0) {
                  setTranslationContentHeight(event.nativeEvent.layout.height)
                }
              }}
            >
              <View style={styles.translationHeader}>
                <Text style={styles.translationPanelTitle}>Translation</Text>
                <TouchableOpacity
                  onPress={toggleTranslation}
                  style={styles.closeTranslationIcon}
                >
                  <X size={16} color={Colors.light.textSecondary} />
                </TouchableOpacity>
              </View>
              <Text style={styles.translationPanelText}>
                {paragraph.translation_en || 'No translation available.'}
              </Text>
            </View>
          </Animated.View>
        )}
      </View>
    )
  }
)

const styles = StyleSheet.create({
  paragraphSegmentsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    alignItems: 'flex-start',
    paddingHorizontal: 8,
    paddingVertical: 10,
    backgroundColor: Colors.light.background,
    borderRadius: 6
  },
  focusedHighlightStyleFromSegment: {
    // This style is applied within TappableTextSegment
    // This is ALREADY handled by focusedOccurrenceId being passed to TappableTextSegment
    // and TappableTextSegment applying styles.highlightedFocus based on its isFocused prop.
    // The focusedHighlight style is applied to the *base* style of the segment.
  },
  plainText: {
    fontSize: 17,
    fontFamily: 'Inter-Regular',
    color: Colors.light.text,
    lineHeight: 28
    // No marginRight here by default, let natural spaces in content work
  },
  highlightedWord: {
    fontSize: 17,
    fontFamily: 'Inter-Regular',
    color: '#2563EB',
    backgroundColor: '#DBEAFE',
    lineHeight: 28,
    borderRadius: 3, // Optional: for rounded highlights
    paddingHorizontal: 1 // Tiny margin if needed to prevent touching
  },
  highlightedGrammar: {
    fontSize: 17,
    fontFamily: 'Inter-Regular',
    color: '#B45309',
    backgroundColor: '#FEF3C7',
    lineHeight: 28,
    borderRadius: 3,
    paddingHorizontal: 1
  },
  focusedHighlightWord: {
    backgroundColor: '#2563EB',
    color: '#DBEAFE',
    borderRadius: 3
  },
  focusedHighlightGrammar: {
    backgroundColor: '#B45309',
    color: '#FEF3C7',
    borderRadius: 3
  },
  paragraphOuterContainer: {
    flexDirection: 'column',
    marginBottom: 16, // Spacing between paragraphs
    lineHeight: 28 // Ensure consistent line height for mixed content
  },
  touchableParagraphWrapper: {
    flex: 1
  },
  // New styles for the TranslationPanel look
  translationPanel: {
    flex: 1,
    backgroundColor: '#F9FAFB', // bg-gray-50
    borderRadius: 6,
    borderWidth: 1,
    borderColor: '#E5E7EB' // border-gray-200
    // padding is on the inner content for better animation
    // borderRadius (top part if needed) should be on paragraphOuterContainer if it has bottom border too
  },
  translationHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    paddingHorizontal: 12,
    paddingVertical: 10
  },
  translationPanelTitle: {
    fontSize: 13,
    fontFamily: 'Inter-Medium',
    color: '#374151',
    fontWeight: 'bold'
  },
  closeTranslationIcon: {
    padding: 2
  },
  translationPanelText: {
    fontSize: 14,
    fontFamily: 'Inter-Regular',
    color: '#1F2937', // text-gray-800
    lineHeight: 22, // leading-relaxed
    paddingHorizontal: 12,
    paddingBottom: 10,
    fontWeight: 'normal'
  }
})

```
src/components/ParallaxScrollView.tsx
```
import type { PropsWithChildren, ReactElement } from 'react'
import { StyleSheet } from 'react-native'
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollViewOffset
} from 'react-native-reanimated'

import { ThemedView } from '@components/ThemedView'
import { useBottomTabOverflow } from '@components/ui/TabBarBackground'
import { useColorScheme } from '@hooks/useColorScheme'

const HEADER_HEIGHT = 250

type Props = PropsWithChildren<{
  headerImage: ReactElement
  headerBackgroundColor: { dark: string; light: string }
}>

export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor
}: Props) {
  const colorScheme = useColorScheme() ?? 'light'
  const scrollRef = useAnimatedRef<Animated.ScrollView>()
  const scrollOffset = useScrollViewOffset(scrollRef)
  const bottom = useBottomTabOverflow()
  const headerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          )
        },
        {
          scale: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [2, 1, 1]
          )
        }
      ]
    }
  })

  return (
    <ThemedView style={styles.container}>
      <Animated.ScrollView
        ref={scrollRef}
        scrollEventThrottle={16}
        // scrollIndicatorInsets={{ bottom }}
        contentContainerStyle={{ paddingBottom: bottom }}
      >
        <Animated.View
          style={[
            styles.header,
            { backgroundColor: headerBackgroundColor[colorScheme] },
            headerAnimatedStyle
          ]}
        >
          {headerImage}
        </Animated.View>
        <ThemedView style={styles.content}>{children}</ThemedView>
      </Animated.ScrollView>
    </ThemedView>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1
  },
  header: {
    height: HEADER_HEIGHT,
    overflow: 'hidden'
  },
  content: {
    flex: 1,
    padding: 32,
    gap: 16,
    overflow: 'hidden'
  }
})

```
src/components/ThemedText.tsx
```
import { Text, type TextProps, StyleSheet } from "react-native";

import { useThemeColor } from "@hooks/useThemeColor";

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: "default" | "title" | "defaultSemiBold" | "subtitle" | "link";
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = "default",
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, "text");

  return (
    <Text
      style={[
        { color },
        type === "default" ? styles.default : undefined,
        type === "title" ? styles.title : undefined,
        type === "defaultSemiBold" ? styles.defaultSemiBold : undefined,
        type === "subtitle" ? styles.subtitle : undefined,
        type === "link" ? styles.link : undefined,
        style,
      ]}
      {...rest}
    />
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: "600",
  },
  title: {
    fontSize: 32,
    fontWeight: "bold",
    lineHeight: 32,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: "bold",
  },
  link: {
    lineHeight: 30,
    fontSize: 16,
    color: "#0a7ea4",
  },
});


```
src/components/ThemedView.tsx
```
import { View, type ViewProps } from "react-native";

import { useThemeColor } from "@hooks/useThemeColor";

export type ThemedViewProps = ViewProps & {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({
  style,
  lightColor,
  darkColor,
  ...otherProps
}: ThemedViewProps) {
  const backgroundColor = useThemeColor(
    { light: lightColor, dark: darkColor },
    "background"
  );

  return <View style={[{ backgroundColor }, style]} {...otherProps} />;
}


```
src/components/reader/ArticleAudioPlayer.tsx
```
import React from 'react'
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native'
import { PlayCircle } from 'lucide-react-native'
import { Colors } from '@constants/Colors'

interface ArticleAudioPlayerProps {
  articleId: string
  onPlayPress: () => void
}

const MOCK_AUDIO_DURATION = '4:32'

export function ArticleAudioPlayer({
  articleId,
  onPlayPress
}: ArticleAudioPlayerProps): React.ReactElement {
  const displayDuration = MOCK_AUDIO_DURATION

  return (
    <TouchableOpacity
      style={styles.audioPlayerOuterContainer}
      onPress={onPlayPress}
      activeOpacity={0.75}
      accessibilityRole="button"
      accessibilityLabel={`Listen to article, duration ${displayDuration}`}
    >
      <View style={styles.audioPlayerContent}>
        <PlayCircle size={24} color={Colors.light.primary} />
        <Text style={styles.audioPlayerText}>Listen to Article</Text>
      </View>
      {displayDuration && (
        <View style={styles.audioDurationBadge}>
          <Text style={styles.audioDurationText}>{displayDuration}</Text>
        </View>
      )}
    </TouchableOpacity>
  )
}

const styles = StyleSheet.create({
  audioPlayerOuterContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: Colors.common.white,
    borderRadius: 12,
    paddingVertical: 12,
    paddingHorizontal: 16,
    marginBottom: 24,
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.08,
    shadowRadius: 3,
    elevation: 2,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: Colors.light.borderSubtle
  },
  audioPlayerContent: {
    flexDirection: 'row',
    alignItems: 'center'
  },
  audioPlayerText: {
    fontFamily: 'Inter-Medium',
    fontSize: 15,
    color: Colors.light.text,
    marginLeft: 10
  },
  audioDurationBadge: {
    backgroundColor: Colors.light.backgroundSecondary,
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 8
  },
  audioDurationText: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 12,
    color: Colors.light.textSecondary
  }
})

```
src/components/reader/ArticleCard.tsx
```
import React, { useMemo } from 'react'
import type { Article as ArticleType } from '@features/articles/types'
import { Colors } from '@constants/Colors'
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Pressable
} from 'react-native'
import { BookOpen } from 'lucide-react-native'
import { formatDistanceToNowStrict } from 'date-fns'

interface ArticleCardProps {
  article: ArticleType
  onPress: () => void
}

export function ArticleCard({
  article,
  onPress
}: ArticleCardProps): React.ReactElement {
  const formattedDate = useMemo(() => {
    if (!article?.publication_date) return ''
    return formatDistanceToNowStrict(new Date(article.publication_date), {
      addSuffix: true
    })
  }, [article?.publication_date])

  const handleBrandPress = (e: any) => {
    e.stopPropagation()
    console.log('Brand pressed (ArticleCard):', article?.brand?.display_name)
    Alert.alert(
      'Brand Action',
      `Brand: ${article?.brand?.display_name} (Not Implemented)`
    )
  }

  return (
    <TouchableOpacity style={styles.card} onPress={onPress} activeOpacity={0.8}>
      <View style={styles.bookmarkIconContainer}>
        <BookOpen size={18} color={Colors.light.textTertiary} />
      </View>

      <View style={styles.content}>
        <Text style={styles.title} numberOfLines={3}>
          {article?.title || 'Untitled Article'}
        </Text>

        <View style={styles.footer}>
          {article?.brand?.display_name && (
            <Pressable onPress={handleBrandPress} hitSlop={10}>
              <Text style={styles.brandName}>{article.brand.display_name}</Text>
            </Pressable>
          )}
          {article?.publication_date && (
            <Text style={styles.dateText}>{formattedDate}</Text>
          )}
        </View>
      </View>
    </TouchableOpacity>
  )
}
import { Alert } from 'react-native'

const styles = StyleSheet.create({
  card: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 12,
    marginBottom: 16,
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: Colors.light.borderSubtle,
    overflow: 'hidden',
    padding: 16,
    position: 'relative'
  },
  bookmarkIconContainer: {
    position: 'absolute',
    top: 12,
    right: 12,
    padding: 4,
    zIndex: 1
  },
  content: {
    flex: 1,
    justifyContent: 'space-between'
  },
  title: {
    fontSize: 17,
    fontFamily: 'Inter-SemiBold',
    color: Colors.light.text,
    marginBottom: 10,
    lineHeight: 23,
    paddingRight: 30
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 8
  },
  brandName: {
    fontSize: 13,
    fontFamily: 'Inter-Medium',
    color: Colors.light.primary,
    paddingVertical: 2,
    marginRight: 8,
    flexShrink: 1
  },
  dateText: {
    fontSize: 12,
    fontFamily: 'Inter-Regular',
    color: Colors.light.textSecondary,
    textAlign: 'right',
    flexShrink: 0
  },
  progressBarContainer: {
    height: 4,
    backgroundColor: Colors.light.backgroundSecondary,
    borderRadius: 2,
    overflow: 'hidden'
  },
  progressBar: {
    height: '100%',
    backgroundColor: Colors.light.primary,
    borderRadius: 2
  }
})

```
src/components/reader/ArticleCardWithThumbnail.tsx
```
import React, { useMemo } from 'react'
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Alert,
  Platform
} from 'react-native'
import { useRouter } from 'expo-router'
import type { Article as ArticleType } from '@features/articles/types'
import { Colors } from '@constants/Colors'
import { Bookmark, BookmarkCheck } from 'lucide-react-native'
import { useResponsiveDimensions } from '@/hooks/useResponsiveDimensions'
import { formatDistanceToNowStrict } from 'date-fns'
import { ArticleThumbnail } from './ArticleThumbnail'

interface ArticleCardWithThumbnailProps {
  article: ArticleType
  size?: 'small' | 'medium' | 'large'
}

export function ArticleCardWithThumbnail({
  article,
  size = 'small'
}: ArticleCardWithThumbnailProps): React.ReactElement {
  const router = useRouter()
  const { isDesktop } = useResponsiveDimensions()
  const [isLocallySaved, setIsLocallySaved] = React.useState(false)

  const cardDimensions = useMemo(() => {
    let width = 220
    let imageHeight = 140
    if (size === 'medium') {
      width = isDesktop ? 280 : 240
      imageHeight = isDesktop ? 180 : 150
    } else if (size === 'large') {
      width = isDesktop ? 340 : 260
      imageHeight = isDesktop ? 220 : 170
    }
    return { width, imageHeight }
  }, [size, isDesktop])

  const handlePress = () => {
    router.push({ pathname: '/(main)/reader/[id]', params: { id: article.id } })
  }

  const handleToggleSave = (e: any) => {
    e.stopPropagation()
    setIsLocallySaved(!isLocallySaved)
    Alert.alert(
      'Save Action',
      isLocallySaved ? 'Unsaced (mock)' : 'Saved (mock)'
    )
  }

  const formattedDate = useMemo(() => {
    if (!article?.publication_date) return ''
    return formatDistanceToNowStrict(new Date(article.publication_date), {
      addSuffix: true
    })
  }, [article?.publication_date])

  return (
    <TouchableOpacity
      style={[styles.shadowContainer, { width: cardDimensions.width }]}
      onPress={handlePress}
      activeOpacity={0.85}
    >
      <View style={styles.cardContentWrapper}>
        <View
          style={[
            styles.imageOuterContainer,
            { height: cardDimensions.imageHeight }
          ]}
        >
          <ArticleThumbnail
            article={article}
            style={styles.imageFill}
            containerStyle={styles.thumbnailContainerStyle}
            size={
              size === 'small'
                ? 'thumb'
                : size === 'medium'
                ? 'medium'
                : 'large'
            }
            contentFit="cover"
          />
          <TouchableOpacity
            style={styles.bookmarkButton}
            onPress={handleToggleSave}
          >
            {isLocallySaved ? (
              <BookmarkCheck
                size={20}
                color={Colors.light.primary}
                fill={Colors.light.primaryLight}
              />
            ) : (
              <Bookmark size={20} color={Colors.light.primaryContent} />
            )}
          </TouchableOpacity>
          {article?.tags && article.tags.length > 0 && (
            <View style={styles.categoryBadge}>
              <Text style={styles.categoryText} numberOfLines={1}>
                {article.tags[0].toUpperCase()}
              </Text>
            </View>
          )}
        </View>

        <View style={styles.textContextContainer}>
          <Text style={styles.title} numberOfLines={size === 'small' ? 2 : 3}>
            {article.title}
          </Text>
          <View style={styles.metaLine}>
            {article?.brand?.display_name && (
              <Text style={styles.brandText} numberOfLines={1}>
                {article.brand.display_name}
              </Text>
            )}
            {article?.brand?.display_name && formattedDate && (
              <Text style={styles.metaSeparator}></Text>
            )}
            {formattedDate && (
              <Text style={styles.dateText} numberOfLines={1}>
                {formattedDate}
              </Text>
            )}
          </View>
        </View>
      </View>
    </TouchableOpacity>
  )
}

const styles = StyleSheet.create({
  shadowContainer: {
    borderRadius: 12,
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: Colors.light.borderSubtle,
    flex: 1
  },
  cardContentWrapper: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 12,
    overflow: 'hidden',
    flex: 1
  },
  imageOuterContainer: {
    position: 'relative',
    width: '100%',
    backgroundColor: Colors.light.backgroundSecondary
  },
  thumbnailContainerStyle: {},
  imageFill: {
    width: '100%',
    height: '100%'
  },
  bookmarkButton: {
    position: 'absolute',
    top: 10,
    right: 10,
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: 'rgba(0, 0, 0, 0.4)',
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 1
  },
  categoryBadge: {
    position: 'absolute',
    bottom: 8,
    left: 8,
    backgroundColor: 'rgba(0, 0, 0, 0.6)',
    paddingHorizontal: 8,
    paddingVertical: 3,
    borderRadius: 6,
    zIndex: 1,
    maxWidth: '70%'
  },
  categoryText: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 10,
    color: Colors.light.primaryContent,
    textTransform: 'uppercase'
  },
  textContextContainer: {
    padding: 12
  },
  title: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 15,
    color: Colors.light.text,
    marginBottom: 6,
    lineHeight: 20
  },
  metaLine: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 4
  },
  brandText: {
    fontFamily: 'Inter-Medium',
    fontSize: 12,
    color: Colors.light.primary,
    flexShrink: 1
  },
  metaSeparator: {
    fontFamily: 'Inter-Regular',
    fontSize: 12,
    color: Colors.light.textSecondary,
    marginHorizontal: 5
  },
  dateText: {
    fontFamily: 'Inter-Regular',
    fontSize: 12,
    color: Colors.light.textSecondary,
    flexShrink: 1
  }
})

```
src/components/reader/ArticleHeaderControls.tsx
```
import React from 'react'
import {
  View,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator
} from 'react-native'
import { ArrowLeft, Bookmark, Share, BookmarkCheck } from 'lucide-react-native'
import { Colors } from '@constants/Colors'

interface ArticleHeaderControlsProps {
  onGoBack: () => void
  onToggleSave: () => void
  onShare: () => void // Assuming a share function will be implemented
  isSaveLoading: boolean
  isArticleSaved: boolean // Reflects the current saved state (optimistic or from store)
  isDesktop?: boolean // Optional prop for styling differences
}

export const ArticleHeaderControls: React.FC<ArticleHeaderControlsProps> = ({
  onGoBack,
  onToggleSave,
  onShare,
  isSaveLoading,
  isArticleSaved,
  isDesktop = false
}) => {
  return (
    <View
      style={[
        styles.articleHeaderControls,
        isDesktop
          ? styles.wideScreenHeaderControls
          : styles.mobileHeaderControls
      ]}
      pointerEvents="box-none"
    >
      <TouchableOpacity
        style={styles.backButtonContainer}
        onPress={onGoBack}
        accessibilityLabel="Go back"
        accessibilityRole="button"
        pointerEvents="auto"
      >
        <ArrowLeft size={22} color={Colors.common.white} />
      </TouchableOpacity>
      <View style={styles.headerRightButtons}>
        <TouchableOpacity
          style={styles.headerButton}
          onPress={onToggleSave}
          disabled={isSaveLoading}
          accessibilityLabel={
            isArticleSaved ? 'Unsave article' : 'Save article'
          }
          accessibilityRole="button"
          pointerEvents="auto"
        >
          {isSaveLoading ? (
            <ActivityIndicator size="small" color={Colors.common.white} />
          ) : isArticleSaved ? (
            <BookmarkCheck size={22} color={Colors.light.primary} />
          ) : (
            <Bookmark size={22} color={Colors.common.white} />
          )}
        </TouchableOpacity>
        <TouchableOpacity
          style={styles.headerButton}
          onPress={onShare}
          accessibilityLabel="Share article"
          accessibilityRole="button"
          pointerEvents="auto"
        >
          <Share size={22} color={Colors.common.white} />
        </TouchableOpacity>
      </View>
    </View>
  )
}

// Styles are copied and adapted from ArticleScreen.tsx
// Consider moving to a shared style sheet if these styles are reused elsewhere.
const styles = StyleSheet.create({
  articleHeaderControls: {
    position: 'absolute', // Will be placed absolutely by the parent (ArticleScreen)
    top: 0, // Or adjust based on SafeAreaInsets in the parent
    left: 0,
    right: 0,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 10, // Standard padding
    zIndex: 3, // Ensure it's above other content like header gradients
    marginTop: 10 // This margin will be handled by SafeAreaView in ArticleScreen
  },
  mobileHeaderControls: {},
  wideScreenHeaderControls: {
    marginHorizontal: 20 // Keep specific wide-screen horizontal margin
  },
  backButtonContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(0, 0, 0, 0.55)',
    alignItems: 'center',
    justifyContent: 'center'
  },
  headerRightButtons: {
    flexDirection: 'row',
    gap: 12
  },
  headerButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    alignItems: 'center',
    justifyContent: 'center'
  }
})

```
src/components/reader/ArticleMetadataDisplay.tsx
```
import React from 'react'
import { View, Text, StyleSheet, Pressable } from 'react-native'
import { Article } from '@features/articles/types'
import { Colors } from '@constants/Colors'

interface ArticleMetadataDisplayProps {
  article: Article | null | undefined
  publicationDateFormatted: string
  onBrandPress: () => void
  isDesktop?: boolean
}

export function ArticleMetadataDisplay({
  article,
  publicationDateFormatted,
  onBrandPress,
  isDesktop = false
}: ArticleMetadataDisplayProps): React.ReactElement | null {
  if (!article) {
    return null
  }

  const displayCategory =
    article.category && article.tags?.includes(article.category)

  return (
    <View style={styles.metaDisplayContainer}>
      {displayCategory && (
        <Text style={styles.articleCategoryText}>
          {article.category?.toUpperCase()}
        </Text>
      )}
      <Text
        style={[styles.articleTitle, isDesktop && styles.desktopArticleTitle]}
      >
        {article.title}
      </Text>
      {article.subtitle && (
        <Text
          style={[
            styles.articleSubtitle,
            isDesktop && styles.desktopArticleSubtitle
          ]}
        >
          {article.subtitle}
        </Text>
      )}

      {article.tags && article.tags.length > 0 && (
        <View style={styles.tagsContainer}>
          {article.tags.map(tag => (
            <View key={tag} style={styles.tagChip}>
              <Text style={styles.tagText}>{tag}</Text>
            </View>
          ))}
        </View>
      )}

      <View style={styles.bylineContainer}>
        {article.brand?.display_name && (
          <Pressable
            onPress={onBrandPress}
            hitSlop={10}
            style={styles.brandPressable}
          >
            <Text style={styles.brandText}>{article.brand.display_name}</Text>
          </Pressable>
        )}
        {article.brand?.display_name && publicationDateFormatted && (
          <Text style={styles.bylineSeparator}></Text>
        )}
        {publicationDateFormatted && (
          <Text style={styles.dateText}>{publicationDateFormatted}</Text>
        )}
      </View>
    </View>
  )
}

const styles = StyleSheet.create({
  metaDisplayContainer: {},
  articleCategoryText: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 13,
    color: Colors.light.primary,
    textTransform: 'uppercase',
    marginBottom: 8
  },
  articleTitle: {
    fontFamily: 'Inter-Bold',
    fontSize: 26,
    color: Colors.light.text,
    marginBottom: 8,
    lineHeight: 34
  },
  desktopArticleTitle: {
    fontSize: 30,
    lineHeight: 38
  },
  articleSubtitle: {
    fontFamily: 'Inter-Regular',
    fontSize: 17,
    color: Colors.light.textSecondary,
    marginBottom: 16,
    lineHeight: 25
  },
  desktopArticleSubtitle: {
    fontSize: 19,
    lineHeight: 28
  },
  tagsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 16,
    gap: 8
  },
  tagChip: {
    backgroundColor: Colors.light.backgroundSecondary,
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 16,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: Colors.light.borderSubtle
  },
  tagText: {
    fontFamily: 'Inter-Medium',
    fontSize: 12,
    color: Colors.light.textSecondary
  },
  bylineContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
    flexWrap: 'wrap',
    gap: 6
  },
  brandPressable: {},
  brandText: {
    fontSize: 14,
    fontFamily: 'Inter-SemiBold',
    color: Colors.light.primary
  },
  bylineSeparator: {
    fontFamily: 'Inter-Regular',
    fontSize: 14,
    color: Colors.light.textTertiary,
    paddingHorizontal: 2
  },
  dateText: {
    fontSize: 14,
    fontFamily: 'Inter-Regular',
    color: Colors.light.textSecondary
  }
})

```
src/components/reader/ArticleParagraphsList.tsx
```
import React from 'react'
import { View, StyleSheet, Text } from 'react-native'
import {
  ArticleParagraph,
  WordOccurrence,
  GrammarOccurrence
} from '@features/articles/types'
import { ParagraphRenderer } from '@components/ParagraphRenderer' // Assuming this is the correct path

interface ArticleParagraphsListProps {
  paragraphs: ArticleParagraph[] | undefined | null
  onWordSelect: (
    occurrence: WordOccurrence,
    paragraph: ArticleParagraph,
    layout: {
      pageX: number
      pageY: number
      width: number
      height: number
    } | null
  ) => void
  onGrammarSelect: (
    occurrence: GrammarOccurrence,
    paragraph: ArticleParagraph,
    layout: {
      pageX: number
      pageY: number
      width: number
      height: number
    } | null
  ) => void
  focusedOccurrenceId?: string | null
}

export const ArticleParagraphsList: React.FC<ArticleParagraphsListProps> = ({
  paragraphs,
  onWordSelect,
  onGrammarSelect,
  focusedOccurrenceId
}) => {
  if (!paragraphs || paragraphs.length === 0) {
    // Optionally, render a message or skeleton if paragraphs are loading/empty
    // For now, returning null if no paragraphs.
    return (
      <View style={styles.emptyContainer}>
        <Text style={styles.emptyText}>
          No content available for this article.
        </Text>
      </View>
    )
  }

  // Sort paragraphs by index before rendering
  const sortedParagraphs = [...paragraphs].sort(
    (a, b) => a.paragraph_index - b.paragraph_index
  )

  return (
    <View style={styles.articleContent}>
      {sortedParagraphs.map(paragraph => (
        <ParagraphRenderer
          key={paragraph.paragraph_id || paragraph.paragraph_index.toString()} // Ensure key is a string
          paragraph={paragraph}
          onWordSelect={onWordSelect}
          onGrammarSelect={onGrammarSelect}
          focusedOccurrenceId={focusedOccurrenceId}
        />
      ))}
    </View>
  )
}

const styles = StyleSheet.create({
  articleContent: {
    marginBottom: 24 // Spacing after the paragraphs block
  },
  emptyContainer: {
    paddingVertical: 30,
    alignItems: 'center'
  },
  emptyText: {
    fontSize: 16,
    color: '#666',
    fontStyle: 'italic'
  }
  // ParagraphRenderer itself handles individual paragraph styling
})

```
src/components/reader/ArticleThumbnail.tsx
```
import React, { useMemo } from 'react'
import { View, StyleSheet, ActivityIndicator } from 'react-native'
import { Image as ExpoImage, ImageStyle } from 'expo-image'

import { Article } from '@features/articles/types'
import { MediaMetadata } from '@features/media/types'
import { getBestImageUrl, getStaticPreviewUrl } from '@lib/mediaUtils'
import { Colors } from '@constants/Colors'
import { ImageOff } from 'lucide-react-native'

interface ArticleThumbnailProps {
  article: Article | null | undefined
  style?: ImageStyle
  size?: 'thumb' | 'medium' | 'large'
  contentFit?: 'cover' | 'contain'
}

export const ArticleThumbnail: React.FC<ArticleThumbnailProps> = React.memo(
  ({ article, style, size = 'medium', contentFit = 'cover' }) => {
    const thumbnailMetadata: MediaMetadata | null | undefined =
      article?.thumbnail

    const imageUrl = useMemo(() => {
      if (!thumbnailMetadata) return null
      if (thumbnailMetadata.media_type === 'SVG') {
        return getStaticPreviewUrl(thumbnailMetadata)
      }
      return getBestImageUrl(thumbnailMetadata, size)
    }, [thumbnailMetadata, size])

    const lqip = thumbnailMetadata?.metadata?.lqip_data_uri

    if (!thumbnailMetadata) {
      return (
        <View style={[styles.placeholder, styles.placeholderEmpty, style]}>
          <ImageOff size={24} color={Colors.light.textTertiary} />
        </View>
      )
    }

    if (thumbnailMetadata.processing_status === 'Processing') {
      return (
        <View style={[styles.placeholder, style]}>
          {lqip ? (
            <ExpoImage
              source={{ uri: lqip }}
              style={styles.image}
              contentFit="cover"
            />
          ) : null}
          <ActivityIndicator
            style={StyleSheet.absoluteFill}
            color={lqip ? Colors.common.white : Colors.light.textSecondary}
          />
        </View>
      )
    }

    if (
      thumbnailMetadata.processing_status === 'Failed' ||
      (thumbnailMetadata.processing_status === 'Completed' && !imageUrl)
    ) {
      return (
        <View style={[styles.placeholder, styles.placeholderError, style]}>
          <ImageOff size={24} color={Colors.light.error} />
        </View>
      )
    }

    return (
      <ExpoImage
        source={{ uri: imageUrl as string }}
        placeholder={{ uri: lqip }}
        placeholderContentFit="cover"
        contentFit={contentFit}
        style={[styles.image, style]}
        transition={300}
      />
    )
  }
)

const styles = StyleSheet.create({
  placeholder: {
    width: '100%',
    height: '100%',
    backgroundColor: Colors.light.backgroundSecondary,
    justifyContent: 'center',
    alignItems: 'center',
    overflow: 'hidden',
    position: 'relative'
  },
  placeholderEmpty: {
    borderWidth: 1,
    borderColor: Colors.light.border
  },
  placeholderError: {
    backgroundColor: Colors.light.errorBackground,
    borderWidth: 1,
    borderColor: Colors.light.error
  },
  image: {
    width: '100%',
    height: '100%',
    backgroundColor: Colors.light.backgroundSecondary,
    overflow: 'hidden'
  }
})

```
src/components/reader/ArticleVocabularySection.tsx
```
import React from 'react'
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native'
import { Volume2 } from 'lucide-react-native'
import { VocabularyType as ArticleVocabularyItem } from '@features/articles/types' // Renaming for clarity within this component
import { Colors } from '@constants/Colors'

interface ArticleVocabularySectionProps {
  vocabulary: ArticleVocabularyItem[] | undefined | null
  isDesktop?: boolean
  // onPlayWordAudio: (word: string) => void; // If audio playback is handled here
  // onSaveWordToVocabulary: (word: string, translation: string) => void; // If saving is handled here
}

export const ArticleVocabularySection: React.FC<
  ArticleVocabularySectionProps
> = ({ vocabulary, isDesktop = false }) => {
  if (!vocabulary || vocabulary.length === 0) {
    return null // Don't render the section if there's no vocabulary
  }

  const handlePlayAudio = (word: string) => {
    // TODO: Implement actual audio playback for the word
    alert(`Play audio for ${word} (Not Implemented)`)
  }

  // const handleSaveWord = (word: string, translation: string) => {
  //   // TODO: Implement logic to save the word to user's vocabulary
  //   alert(`Save word: ${word} - ${translation} (Not Implemented)`);
  // };

  return (
    <View
      style={[
        styles.vocabularySection,
        isDesktop && styles.wideScreenVocabularySection
      ]}
    >
      <Text style={styles.vocabularySectionTitle}>Key Vocabulary</Text>
      {vocabulary.map((item, index) => (
        <View key={index} style={styles.vocabularyItem}>
          <View style={styles.vocabularyWordContainer}>
            <Text style={styles.finnishWord}>{item.word}</Text>
            <TouchableOpacity
              style={styles.audioButton}
              onPress={() => handlePlayAudio(item.word)}
              accessibilityLabel={`Play audio for ${item.word}`}
            >
              <Volume2 size={16} color={Colors.light.primary} />
            </TouchableOpacity>
          </View>
          <Text style={styles.englishTranslation}>{item.translation}</Text>
          {item.example && ( // Conditionally render example if it exists
            <Text style={styles.exampleText}>"{item.example}"</Text>
          )}
        </View>
      ))}
    </View>
  )
}

// Styles are copied and adapted from ArticleScreen.tsx
const styles = StyleSheet.create({
  vocabularySection: {
    paddingHorizontal: 20, // Keep horizontal padding consistent with ArticleScreen's content
    paddingVertical: 20, // Add vertical padding for the section itself
    backgroundColor: Colors.light.cardBackground
    // borderTopWidth: 1, // Removed to simplify, can be added by parent if needed
    // borderTopColor: Colors.light.border,
  },
  wideScreenVocabularySection: {
    maxWidth: 760, // Match content width on desktop
    width: '100%',
    alignSelf: 'center', // Center it if it's narrower than screen
    borderRadius: 12,
    marginTop: 24, // Add margin when it's a distinct card on desktop
    marginBottom: 40
  },
  vocabularySectionTitle: {
    fontFamily: 'Inter-Bold',
    fontSize: 18,
    color: Colors.light.text,
    marginBottom: 16
  },
  vocabularyItem: {
    marginBottom: 16,
    paddingBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: Colors.light.border
    // Remove border from last item - using pseudo-class for web/React Native Web
    // For native, this can be handled by not rendering border for the last item or specific styling.
    // RN doesn't directly support '&:last-child' in StyleSheet.create
  },
  // To handle last-child border in native:
  // You would typically map and check if it's the last item in the render method.
  // For example: style={[styles.vocabularyItem, index === vocabulary.length - 1 && styles.lastVocabularyItem]}
  // And then add: lastVocabularyItem: { borderBottomWidth: 0, marginBottom: 0, paddingBottom: 0 }

  vocabularyWordContainer: {
    // Renamed from vocabularyWord for clarity
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
    justifyContent: 'space-between'
  },
  finnishWord: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 16,
    color: Colors.light.text,
    marginRight: 8,
    flexShrink: 1
  },
  audioButton: {
    padding: 4 // Hit area
  },
  englishTranslation: {
    fontFamily: 'Inter-Medium',
    fontSize: 14,
    color: Colors.light.primary,
    marginBottom: 4
  },
  exampleText: {
    fontFamily: 'Inter-Regular',
    fontSize: 14,
    color: Colors.light.textSecondary,
    fontStyle: 'italic'
  }
})

```
src/components/reader/InteractiveDetailPopup.tsx
```
// src/components/reader/InteractiveDetailPopup.tsx
import React, { useRef, useEffect, useCallback, useState } from 'react'
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  Animated,
  Dimensions,
  Platform,
  StatusBar
} from 'react-native'
import { X, Volume2, Save, BookOpen } from 'lucide-react-native' // Updated icons
// import { Colors } from '@constants/Colors'; // We'll define colors locally or use new ones
import {
  ArticleParagraph,
  WordOccurrence,
  GrammarOccurrence,
  BaseWordDetail,
  GrammarDetail,
  InflectedFormDetails
} from '@features/articles/types'
import { useSafeAreaInsets } from 'react-native-safe-area-context'
import { CustomScrollView } from '@/components/common/CustomScrollView'

export type PopupContentMode = 'word' | 'grammar' | null

interface InteractiveDetailPopupProps {
  isVisible: boolean
  contentMode: PopupContentMode
  // paragraphData: ArticleParagraph | null; // For paragraph translation & context - Not in web popovers, removing for now to match
  wordOccurrenceData: WordOccurrence | null
  grammarOccurrenceData: GrammarOccurrence | null
  onClose: () => void
  onSaveWord?: (baseWord: BaseWordDetail) => void
  onSaveGrammar?: (grammar: GrammarDetail) => void
  onLearnMoreWord?: (baseWord: BaseWordDetail) => void // Example action
  onLearnMoreGrammar?: (grammar: GrammarDetail) => void // Example action
  // onPlayAudio?: (text: string, lang?: 'fi' | 'en') => void; // Can be handled internally or via prop
  isDesktop?: boolean // Retained for potential platform-specific adjustments
  popupPosition: {
    top: number
    left: number
    targetWidth: number
    targetHeight: number
  } | null
}

const POPUP_MAX_HEIGHT_PERCENT = 0.5 // Max 50% of screen height
const POPUP_WIDTH = 320 // Corresponds to w-80

const POPUP_DEFAULT_WIDTH = 320
const POPUP_MAX_WIDTH_PERCENT = 0.9 // Max 90% of screen width

const POPUP_MARGIN_FROM_TARGET = 5 // Space between target and popup
const SCREEN_EDGE_MARGIN = 10 // Min space from screen edges

const SCREEN_DIMENSIONS = Dimensions.get('window')

// Define colors based on Tailwind names
const AppColors = {
  white: '#FFFFFF',
  black: '#000000',

  gray50: '#F9FAFB',
  gray100: '#F3F4F6',
  gray200: '#E5E7EB', // border
  gray400: '#9CA3AF', // close icon
  gray500: '#6B7280', // secondary text
  gray600: '#4B5563', // paragraph text
  gray700: '#374151', // medium text, section titles
  gray800: '#1F2937', // example text
  gray900: '#11182C', // main title text

  amber50: '#FFFBEB',
  amber100: '#FEF3C7', // save button bg (grammar)
  amber200: '#FDE68A', // save button hover bg (grammar)
  amber700: '#B45309', // text on amber bg
  amber800: '#92400E', // text on amber bg

  green100: '#DCFCE7',
  green200: '#BBF7D0',
  green800: '#166534',

  blue100: '#DBEAFE', // save button bg (word)
  blue200: '#BFDBFE', // save button hover bg (word)
  blue600: '#2563EB', // learn more text
  blue800: '#1E40AF', // learn more hover, text on blue bg

  purple100: '#F3E8FF',
  purple200: '#E9D5FF',
  purple800: '#581C87'
}

// Determine CEFR level badge color and text color
const getCefrStyle = (
  level: string | null | undefined
): { backgroundColor: string; color: string } => {
  switch (level) {
    case 'A1':
      return { backgroundColor: AppColors.green100, color: AppColors.green800 }
    case 'A2':
      return { backgroundColor: AppColors.green200, color: AppColors.green800 }
    case 'B1':
      return { backgroundColor: AppColors.blue100, color: AppColors.blue800 }
    case 'B2':
      return { backgroundColor: AppColors.blue200, color: AppColors.blue800 }
    case 'C1':
      return {
        backgroundColor: AppColors.purple100,
        color: AppColors.purple800
      }
    case 'C2':
      return {
        backgroundColor: AppColors.purple200,
        color: AppColors.purple800
      }
    default:
      return { backgroundColor: AppColors.gray100, color: AppColors.gray800 }
  }
}

// Format case display for readability (from WordPopover)
const formatCase = (caseValue: string | null | undefined): string => {
  if (!caseValue) return 'N/A'
  return caseValue.charAt(0).toUpperCase() + caseValue.slice(1).toLowerCase()
}

export const InteractiveDetailPopup: React.FC<InteractiveDetailPopupProps> = ({
  isVisible,
  contentMode,
  wordOccurrenceData,
  grammarOccurrenceData,
  onClose,
  onSaveWord,
  onSaveGrammar,
  onLearnMoreWord,
  onLearnMoreGrammar,
  isDesktop = false,
  popupPosition
}) => {
  const anim = useRef(new Animated.Value(0)).current
  // contentNaturalHeight: the height the content *would* take if unconstrained
  const [contentNaturalHeight, setContentNaturalHeight] = useState<
    number | null
  >(null)
  const safeAreaInsets = useSafeAreaInsets()

  const [isMounted, setIsMounted] = useState(isVisible)
  useEffect(() => {
    if (!isVisible || !popupPosition) {
      setContentNaturalHeight(null) // Reset measured height when hiding or target is gone
    }
    // Animation logic for isVisible
    Animated.timing(anim, {
      toValue: isVisible && popupPosition ? 1 : 0,
      duration: isVisible ? 250 : 150,
      useNativeDriver: false
    }).start(() => setIsMounted(false))
  }, [isVisible, popupPosition, anim])

  const onActualContentLayout = (event: {
    nativeEvent: { layout: { height: number } }
  }) => {
    const newHeight = event.nativeEvent.layout.height
    if (newHeight > 0 && newHeight !== contentNaturalHeight) {
      setContentNaturalHeight(newHeight)
    }
  }

  const handleInternalClose = useCallback(() => {
    onClose()
  }, [onClose])

  const renderWordDetails = () => {
    if (!wordOccurrenceData || !wordOccurrenceData.base_word_detail) return null
    const {
      base_word_detail,
      inflected_form_details,
      specific_explanation_en
    } = wordOccurrenceData

    const cefrStyle = getCefrStyle(base_word_detail.cefr_level)

    return (
      <>
        {/* Header */}
        <View style={styles.popoverHeader}>
          <View style={styles.titleContainer}>
            <Text style={styles.titleText}>{base_word_detail.word_fi}</Text>
            <View
              style={[
                styles.cefrBadge,
                { backgroundColor: cefrStyle.backgroundColor }
              ]}
            >
              <Text style={[styles.cefrBadgeText, { color: cefrStyle.color }]}>
                {base_word_detail.cefr_level || 'N/A'}
              </Text>
            </View>
          </View>
          <TouchableOpacity
            onPress={handleInternalClose}
            accessibilityLabel="Close"
            style={styles.closeButton}
          >
            <X size={18} color={AppColors.gray400} />
          </TouchableOpacity>
        </View>

        {/* Part of Speech & Translation */}
        <View style={styles.sectionSpacing}>
          <Text style={styles.secondaryTextSm}>
            {base_word_detail.part_of_speech}
          </Text>
          <Text style={styles.regularTextSm}>
            <Text style={styles.fontMedium}>Translation: </Text>
            {base_word_detail.primary_translation_en}
          </Text>
          {base_word_detail.pronunciation_ipa && (
            <View style={styles.pronunciationContainer}>
              <Text style={styles.regularTextSm}>
                <Text style={styles.fontMedium}>Pronunciation: </Text>
                <Text style={styles.fontMono}>
                  {base_word_detail.pronunciation_ipa}
                </Text>
              </Text>
              <TouchableOpacity
                style={styles.pronunciationButton}
                onPress={() => {
                  /* TODO: Play audio */
                }}
              >
                <Volume2 size={16} color={AppColors.blue600} />
              </TouchableOpacity>
            </View>
          )}
        </View>

        {/* Inflected Form Details */}
        {(inflected_form_details?.case ||
          inflected_form_details?.number ||
          inflected_form_details?.person ||
          inflected_form_details?.tense) && (
          <View style={[styles.infoBox, styles.sectionSpacing]}>
            <Text style={styles.infoBoxTitle}>Word Form</Text>
            <View style={styles.inflectionGrid}>
              {inflected_form_details.case && (
                <View style={styles.inflectionItem}>
                  <Text style={styles.inflectionLabel}>Case: </Text>
                  <Text style={styles.inflectionValue}>
                    {formatCase(inflected_form_details.case)}
                  </Text>
                </View>
              )}
              {inflected_form_details.number && (
                <View style={styles.inflectionItem}>
                  <Text style={styles.inflectionLabel}>Number: </Text>
                  <Text style={styles.inflectionValue}>
                    {formatCase(inflected_form_details.number)}
                  </Text>
                </View>
              )}
              {inflected_form_details.person && (
                <View style={styles.inflectionItem}>
                  <Text style={styles.inflectionLabel}>Person: </Text>
                  <Text style={styles.inflectionValue}>
                    {formatCase(inflected_form_details.person)}
                  </Text>
                </View>
              )}
              {inflected_form_details.tense && (
                <View style={styles.inflectionItem}>
                  <Text style={styles.inflectionLabel}>Tense: </Text>
                  <Text style={styles.inflectionValue}>
                    {formatCase(inflected_form_details.tense)}
                  </Text>
                </View>
              )}
            </View>
          </View>
        )}

        {/* Explanation */}
        {specific_explanation_en && (
          <View style={styles.sectionSpacing}>
            <Text style={styles.subHeader}>Explanation</Text>
            <Text style={styles.paragraphText}>{specific_explanation_en}</Text>
          </View>
        )}

        {/* Footer Actions */}
        <View style={styles.footerActions}>
          <TouchableOpacity
            style={styles.learnMoreButton}
            onPress={() => onLearnMoreWord && onLearnMoreWord(base_word_detail)}
          >
            <BookOpen
              size={14}
              color={AppColors.blue600}
              style={styles.buttonIcon}
            />
            <Text style={styles.learnMoreButtonText}>See full details</Text>
          </TouchableOpacity>
          {onSaveWord && (
            <TouchableOpacity
              style={[styles.saveButtonBase, styles.saveButtonWord]}
              onPress={() => onSaveWord(base_word_detail)}
            >
              <Save
                size={14}
                color={AppColors.blue800}
                style={styles.buttonIcon}
              />
              <Text
                style={[styles.saveButtonTextBase, styles.saveButtonTextWord]}
              >
                Save Word
              </Text>
            </TouchableOpacity>
          )}
        </View>
      </>
    )
  }

  const renderGrammarDetails = () => {
    if (!grammarOccurrenceData || !grammarOccurrenceData.grammar_detail)
      return null
    const { grammar_detail, specific_explanation_en, original_token_phrase } =
      grammarOccurrenceData

    const cefrStyle = getCefrStyle(grammar_detail.cefr_level)

    return (
      <>
        {/* Header */}
        <View style={styles.popoverHeader}>
          <View style={styles.titleContainer}>
            <Text style={styles.titleText}>{grammar_detail.name_en}</Text>
            <View
              style={[
                styles.cefrBadge,
                { backgroundColor: cefrStyle.backgroundColor }
              ]}
            >
              <Text style={[styles.cefrBadgeText, { color: cefrStyle.color }]}>
                {grammar_detail.cefr_level || 'N/A'}
              </Text>
            </View>
          </View>
          <TouchableOpacity
            onPress={handleInternalClose}
            accessibilityLabel="Close"
            style={styles.closeButton}
          >
            <X size={18} color={AppColors.gray400} />
          </TouchableOpacity>
        </View>

        {/* Category */}
        <View style={styles.sectionSpacing}>
          <Text style={styles.secondaryTextSm}>{grammar_detail.category}</Text>
        </View>

        {/* Original Token Phrase Highlight */}
        <View style={[styles.highlightBoxAmber, styles.sectionSpacing]}>
          <Text style={styles.highlightBoxAmberTextPrimary}>
            {original_token_phrase}
          </Text>
          <Text style={styles.highlightBoxAmberTextSecondary}>
            {grammar_detail.name_fi}
          </Text>
        </View>

        {/* In This Context */}
        {specific_explanation_en && (
          <View style={styles.sectionSpacing}>
            <Text style={styles.subHeader}>In This Context</Text>
            <Text style={styles.paragraphText}>{specific_explanation_en}</Text>
          </View>
        )}

        {/* General Rule */}
        {grammar_detail.rule_summary_en && (
          <View style={styles.sectionSpacing}>
            <Text style={styles.subHeader}>General Rule</Text>
            <Text style={styles.paragraphText}>
              {grammar_detail.rule_summary_en}
            </Text>
          </View>
        )}

        {/* Example */}
        {grammar_detail.example_fi && (
          <View style={[styles.infoBox, styles.sectionSpacing]}>
            <Text style={styles.infoBoxTitleXs}>Example</Text>
            <Text style={styles.infoBoxExampleFi}>
              {grammar_detail.example_fi}
            </Text>
            <Text style={styles.infoBoxExampleEn}>
              {grammar_detail.example_translation_en}
            </Text>
          </View>
        )}

        {/* Footer Actions */}
        <View style={styles.footerActions}>
          <TouchableOpacity
            style={styles.learnMoreButton}
            onPress={() =>
              onLearnMoreGrammar && onLearnMoreGrammar(grammar_detail)
            }
          >
            <BookOpen
              size={14}
              color={AppColors.blue600}
              style={styles.buttonIcon}
            />
            <Text style={styles.learnMoreButtonText}>Learn more</Text>
          </TouchableOpacity>
          {onSaveGrammar && (
            <TouchableOpacity
              style={[styles.saveButtonBase, styles.saveButtonGrammar]}
              onPress={() => onSaveGrammar(grammar_detail)}
            >
              <Save
                size={14}
                color={AppColors.amber800}
                style={styles.buttonIcon}
              />
              <Text
                style={[
                  styles.saveButtonTextBase,
                  styles.saveButtonTextGrammar
                ]}
              >
                Save to Notes
              </Text>
            </TouchableOpacity>
          )}
        </View>
      </>
    )
  }

  let contentToRender = null
  if (contentMode === 'word') {
    contentToRender = renderWordDetails()
  } else if (contentMode === 'grammar') {
    contentToRender = renderGrammarDetails()
  }

  if (!isVisible && anim.__getValue() === 0) return null
  if (!popupPosition && isVisible) {
    // Safety check if visible but no position
    console.warn('Popup is visible but popupPosition is null. Hiding.')
    // onClose(); // This might cause a loop if isVisible is not set to false by parent immediately
    return null
  }

  if (!isMounted && !isVisible) return null

  // --- Positioning and Sizing Logic ---
  let calculatedTop = SCREEN_DIMENSIONS.height / 3 // Fallback if no popupPosition
  let calculatedLeft = SCREEN_DIMENSIONS.width / 2 - POPUP_DEFAULT_WIDTH / 2
  let calculatedWidth = POPUP_DEFAULT_WIDTH
  let calculatedContainerHeight: number | string = 'auto' // Height of the popup container
  let needsScroll = false

  if (popupPosition) {
    const targetScreenYTop = popupPosition.screenY
    const targetScreenYBottom = popupPosition.screenY + popupPosition.height
    const targetScreenXCenter = popupPosition.screenX + popupPosition.width / 2

    // Available space calculations
    let spaceAbove =
      targetScreenYTop -
      safeAreaInsets.top -
      POPUP_MARGIN_FROM_TARGET -
      SCREEN_EDGE_MARGIN
    let spaceBelow =
      SCREEN_DIMENSIONS.height -
      safeAreaInsets.bottom -
      targetScreenYBottom -
      POPUP_MARGIN_FROM_TARGET -
      SCREEN_EDGE_MARGIN

    // Attempt to subtract Android status bar height from pageY
    // This assumes measureInWindow on Android includes the status bar
    const statusBarHeight = StatusBar.currentHeight || 0
    spaceBelow -= statusBarHeight

    // Use the measured natural height of the content if available, otherwise estimate
    const currentEstimatedContentHeight =
      contentNaturalHeight || SCREEN_DIMENSIONS.height * 0.3 // Estimate if not measured

    let positionPreference: 'below' | 'above' =
      targetScreenYTop < SCREEN_DIMENSIONS.height / 2 ? 'below' : 'above'

    let availableHeightForPopup: number

    if (positionPreference === 'above' && spaceAbove >= 50) {
      // Prefer above if target is in bottom half & some space
      calculatedTop = targetScreenYTop - POPUP_MARGIN_FROM_TARGET // Anchor bottom of popup to top of target
      availableHeightForPopup = spaceAbove
      // Adjust 'top' if content height is known, to make bottom align with target's top
      if (contentNaturalHeight) {
        calculatedTop =
          targetScreenYTop -
          Math.min(contentNaturalHeight, availableHeightForPopup) -
          POPUP_MARGIN_FROM_TARGET
      }
    } else {
      // Default to below or if above doesn't have enough initial space
      calculatedTop = targetScreenYBottom + POPUP_MARGIN_FROM_TARGET
      availableHeightForPopup = spaceBelow
    }

    // Determine final container height and if scroll is needed
    if (contentNaturalHeight && contentNaturalHeight > 0) {
      if (contentNaturalHeight <= availableHeightForPopup) {
        calculatedContainerHeight = contentNaturalHeight // Fit content exactly
        needsScroll = false
      } else {
        calculatedContainerHeight = availableHeightForPopup // Constrain to available space
        needsScroll = true
      }
    } else {
      // Content not measured yet, or zero height content
      // Use available space but cap it to a reasonable default max, allow scroll if it might exceed
      calculatedContainerHeight = Math.min(
        availableHeightForPopup,
        SCREEN_DIMENSIONS.height * POPUP_MAX_HEIGHT_PERCENT
      )
      needsScroll = true // Assume scroll might be needed if content height is unknown
    }

    // Clamp top position
    calculatedTop = Math.max(
      calculatedTop,
      safeAreaInsets.top + SCREEN_EDGE_MARGIN
    )
    // Ensure bottom of popup (if its height is known) doesn't go off screen
    const finalPopupHeight =
      typeof calculatedContainerHeight === 'number'
        ? calculatedContainerHeight
        : SCREEN_DIMENSIONS.height * 0.3
    if (
      calculatedTop + finalPopupHeight >
      SCREEN_DIMENSIONS.height - safeAreaInsets.bottom - SCREEN_EDGE_MARGIN
    ) {
      calculatedTop =
        SCREEN_DIMENSIONS.height -
        safeAreaInsets.bottom -
        SCREEN_EDGE_MARGIN -
        finalPopupHeight
      // Re-clamp if this pushes it too high
      calculatedTop = Math.max(
        calculatedTop,
        safeAreaInsets.top + SCREEN_EDGE_MARGIN
      )
    }

    // Horizontal
    calculatedWidth = Math.min(
      POPUP_DEFAULT_WIDTH,
      SCREEN_DIMENSIONS.width * POPUP_MAX_WIDTH_PERCENT - 2 * SCREEN_EDGE_MARGIN
    )
    calculatedLeft = targetScreenXCenter - calculatedWidth / 2
    if (calculatedLeft < SCREEN_EDGE_MARGIN) calculatedLeft = SCREEN_EDGE_MARGIN
    if (
      calculatedLeft + calculatedWidth >
      SCREEN_DIMENSIONS.width - SCREEN_EDGE_MARGIN
    ) {
      calculatedLeft =
        SCREEN_DIMENSIONS.width - calculatedWidth - SCREEN_EDGE_MARGIN
    }
  }
  // --- End Positioning and Sizing Logic ---

  const animatedStyle = {
    opacity: anim,
    transform: [
      {
        scale: anim.interpolate({ inputRange: [0, 1], outputRange: [0.95, 1] })
      }
    ],
    position: 'absolute' as 'absolute',
    top: calculatedTop,
    left: calculatedLeft,
    width: calculatedWidth,
    height: calculatedContainerHeight // Apply calculated height (can be 'auto' or a number)
  }

  return (
    <Animated.View
      style={[
        styles.popupContainer,
        isDesktop && styles.wideScreenPopup,
        animatedStyle
      ]}
      onTouchEnd={e => e.stopPropagation()}
    >
      <CustomScrollView showScrollArrows={true} showScrollShadows={true}>
        <View
          onLayout={onActualContentLayout}
          style={styles.scrollContentContainerForScrollableView}
        >
          {/* Content is now directly rendered based on mode */}
          {contentToRender}
        </View>
      </CustomScrollView>
    </Animated.View>
  )
}

const styles = StyleSheet.create({
  popupContainer: {
    backgroundColor: AppColors.white,
    borderRadius: 8, // rounded-lg
    shadowColor: AppColors.black, // shadow-lg
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2, // Softer shadow
    shadowRadius: 8,
    elevation: 5,
    borderWidth: 1,
    borderColor: AppColors.gray200,
    overflow: 'hidden',
    zIndex: 3 // Ensure it's above article controls
  },
  wideScreenPopup: {
    // Example for isDesktop, can be adjusted
    width: POPUP_WIDTH * 1.2 // Slightly wider on "desktop"
  },
  scrollContentContainerForScrollableView: {
    padding: 16, // p-4
    paddingTop: 0
  },
  popoverHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingTop: 12, // Padding for header
    paddingBottom: 8, // Padding for header
    borderBottomWidth: 1,
    borderBottomColor: AppColors.gray100,
    marginBottom: 12 // mb-3
  },
  titleContainer: {
    flexDirection: 'row',
    alignItems: 'baseline',
    gap: 8, // gap-2
    flexShrink: 1 // Allow title to shrink if too long
  },
  titleText: {
    fontSize: 18, // text-lg
    fontWeight: 'bold', // font-bold
    color: AppColors.gray900
  },
  cefrBadge: {
    paddingHorizontal: 8, // px-2
    paddingVertical: 2, // py-0.5
    borderRadius: 9999 // rounded-full
  },
  cefrBadgeText: {
    fontSize: 12, // text-xs
    fontWeight: '500' // Tailwind default for such badges often implies medium
  },
  closeButton: {
    padding: 4 // For easier tap
  },
  sectionSpacing: {
    marginBottom: 12 // mb-3
  },
  // Text styles
  secondaryTextSm: {
    // e.g., part of speech, category
    fontSize: 14, // text-sm
    color: AppColors.gray500,
    marginBottom: 2
  },
  regularTextSm: {
    // e.g., translation
    fontSize: 14, // text-sm
    color: AppColors.gray700
  },
  fontMedium: {
    fontWeight: '500'
  },
  fontMono: {
    // For IPA
    // Ensure you have a monospace font in your project or use platform defaults
    fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace'
  },
  pronunciationContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 4 // mt-1
  },
  pronunciationButton: {
    marginLeft: 8 // ml-2
  },
  // Info Box (Word Form / Grammar Example)
  infoBox: {
    backgroundColor: AppColors.gray50,
    padding: 8, // p-2
    borderRadius: 6 // rounded-md
  },
  infoBoxTitle: {
    // For "Word Form"
    fontSize: 14, // text-sm
    fontWeight: '500',
    color: AppColors.gray700,
    marginBottom: 4 // mb-1
  },
  infoBoxTitleXs: {
    // For "Example" (Grammar)
    fontSize: 12, // text-xs
    fontWeight: '500',
    color: AppColors.gray700,
    marginBottom: 4 // mb-1
  },
  inflectionGrid: {
    // For Word Form details
    // Simulating grid cols-2, gap-1
    // No direct grid in RN, use flex or specific layout
  },
  inflectionItem: {
    flexDirection: 'row',
    marginBottom: 2
  },
  inflectionLabel: {
    fontSize: 12, // text-xs
    color: AppColors.gray500,
    marginRight: 4
  },
  inflectionValue: {
    fontSize: 12, // text-xs
    color: AppColors.gray700, // Text color for value
    fontWeight: '500'
  },
  infoBoxExampleFi: {
    // Grammar example FI
    fontSize: 14, // text-sm
    fontWeight: '500',
    color: AppColors.gray800
  },
  infoBoxExampleEn: {
    // Grammar example EN
    fontSize: 12, // text-xs
    color: AppColors.gray600,
    marginTop: 2 // mt-0.5
  },
  // Highlight Box (Grammar Original Phrase)
  highlightBoxAmber: {
    backgroundColor: AppColors.amber50,
    padding: 12, // p-3
    borderRadius: 6 // rounded-md
  },
  highlightBoxAmberTextPrimary: {
    fontSize: 14, // text-sm
    color: AppColors.amber800,
    fontWeight: '500'
  },
  highlightBoxAmberTextSecondary: {
    fontSize: 12, // text-xs
    color: AppColors.amber700,
    marginTop: 4 // mt-1
  },
  // Explanation / Rule Section
  subHeader: {
    // For "In This Context", "General Rule", "Explanation"
    fontSize: 14, // text-sm
    fontWeight: '500',
    color: AppColors.gray700,
    marginBottom: 4 // mb-1
  },
  paragraphText: {
    // For explanation text, rule summary
    fontSize: 14, // text-sm
    color: AppColors.gray600,
    lineHeight: 20
  },
  // Footer Actions
  footerActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 16, // mt-4
    borderTopWidth: 1,
    borderTopColor: AppColors.gray100, // Added a subtle separator
    paddingTop: 12 // Added padding for separator
  },
  learnMoreButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 4, // Make tappable area decent
    paddingHorizontal: 2
  },
  learnMoreButtonText: {
    fontSize: 12, // text-xs
    color: AppColors.blue600,
    fontWeight: '500'
  },
  buttonIcon: {
    marginRight: 4 // mr-1 for learn more, gap-1 implies spacing for save
  },
  saveButtonBase: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 6, // py-1 (approx, 6 is more tappable)
    paddingHorizontal: 12, // px-3
    borderRadius: 9999 // rounded-full
  },
  saveButtonTextBase: {
    fontSize: 14, // text-sm
    fontWeight: '500',
    marginLeft: 4 // for gap-1
  },
  saveButtonWord: {
    backgroundColor: AppColors.blue100
  },
  saveButtonTextWord: {
    color: AppColors.blue800
  },
  saveButtonGrammar: {
    backgroundColor: AppColors.amber100
  },
  saveButtonTextGrammar: {
    color: AppColors.amber800
  }
})

```
src/components/reader/TranslationModal.tsx
```
import React, { useRef, useEffect, useCallback } from 'react'
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  Animated,
  Dimensions,
  Platform
} from 'react-native'
import { X, Volume2 } from 'lucide-react-native'
import { Colors } from '@constants/Colors'
import { ArticleParagraph } from '@features/articles/types' // Your paragraph type

interface TranslationModalProps {
  isVisible: boolean
  selectedParagraph: ArticleParagraph | null
  onClose: () => void
  onSaveVocabulary: (paragraphText: string, translationText: string) => void // More specific
  onPlayAudioSelection?: (text: string) => void // Optional: if you want to play selected text
  isDesktop?: boolean
}

const MODAL_ANIMATION_DURATION = 300
const MODAL_CLOSE_DURATION = 200

export const TranslationModal: React.FC<TranslationModalProps> = ({
  isVisible,
  selectedParagraph,
  onClose,
  onSaveVocabulary,
  onPlayAudioSelection,
  isDesktop = false
}) => {
  const translateAnimation = useRef(new Animated.Value(0)).current

  useEffect(() => {
    if (isVisible && selectedParagraph) {
      Animated.timing(translateAnimation, {
        toValue: 1,
        duration: MODAL_ANIMATION_DURATION,
        useNativeDriver: true
      }).start()
    } else {
      // This handles initial state or when isVisible becomes false externally
      // The onClose prop itself will also trigger this if called via the X button
      Animated.timing(translateAnimation, {
        toValue: 0,
        duration: MODAL_CLOSE_DURATION,
        useNativeDriver: true
      }).start()
    }
  }, [isVisible, selectedParagraph, translateAnimation])

  const translateY = translateAnimation.interpolate({
    inputRange: [0, 1],
    outputRange: [Dimensions.get('window').height * 0.6, 0] // Animate from bottom
  })

  const handleInternalClose = useCallback(() => {
    // Animate out then call onClose prop
    Animated.timing(translateAnimation, {
      toValue: 0,
      duration: MODAL_CLOSE_DURATION,
      useNativeDriver: true
    }).start(() => {
      onClose()
    })
  }, [translateAnimation, onClose])

  const handleSave = useCallback(() => {
    if (selectedParagraph) {
      onSaveVocabulary(
        selectedParagraph.original_text_fi,
        selectedParagraph.translation_en
      )
      // Optionally close after saving, or let parent decide
      // handleInternalClose();
    }
  }, [selectedParagraph, onSaveVocabulary])

  const handlePlayAudio = useCallback(() => {
    if (selectedParagraph && onPlayAudioSelection) {
      onPlayAudioSelection(selectedParagraph.original_text_fi)
    } else if (selectedParagraph) {
      alert(
        `Play audio for: "${selectedParagraph.original_text_fi}" (Not Implemented)`
      )
    }
  }, [selectedParagraph, onPlayAudioSelection])

  if (!isVisible || !selectedParagraph) {
    return null // Don't render if not visible or no paragraph selected
  }

  return (
    <View style={styles.modalOverlay}>
      <TouchableOpacity
        style={styles.modalBackdrop}
        onPress={handleInternalClose}
        activeOpacity={1} // Full opacity backdrop
      />
      <Animated.View
        style={[
          styles.translationModal,
          { transform: [{ translateY }] },
          isDesktop && styles.wideScreenModal
        ]}
      >
        <View style={styles.modalHeader}>
          <Text style={styles.modalTitle}>Translate</Text>
          <TouchableOpacity
            onPress={handleInternalClose}
            accessibilityLabel="Close translation modal"
          >
            <X size={20} color={Colors.light.text} />
          </TouchableOpacity>
        </View>

        <ScrollView
          // showsVerticalScrollIndicator={true}
          bounces={false}
          style={styles.modalContentScroll}
        >
          <View style={styles.originalTextContainer}>
            <Text style={styles.originalText}>
              {selectedParagraph.original_text_fi}
            </Text>
            <TouchableOpacity
              style={styles.audioButton}
              onPress={handlePlayAudio}
              accessibilityLabel="Play original text audio"
            >
              <Volume2 size={18} color={Colors.light.primary} />
            </TouchableOpacity>
          </View>
          <View style={styles.translationContainer}>
            <Text style={styles.translationText}>
              {selectedParagraph.translation_en}
            </Text>
          </View>
        </ScrollView>

        <View style={styles.modalActions}>
          <TouchableOpacity
            style={styles.actionButton}
            onPress={handleSave}
            accessibilityRole="button"
          >
            <Text style={styles.actionButtonText}>Save to Vocabulary</Text>
          </TouchableOpacity>
        </View>
      </Animated.View>
    </View>
  )
}

// Styles are copied and adapted from ArticleScreen.tsx
const styles = StyleSheet.create({
  modalOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'flex-end',
    alignItems: 'center'
    // backgroundColor: 'rgba(0, 0, 0, 0.5)', // Moved to backdrop
  },
  modalBackdrop: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.5)'
  },
  translationModal: {
    backgroundColor: Colors.light.background,
    borderTopLeftRadius: 16,
    borderTopRightRadius: 16,
    paddingHorizontal: 20,
    paddingTop: 20,
    paddingBottom: Platform.OS === 'ios' ? 30 : 20, // Adjust padding for different OS
    width: '100%',
    maxHeight: '60%', // Max height of the modal
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -3 },
    shadowOpacity: 0.2,
    shadowRadius: 5,
    elevation: 10 // For Android shadow
  },
  wideScreenModal: {
    maxWidth: 600, // Max width on desktop
    borderRadius: 16, // Round all corners on desktop
    marginBottom: 40, // Margin from bottom on desktop
    maxHeight: '70%'
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
    borderBottomWidth: 1,
    borderBottomColor: Colors.light.border,
    paddingBottom: 10
  },
  modalTitle: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 18,
    color: Colors.light.text
  },
  modalContentScroll: {
    flexGrow: 0 // Prevent ScrollView from taking all available height inside the maxHeight modal
  },
  originalTextContainer: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    flexDirection: 'row',
    alignItems: 'flex-start',
    justifyContent: 'space-between'
  },
  originalText: {
    fontFamily: 'Inter-Regular',
    fontSize: 16,
    color: Colors.light.text,
    flex: 1,
    marginRight: 8,
    lineHeight: 24
  },
  translationContainer: {
    backgroundColor: Colors.light.backgroundLight,
    borderRadius: 12,
    padding: 16,
    marginBottom: 20,
    minHeight: 60
  },
  translationText: {
    fontFamily: 'Inter-Regular',
    fontSize: 16,
    color: Colors.light.text,
    lineHeight: 24
  },
  audioButton: {
    padding: 4 // Hit area
  },
  modalActions: {
    flexDirection: 'row',
    justifyContent: 'center',
    paddingTop: 10, // Add some space above the button
    borderTopWidth: 1,
    borderTopColor: Colors.light.border,
    marginTop: 'auto' // Push actions to the bottom if content is short
  },
  actionButton: {
    backgroundColor: Colors.light.primary,
    borderRadius: 8,
    paddingVertical: 12,
    paddingHorizontal: 20,
    alignItems: 'center',
    justifyContent: 'center',
    flex: 1, // Make button take available width in its container
    maxWidth: 300, // Max width for the button
    alignSelf: 'center'
  },
  actionButtonText: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 14,
    color: Colors.common.white
  }
})

```
src/components/ui/IconSymbol.ios.tsx
```
import { SymbolView, SymbolViewProps, SymbolWeight } from 'expo-symbols';
import { StyleProp, ViewStyle } from 'react-native';

export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = 'regular',
}: {
  name: SymbolViewProps['name'];
  size?: number;
  color: string;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return (
    <SymbolView
      weight={weight}
      tintColor={color}
      resizeMode="scaleAspectFit"
      name={name}
      style={[
        {
          width: size,
          height: size,
        },
        style,
      ]}
    />
  );
}

```
src/components/ui/IconSymbol.tsx
```
// This file is a fallback for using MaterialIcons on Android and web.

import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { SymbolWeight } from 'expo-symbols';
import React from 'react';
import { OpaqueColorValue, StyleProp, ViewStyle } from 'react-native';

// Add your SFSymbol to MaterialIcons mappings here.
const MAPPING = {
  // See MaterialIcons here: https://icons.expo.fyi
  // See SF Symbols in the SF Symbols app on Mac.
  'house.fill': 'home',
  'paperplane.fill': 'send',
  'chevron.left.forwardslash.chevron.right': 'code',
  'chevron.right': 'chevron-right',
} as Partial<
  Record<
    import('expo-symbols').SymbolViewProps['name'],
    React.ComponentProps<typeof MaterialIcons>['name']
  >
>;

export type IconSymbolName = keyof typeof MAPPING;

/**
 * An icon component that uses native SFSymbols on iOS, and MaterialIcons on Android and web. This ensures a consistent look across platforms, and optimal resource usage.
 *
 * Icon `name`s are based on SFSymbols and require manual mapping to MaterialIcons.
 */
export function IconSymbol({
  name,
  size = 24,
  color,
  style,
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return <MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} />;
}

```
src/components/ui/TabBarBackground.ios.tsx
```
import { useBottomTabBarHeight } from '@react-navigation/bottom-tabs';
import { BlurView } from 'expo-blur';
import { StyleSheet } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

export default function BlurTabBarBackground() {
  return (
    <BlurView
      // System chrome material automatically adapts to the system's theme
      // and matches the native tab bar appearance on iOS.
      tint="systemChromeMaterial"
      intensity={100}
      style={StyleSheet.absoluteFill}
    />
  );
}

export function useBottomTabOverflow() {
  const tabHeight = useBottomTabBarHeight();
  const { bottom } = useSafeAreaInsets();
  return tabHeight - bottom;
}

```
src/components/ui/TabBarBackground.tsx
```
// This is a shim for web and Android where the tab bar is generally opaque.
export default undefined;

export function useBottomTabOverflow() {
  return 0;
}

```
src/components/home/DailyGoalCard.tsx
```
import React from 'react'
import { View, Text, StyleSheet } from 'react-native'
import { useSelector } from 'react-redux'
import { Colors } from '@constants/Colors'
import { selectProgressSummary } from '@features/progress/progressSlice'
import { ProgressSummary } from '@features/progress/types'
import { FlameIcon } from '@/assets/svgs/streak-flame'

function getTodayDayName():
  | 'Mon'
  | 'Tue'
  | 'Wed'
  | 'Thu'
  | 'Fri'
  | 'Sat'
  | 'Sun' {
  const days: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'] = [
    'Sun',
    'Mon',
    'Tue',
    'Wed',
    'Thu',
    'Fri',
    'Sat'
  ]
  const jsDayIndex = new Date().getDay()
  const dayMap: {
    [key: number]: 'Mon' | 'Tue' | 'Wed' | 'Thu' | 'Fri' | 'Sat' | 'Sun'
  } = {
    0: 'Sun',
    1: 'Mon',
    2: 'Tue',
    3: 'Wed',
    4: 'Thu',
    5: 'Fri',
    6: 'Sat'
  }
  return dayMap[jsDayIndex]
}

export function DailyGoalCard(): React.ReactElement | null {
  const progressSummary: ProgressSummary | null = useSelector(
    selectProgressSummary
  )

  if (!progressSummary) {
    return (
      <View style={styles.cardBase}>
        <Text style={styles.dailyGoalTitle}>Daily Study Goal</Text>
        <View style={styles.progressBarContainer}>
          <View style={[styles.progressBar, { width: `0%` }]} />
        </View>
        <View style={styles.progressTextsContainer}>
          <Text style={styles.progressTextMain}>0 / 0 min today</Text>
          <Text style={styles.progressTextPercent}>0%</Text>
        </View>
      </View>
    )
  }

  const todayDayName = getTodayDayName()
  const todayActivity = progressSummary.weekly_activity.find(
    activity => activity.day === todayDayName
  )
  const timeStudiedTodayMinutes = todayActivity ? todayActivity.minutes : 0

  const averageDailyGoalMinutes = Math.max(
    1,
    Math.round(progressSummary.total_study_time_minutes / 7) || 20
  )

  let progressPercentRaw = 0
  if (averageDailyGoalMinutes > 0) {
    progressPercentRaw =
      (timeStudiedTodayMinutes / averageDailyGoalMinutes) * 100
  }

  const displayProgressPercent = Math.min(progressPercentRaw, 100)
  const hasExceededGoal = progressPercentRaw > 100
  const showFireEmoji = progressPercentRaw >= 80

  return (
    <View style={styles.cardBase}>
      <Text style={styles.dailyGoalTitle}>Daily Study Goal</Text>
      <View style={styles.progressBarOuterWrapper}>
        <View style={styles.progressBarContainer}>
          <View
            style={[
              styles.progressBar,
              { width: `${displayProgressPercent}%` },
              hasExceededGoal && {
                backgroundColor: Colors.light.accentYellow,
                opacity: 0.4
              }
            ]}
          />
          {hasExceededGoal && (
            <View style={styles.brokenBarEndContainer}>
              <FlameIcon
                width={24}
                height={24}
                color={Colors.light.accentOrange}
              />
            </View>
          )}
        </View>
      </View>
      <View style={styles.progressTextsContainer}>
        <Text style={styles.progressTextMain}>
          {timeStudiedTodayMinutes} / {averageDailyGoalMinutes} min today
        </Text>
        <View style={styles.percentAndEmojiContainer}>
          <Text style={styles.progressTextPercent}>
            {Math.round(progressPercentRaw)}%
          </Text>
          {showFireEmoji && !hasExceededGoal && (
            <FlameIcon
              width={18}
              height={18}
              color={Colors.light.accentOrange}
            />
          )}
        </View>
      </View>
    </View>
  )
}

const styles = StyleSheet.create({
  cardBase: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 20,
    paddingVertical: 16,
    paddingHorizontal: 20,
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.08,
    shadowRadius: 12,
    elevation: 4,
    marginBottom: 24
  },
  dailyGoalTitle: {
    fontFamily: 'Inter-Bold',
    color: Colors.light.text,
    marginBottom: 12,
    fontSize: 18,
    textAlign: 'left'
  },
  progressBarOuterWrapper: {
    marginBottom: 8
  },
  progressBarContainer: {
    width: '100%',
    backgroundColor: Colors.light.dailyGoalTrack,
    borderRadius: 10,
    height: 12,
    overflow: 'visible',
    position: 'relative'
  },
  progressBar: {
    backgroundColor: Colors.light.dailyGoalProgress,
    height: '100%',
    borderRadius: 10,
    zIndex: 1
  },
  brokenBarEndContainer: {
    position: 'absolute',
    right: 0,
    top: 0,
    bottom: 0,
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: -6,
    marginTop: -4,
    zIndex: 2
  },
  brokenBarSegment: {
    width: 6,
    height: '120%',
    backgroundColor: Colors.light.dailyGoalProgress,
    transform: [{ skewX: '-15deg' }],
    marginRight: -2
  },
  brokenBarSegmentOffset: {
    height: '80%',
    transform: [{ skewX: '10deg' }]
  },
  progressTextsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 6
  },
  progressTextMain: {
    fontSize: 13,
    fontFamily: 'Inter-Medium',
    color: Colors.light.textSecondary
  },
  percentAndEmojiContainer: {
    flexDirection: 'row',
    alignItems: 'center'
  },
  progressTextPercent: {
    fontSize: 13,
    fontFamily: 'Inter-SemiBold',
    color: Colors.light.text
  }
})

```
src/components/home/FeaturedArticles.tsx
```
import React from 'react'
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native'
import { Link } from 'expo-router'
import { ChevronRight } from 'lucide-react-native'
import { Colors } from '@constants/Colors'
import { ArticleCardWithThumbnail } from '@components/reader/ArticleCardWithThumbnail'
import { CustomFlatList } from '@/components/common/CustomFlatList'
import { Article } from '@features/articles/types'
import { PaginationStateType } from '@pagination/types'
import { useResponsiveDimensions } from '@/hooks/useResponsiveDimensions'
import { ArticleCardWithThumbnailSkeleton } from '@/components/skeletons/ArticleCardWithThumbnailSkeleton'

interface FeaturedArticlesProps {
  articles: Article[]
  pagination: PaginationStateType
  onLoadMore?: () => void
  title?: string
  viewAllPath?: string
  marginHorizontal?: number
}

const NUM_SKELETONS_INITIAL = 3

export function FeaturedArticles({
  articles,
  pagination,
  onLoadMore,
  title = 'Featured Articles',
  viewAllPath = '/(main)/(tabs)/reader',
  marginHorizontal = 0
}: FeaturedArticlesProps): React.ReactElement | null {
  const { isMobile } = useResponsiveDimensions()

  const showInitialLoadingSkeleton =
    pagination.isLoading && articles.length === 0 && !pagination.error
  const showLoadMoreSkeleton =
    pagination.isLoading && articles.length > 0 && pagination.hasMore

  const renderItem = ({ item }: { item: Article }) => (
    <View style={styles.articleCardContainer}>
      <ArticleCardWithThumbnail
        article={item}
        size={isMobile ? 'small' : 'medium'}
      />
    </View>
  )

  const renderSkeletonItem = (keySuffix: string | number) => (
    <View style={styles.articleCardContainer} key={keySuffix}>
      <ArticleCardWithThumbnailSkeleton size={isMobile ? 'small' : 'medium'} />
    </View>
  )

  if (pagination.error && articles.length === 0) {
    return (
      <View style={styles.section}>
        <View style={[styles.sectionHeader, { marginHorizontal }]}>
          <Text style={styles.sectionTitle}>{title}</Text>
        </View>
        <Text style={[styles.errorText, { marginHorizontal }]}>
          Could not load {title.toLowerCase()}. Please try again later.
        </Text>
      </View>
    )
  }

  if (
    !showInitialLoadingSkeleton &&
    articles.length === 0 &&
    !pagination.error
  ) {
    return null
  }

  return (
    <View style={styles.section}>
      <View style={[styles.sectionHeader, { marginHorizontal }]}>
        <Text style={styles.sectionTitle}>{title}</Text>
        {(!showInitialLoadingSkeleton || articles.length > 0) && (
          <Link href={viewAllPath as any} asChild>
            <TouchableOpacity
              style={styles.seeAllButton}
              accessibilityRole="link"
              accessibilityLabel={`See all ${title.toLowerCase()}`}
            >
              <Text style={styles.seeAllText}>See all</Text>
              <ChevronRight size={16} color={Colors.common.gray[500]} />
            </TouchableOpacity>
          </Link>
        )}
      </View>

      {showInitialLoadingSkeleton ? (
        <View style={[styles.skeletonContainer, { marginHorizontal }]}>
          {Array.from({ length: NUM_SKELETONS_INITIAL }).map((_, index) =>
            renderSkeletonItem(`initial-${index}`)
          )}
        </View>
      ) : (
        <CustomFlatList
          horizontal
          data={articles}
          renderItem={renderItem}
          keyExtractor={item => item.id}
          showsHorizontalScrollIndicator
          showScrollShadows={false}
          onEndReached={onLoadMore}
          onEndReachedThreshold={1}
          contentContainerStyle={{
            paddingHorizontal: marginHorizontal,
            paddingVertical: 4
          }}
          ListFooterComponent={
            showLoadMoreSkeleton ? renderSkeletonItem('footer-loading') : null
          }
        />
      )}
    </View>
  )
}

const styles = StyleSheet.create({
  section: {
    marginBottom: 28
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 4
  },
  sectionTitle: {
    fontFamily: 'Inter-Bold',
    color: Colors.light.text,
    fontSize: 20
  },
  seeAllButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 4
  },
  seeAllText: {
    fontFamily: 'Inter-Medium',
    fontSize: 14,
    color: Colors.common.gray[500],
    marginRight: 2
  },
  skeletonContainer: {
    flexDirection: 'row',
    paddingLeft: 2,
    paddingVertical: 4
  },
  articleCardContainer: {
    marginRight: 8,
    marginLeft: 3,
    marginVertical: 6,
    flex: 1
  },
  errorText: {
    fontFamily: 'Inter-Regular',
    color: Colors.light.textSecondary,
    fontSize: 14,
    textAlign: 'center',
    paddingVertical: 20,
    minHeight: 180,
    justifyContent: 'center',
    alignItems: 'center'
  }
})

```
src/components/home/HomeHeader.tsx
```
import React from 'react'
import { View, Text, StyleSheet, TouchableOpacity, Image } from 'react-native'
import { useRouter } from 'expo-router'
import { LogIn } from 'lucide-react-native'
import { Colors } from '@constants/Colors'
import { User } from '@features/auth/types'
import { nameParser } from '@utils/string'

interface HomeHeaderProps {
  user: User | null
}

export const HomeHeader: React.FC<HomeHeaderProps> = ({ user }) => {
  const router = useRouter()

  return (
    <View style={styles.profileSection}>
      <View style={styles.headerTextContainer}>
        {user ? (
          <>
            <Text style={styles.headerTitle}>
              Hei, {nameParser(user.displayName || 'User', { ellipsis: '' })}!
              
            </Text>
            <Text style={styles.headerSubtitle}>
              Let's learn some Finnish today
            </Text>
          </>
        ) : (
          <>
            <Text style={styles.headerTitle}>Tervetuloa! </Text>
            <Text style={styles.headerSubtitle}>
              Login to track your progress
            </Text>
          </>
        )}
      </View>
      {user ? (
        <TouchableOpacity
          onPress={() => router.push('/(main)/(tabs)/profile')}
          accessibilityLabel="View your profile"
          accessibilityRole="button"
        >
          <Image
            source={{
              uri:
                user.avatarUrl || `https://picsum.photos/seed/${user.id}/80/80` // Use avatarUrl if available
            }}
            style={styles.profileImage}
          />
        </TouchableOpacity>
      ) : (
        <TouchableOpacity
          onPress={() => router.push('/(auth)/login')}
          style={styles.loginButton}
          accessibilityLabel="Login to your account"
          accessibilityRole="button"
        >
          <LogIn size={20} color={Colors.light.primary} />
          <Text style={styles.loginButtonText}>Login</Text>
        </TouchableOpacity>
      )}
    </View>
  )
}

// Styles copied from HomeScreen
const styles = StyleSheet.create({
  profileSection: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 24
  },
  headerTextContainer: { flex: 1, marginRight: 16 },
  headerTitle: {
    fontFamily: 'Inter-Bold',
    fontSize: 24,
    color: Colors.light.text
  },
  headerSubtitle: {
    fontFamily: 'Inter-Regular',
    fontSize: 14,
    color: Colors.light.textSecondary
  },
  profileImage: { width: 50, height: 50, borderRadius: 25 },
  loginButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.light.cardBackground,
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: Colors.light.border
  },
  loginButtonText: {
    marginLeft: 6,
    color: Colors.light.primary,
    fontWeight: '500', // Corresponds to Inter-Medium
    fontFamily: 'Inter-Medium'
  }
})

```
src/components/home/LearningModuleCard.tsx
```
import React from 'react'
import { View, Text, StyleSheet, TouchableOpacity, Image } from 'react-native'
import { Colors } from '@constants/Colors'

interface LearningModuleProps {
  title: string
  description: string
  iconUrl: string
  backgroundColor: string
  onPress: () => void
}

export function LearningModuleCard({
  title,
  description,
  iconUrl,
  backgroundColor,
  onPress
}: LearningModuleProps): React.ReactElement {
  return (
    <TouchableOpacity
      style={[styles.moduleCardBase, { backgroundColor }]}
      onPress={onPress}
      activeOpacity={0.8}
    >
      <View style={styles.moduleIconContainer}>
        <Image source={{ uri: iconUrl }} style={styles.moduleIconImage} />
      </View>
      <Text style={styles.moduleTitle}>{title}</Text>
      <Text style={styles.moduleDescription} numberOfLines={2}>
        {description}
      </Text>
    </TouchableOpacity>
  )
}

const styles = StyleSheet.create({
  moduleCardBase: {
    borderRadius: 18,
    padding: 16,
    borderWidth: 1,
    borderColor: Colors.light.borderStrong,
    alignItems: 'flex-start',
    width: '48%',
    marginBottom: 16,
    minHeight: 150
  },
  moduleIconContainer: {
    width: '100%',
    height: 55,
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 4,
    marginBottom: 8,
    overflow: 'hidden'
  },
  moduleIconImage: {
    width: '90%',
    height: '90%',
    resizeMode: 'contain',
    textAlign: 'center'
  },
  moduleTitle: {
    fontFamily: 'Inter-Bold',
    color: Colors.light.text,
    fontSize: 16,
    marginBottom: 4,
    width: '100%',
    textAlign: 'center'
  },
  moduleDescription: {
    fontFamily: 'Inter-Regular',
    color: Colors.light.text,
    opacity: 0.8,
    fontSize: 12,
    lineHeight: 16,
    width: '100%',
    textAlign: 'center'
  }
})

```
src/components/home/ProgressCard.tsx
```
import React from 'react'
import { View, Text, StyleSheet } from 'react-native'
import { Colors } from '@constants/Colors'

type ProgressCardProps = {
  icon: React.ReactNode
  title: string
  subtitle: string
  progress: number // 0 to 1
  color: string
}

export const ProgressCard: React.FC<ProgressCardProps> = ({
  icon,
  title,
  subtitle,
  progress,
  color
}) => {
  // Ensure progress is between 0 and 1
  const clampedProgress = Math.max(0, Math.min(1, progress))
  const progressPercent = Math.round(clampedProgress * 100)

  return (
    <View style={styles.card}>
      <View style={styles.cardHeader}>
        <View style={[styles.iconContainer, { backgroundColor: color + '15' }]}>
          {icon}
        </View>
        <Text style={styles.percentage}>{progressPercent}%</Text>
      </View>

      <Text style={styles.title}>{title}</Text>
      <Text style={styles.subtitle}>{subtitle}</Text>

      <View style={styles.progressBarContainer}>
        <View
          style={[
            styles.progressBar,
            { width: `${progressPercent}%`, backgroundColor: color }
          ]}
        />
      </View>
    </View>
  )
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 12,
    padding: 16,
    width: '48%',
    shadowColor: Colors.light.shadow,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 2
  },
  cardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12
  },
  iconContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    alignItems: 'center',
    justifyContent: 'center'
  },
  percentage: {
    fontFamily: 'Inter-Bold',
    fontSize: 16,
    color: Colors.light.text
  },
  title: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 16,
    color: Colors.light.text,
    marginBottom: 4
  },
  subtitle: {
    fontFamily: 'Inter-Regular',
    fontSize: 14,
    color: Colors.light.textSecondary,
    marginBottom: 12
  },
  progressBarContainer: {
    height: 6,
    backgroundColor: Colors.light.backgroundLight,
    borderRadius: 3,
    overflow: 'hidden'
  },
  progressBar: {
    height: '100%',
    borderRadius: 3
  }
})

```
src/components/home/StreakCard.tsx
```
import React from 'react'
import { View, Text, StyleSheet } from 'react-native'
import { Check, Clock } from 'lucide-react-native'
import { FlameIcon } from '@/assets/svgs/streak-flame'
import { Colors } from '@constants/Colors'
import { ProgressSummary } from '@features/progress/types'

interface StreakCardProps {
  progressSummary: ProgressSummary | null
}

export const StreakCard: React.FC<StreakCardProps> = ({ progressSummary }) => {
  const currentStreak = progressSummary?.streak.current_streak_days || 0
  const weeklyActivity = progressSummary?.weekly_activity || []
  const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']

  const getDayStatus = (dayName: string, index: number) => {
    const activityDay = weeklyActivity.find(d => d.day === dayName)
    const isToday = index === (new Date().getDay() + 6) % 7
    if (isToday && currentStreak > 0) return Colors.light.streakDayCurrent
    if (activityDay && activityDay.minutes > 0)
      return Colors.light.streakDayActive
    return Colors.light.streakDayFuture
  }

  return (
    <View style={styles.cardBase}>
      <View style={styles.streakHeader}>
        <View>
          <Text style={styles.streakTitle}>Current Streak</Text>
          <Text style={styles.streakSubtitle}>Keep it going!</Text>
        </View>
        <View style={styles.streakValueContainer}>
          <FlameIcon width={24} height={24} color={Colors.light.accentOrange} />
          <Text style={styles.streakValue}>{currentStreak}</Text>
          <Text style={styles.streakDaysText}>days</Text>
        </View>
      </View>
      <View style={styles.streakDaysContainer}>
        {days.map((day, index) => (
          <View key={day} style={styles.streakDayItem}>
            <View
              style={[
                styles.streakDayCircle,
                { backgroundColor: getDayStatus(day, index) }
              ]}
            >
              {getDayStatus(day, index) === Colors.light.streakDayActive && (
                <Check size={16} color={Colors.light.primaryContent} />
              )}
              {getDayStatus(day, index) === Colors.light.streakDayCurrent && (
                <Clock size={16} color={Colors.light.primaryContent} />
              )}
            </View>
            <Text style={styles.streakDayLabel}>{day}</Text>
          </View>
        ))}
      </View>
    </View>
  )
}

const styles = StyleSheet.create({
  cardBase: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 20,
    padding: 18,
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 10,
    elevation: 5,
    marginBottom: 24
  },
  streakHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8
  },
  streakTitle: {
    fontFamily: 'Inter-Bold',
    color: Colors.light.text,
    fontSize: 17
  },
  streakSubtitle: {
    fontFamily: 'Inter-Regular',
    color: Colors.light.textSecondary,
    fontSize: 12
  },
  streakValueContainer: { flexDirection: 'row', alignItems: 'flex-end' },
  streakValue: {
    fontSize: 28,
    fontFamily: 'Inter-Bold',
    marginLeft: 6,
    color: Colors.light.text,
    lineHeight: 28
  },
  streakDaysText: {
    fontSize: 13,
    marginLeft: 4,
    color: Colors.light.textSecondary,
    fontFamily: 'Inter-Medium',
    paddingBottom: 2
  },
  streakDaysContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginTop: 16
  },
  streakDayItem: { alignItems: 'center' },
  streakDayCircle: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center'
  },
  streakDayLabel: {
    fontSize: 11,
    marginTop: 6,
    color: Colors.light.textSecondary,
    fontFamily: 'Inter-Medium'
  }
})

export default StreakCard

```
src/components/ArticleList/ArticleList.tsx
```
// src/components/ArticleList.tsx
import React from "react";
import {
  View,
  Text,
  FlatList,
  StyleSheet,
  ActivityIndicator,
  RefreshControl,
  Platform,
  Pressable,
  ListRenderItemInfo,
} from "react-native";
import { Article } from "@features/articles/types";
import { Colors } from "@constants/Colors";
import { ArticleListItem } from "./ArticleListItem"; // Import the item component

interface ArticleListProps {
  articles: Article[];
  isLoading: boolean; // Combined loading state (initial or loading more)
  isInitialLoading: boolean; // Specifically for initial load screen
  error: string | null;
  onRefresh: () => void; // Callback for pull-to-refresh
  onEndReached: () => void; // Callback for reaching end
  ListFooterComponent: React.ReactElement | null; // Component to show at the bottom (loading indicator/end message)
  retryLoad: () => void; // Callback to retry loading on initial error
}

export const ArticleList: React.FC<ArticleListProps> = ({
  articles,
  isLoading,
  isInitialLoading,
  error,
  onRefresh,
  onEndReached,
  ListFooterComponent,
  retryLoad,
}) => {
  const isRefreshing = isLoading && !isInitialLoading; // Loading state while data exists is considered refreshing

  // --- Render Logic ---

  // 1. Initial Loading State
  if (isInitialLoading) {
    return (
      <View style={styles.centered}>
        <ActivityIndicator size="large" color={Colors.light.tint} />
        <Text style={styles.infoText}>Loading News...</Text>
      </View>
    );
  }

  // 2. Initial Load Error State
  if (error && articles.length === 0) {
    return (
      <View style={styles.centered}>
        <Text style={styles.errorText}>Error loading news:</Text>
        <Text style={styles.errorDetailText}>{error}</Text>
        <Pressable onPress={retryLoad} style={styles.retryButton}>
          <Text style={styles.retryButtonText}>Retry</Text>
        </Pressable>
      </View>
    );
  }

  // 3. Render the List (or empty state)
  const renderItem = ({ item }: ListRenderItemInfo<Article>) => (
    <ArticleListItem article={item} />
  );

  return (
    <View style={styles.container}>
      {/* Optional: Error banner for refresh failures */}
      {error && articles.length > 0 && (
        <View style={styles.errorBanner}>
          <Text style={styles.errorBannerText}>
            Update failed: {error}. Showing cached data.
          </Text>
        </View>
      )}

      <FlatList
        data={articles}
        renderItem={renderItem}
        keyExtractor={(item) => item.id} // Ensure articles have unique IDs
        contentContainerStyle={styles.listContentContainer}
        refreshControl={
          <RefreshControl
            refreshing={isRefreshing}
            onRefresh={onRefresh}
            tintColor={Colors.light.tint}
            colors={[Colors.light.tint]} // for Android
          />
        }
        onEndReached={onEndReached}
        onEndReachedThreshold={0.5} // Adjust as needed
        ListFooterComponent={ListFooterComponent} // Show loading/end indicator
        ListEmptyComponent={
          !isLoading && !error ? ( // Show only if not loading and no error
            <View style={styles.centered}>
              <Text style={styles.infoText}>No articles found.</Text>
            </View>
          ) : null
        }
        // Performance settings (optional but recommended)
        initialNumToRender={10}
        maxToRenderPerBatch={10}
        windowSize={11}
      />
    </View>
  );
};

// Styles for ArticleList container and states
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  centered: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 20,
    minHeight: 200, // Ensure empty/error states have some height
  },
  listContentContainer: {
    paddingVertical: Platform.OS === "web" ? 20 : 10,
    // Responsive horizontal padding using percentages for web
    paddingHorizontal: Platform.OS === "web" ? "10%" : 15,
  },
  infoText: {
    marginTop: 10,
    color: Colors.light.text,
    fontSize: 16,
  },
  errorText: {
    color: Colors.light.error,
    textAlign: "center",
    marginBottom: 5,
    fontSize: 16,
    fontWeight: "bold",
  },
  errorDetailText: {
    color: Colors.light.error,
    textAlign: "center",
    marginBottom: 15,
    fontSize: 14,
  },
  retryButton: {
    paddingVertical: 10,
    paddingHorizontal: 25,
    backgroundColor: Colors.light.tint,
    borderRadius: 5,
  },
  retryButtonText: {
    color: "#fff",
    fontWeight: "bold",
    fontSize: 16,
  },
  errorBanner: {
    backgroundColor: Colors.light.errorBackground, // Use a background color
    paddingVertical: 8,
    paddingHorizontal: 15,
    alignItems: "center",
  },
  errorBannerText: {
    color: Colors.light.error, // Text color matching the theme error color
    textAlign: "center",
    fontSize: 13,
  },
  footerLoadingContainer: {
    paddingVertical: 20,
  },
  footerText: {
    textAlign: "center",
    color: Colors.light.textMuted,
    paddingVertical: 20,
  },
});

```
src/components/ArticleList/ArticleListItem.tsx
```
// src/components/ArticleListItem.tsx
import React from 'react'
import { View, Text, StyleSheet, Pressable, Platform } from 'react-native'
import { Link } from 'expo-router'
import { Article } from '@features/articles/types' // Assuming type definition exists
import { Colors } from '@constants/Colors'
import { useResponsiveDimensions } from '@hooks/useResponsiveDimensions' // Can use hooks here

interface ArticleListItemProps {
  article: Article
}

export const ArticleListItem: React.FC<ArticleListItemProps> = React.memo(
  ({ article }) => {
    const { isMobile } = useResponsiveDimensions() // Use hook for styling

    // Basic validation or fallback
    if (!article) {
      return null // Or render a placeholder/error state for this item
    }

    return (
      <Link
        href={{ pathname: '/(app)/reader/[id]', params: { id: article.id } }}
        asChild
      >
        <Pressable style={styles.itemContainer}>
          <View style={styles.itemContent}>
            <Text
              style={[
                styles.itemTitle,
                isMobile ? styles.itemTitleMobile : styles.itemTitleDesktop
              ]}
            >
              {article.title || 'Untitled Article'}
            </Text>
            {article.date && ( // Conditionally render date
              <Text style={styles.itemDate}>
                {new Date(article.date).toLocaleDateString('fi-FI')}
              </Text>
            )}
            {/* Add other elements like author, snippet etc. if needed */}
          </View>
        </Pressable>
      </Link>
    )
  }
)

// Consistent styling (can be moved to a shared file later)
const styles = StyleSheet.create({
  itemContainer: {
    backgroundColor: Colors.light.background, // Use theme color
    marginBottom: 12,
    borderRadius: 8,
    overflow: 'hidden',
    borderWidth: 1,
    borderColor: Colors.light.border, // Use theme color
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 1.0,
    elevation: 1
  },
  itemContent: {
    padding: 15
  },
  itemTitle: {
    fontWeight: 'bold',
    marginBottom: 5,
    color: Colors.light.text
  },
  itemTitleMobile: { fontSize: 16 },
  itemTitleDesktop: { fontSize: 18 },
  itemDate: {
    fontSize: 12,
    color: Colors.light.textMuted, // Use a muted color
    marginBottom: 5
  }
})

```
src/components/ArticleList/index.js
```javascript
export { ArticleList } from "./ArticleList";


```
src/components/navigation/SideNavBar.tsx
```
import React from 'react'
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator
} from 'react-native'
import { useSegments, useRouter } from 'expo-router'
import { LogIn, LogOut } from 'lucide-react-native'
import { useSelector, useDispatch } from 'react-redux'
import { useSafeAreaInsets } from 'react-native-safe-area-context'

import { Colors } from '@constants/Colors'
import {
  selectIsAuthenticated,
  selectAuthStatus
} from '@features/auth/authSelectors'
import { logoutUser } from '@features/auth/authActions'
import { useRequireAuthAction } from '@hooks/useRequireAuthAction'
import { navItems } from '@/constants/navigation'
import { AppDispatch } from '@store/store'

export function SideNavBar() {
  const router = useRouter()
  const segments = useSegments()
  const insets = useSafeAreaInsets()
  const dispatch = useDispatch<AppDispatch>()

  const isAuthenticated = useSelector(selectIsAuthenticated)
  const authStatus = useSelector(selectAuthStatus)

  let activeSegmentKey: string | null = null
  if (segments.length > 0 && segments[0] === '(main)') {
    if (segments.length > 1 && segments[1] === '(tabs)') {
      activeSegmentKey = segments[2] || 'index'
    } else if (segments.length > 1) {
      activeSegmentKey = segments.slice(1).join('/')
    }
  }

  const navigateToProtected = useRequireAuthAction((path: string) => {
    router.push(path as any)
  }, 'Login required.')

  const handleLogout = () => {
    dispatch(logoutUser())
  }

  return (
    <View
      style={[
        styles.container,
        { paddingTop: insets.top + 20, paddingBottom: insets.bottom + 20 }
      ]}
    >
      <Text style={styles.logo}>Kielo</Text>

      <View style={styles.navItemsContainer}>
        {navItems.map(item => {
          const isActive = activeSegmentKey?.startsWith(item.targetSegment)
          const Icon = item.icon

          const handlePress = () => {
            if (item.protected) {
              navigateToProtected(item.path)
            } else {
              router.push(item.path as any)
            }
          }

          return (
            <TouchableOpacity
              key={item.name}
              style={[styles.navItem, isActive && styles.navItemActive]}
              onPress={handlePress}
              style={[
                styles.navItem,
                isActive && styles.navItemActive,
                item.protected && !isAuthenticated && styles.navItemDisabled
              ]}
            >
              <Icon
                size={22}
                color={
                  isActive ? Colors.light.primary : Colors.light.textSecondary
                }
                strokeWidth={isActive ? 2.5 : 2}
              />
              <Text
                style={[styles.navLabel, isActive && styles.navLabelActive]}
              >
                {item.name}
              </Text>
            </TouchableOpacity>
          )
        })}
      </View>

      <View style={styles.bottomActions}>
        {authStatus === 'loading' ? (
          <ActivityIndicator color={Colors.light.primary} />
        ) : isAuthenticated ? (
          <TouchableOpacity style={styles.actionButton} onPress={handleLogout}>
            <LogOut size={20} color={Colors.light.error} />
            <Text style={[styles.actionLabel, { color: Colors.light.error }]}>
              Logout
            </Text>
          </TouchableOpacity>
        ) : (
          <TouchableOpacity
            style={styles.actionButton}
            onPress={() => router.push('/(auth)/login')}
          >
            <LogIn size={20} color={Colors.light.primary} />
            <Text style={[styles.actionLabel, { color: Colors.light.primary }]}>
              Login
            </Text>
          </TouchableOpacity>
        )}
      </View>
    </View>
  )
}

const SIDEBAR_WIDTH = 240

const styles = StyleSheet.create({
  container: {
    width: SIDEBAR_WIDTH,
    height: '100%',
    backgroundColor: Colors.light.background,
    borderRightWidth: 1,
    borderRightColor: Colors.light.border,
    paddingHorizontal: 16,
    display: 'flex',
    flexDirection: 'column'
  },
  logo: {
    fontFamily: 'Inter-Bold',
    fontSize: 24,
    color: Colors.light.primary,
    marginBottom: 30,
    paddingLeft: 12
  },
  navItemsContainer: {
    flex: 1,
    gap: 8
  },
  navItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
    gap: 14
  },
  navItemActive: {
    backgroundColor: Colors.light.primaryLight
  },
  navItemDisabled: {
    opacity: 0.5
  },
  navLabel: {
    fontFamily: 'Inter-Medium',
    fontSize: 16,
    color: Colors.light.textSecondary
  },
  navLabelActive: {
    fontFamily: 'Inter-SemiBold',
    color: Colors.light.primary
  },
  bottomActions: {
    marginTop: 'auto',
    paddingTop: 20,
    borderTopWidth: 1,
    borderTopColor: Colors.light.border
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
    gap: 14
  },
  actionLabel: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 16
  }
})

```
src/components/skeletons/ArticleCardWithThumbnailSkeleton.tsx
```
import React from 'react'
import { View, StyleSheet } from 'react-native'
import { SkeletonBlock } from './SkeletonElements'
import { Colors } from '@constants/Colors'
import { useResponsiveDimensions } from '@/hooks/useResponsiveDimensions'

interface ArticleCardWithThumbnailSkeletonProps {
  size?: 'small' | 'medium' | 'large'
}

export function ArticleCardWithThumbnailSkeleton({
  size = 'small'
}: ArticleCardWithThumbnailSkeletonProps): React.ReactElement {
  const { isDesktop } = useResponsiveDimensions()

  const cardDimensions = React.useMemo(() => {
    let width = 220
    let imageHeight = 140
    if (size === 'medium') {
      width = isDesktop ? 280 : 240
      imageHeight = isDesktop ? 180 : 150
    } else if (size === 'large') {
      width = isDesktop ? 340 : 260
      imageHeight = isDesktop ? 220 : 170
    }
    return { width, imageHeight }
  }, [size, isDesktop])

  return (
    <View style={[styles.container, { width: cardDimensions.width }]}>
      <SkeletonBlock
        width="100%"
        height={cardDimensions.imageHeight}
        borderRadius={0}
        style={styles.imagePlaceholder}
      />
      <View style={styles.contentContainer}>
        <SkeletonBlock
          width="80%"
          height={18}
          borderRadius={4}
          style={{ marginBottom: 8 }}
        />
        <SkeletonBlock
          width="60%"
          height={18}
          borderRadius={4}
          style={{ marginBottom: 10 }}
        />
        <View style={styles.metaLine}>
          <SkeletonBlock width="40%" height={12} borderRadius={4} />
          <SkeletonBlock
            width="30%"
            height={12}
            borderRadius={4}
            style={{ marginLeft: 'auto' }}
          />
        </View>
      </View>
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 12,
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 6,
    elevation: 3,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: Colors.light.borderSubtle
  },
  imagePlaceholder: {
    backgroundColor: Colors.light.backgroundSecondary,
    borderTopLeftRadius: 12,
    borderTopRightRadius: 12
  },
  contentContainer: {
    padding: 12
  },
  metaLine: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 4
  }
})

```
src/components/skeletons/DashboardContentSkeleton.tsx
```
import React from 'react'
import { View, StyleSheet, ScrollView } from 'react-native'
import { SkeletonBlock, SkeletonCircle } from './SkeletonElements'
import { Colors } from '@/constants/Colors'

export const DashboardContentSkeleton: React.FC = React.memo(() => {
  return (
    <ScrollView
      style={styles.container}
      contentContainerStyle={styles.contentContainer}
    >
      <View style={styles.header}>
        <View style={styles.headerText}>
          <SkeletonBlock
            width="70%"
            height={28}
            borderRadius={6}
            style={{ marginBottom: 6 }}
          />
          <SkeletonBlock width="50%" height={18} borderRadius={5} />
        </View>
        <SkeletonCircle size={44} />
      </View>

      <View style={styles.card}>
        <SkeletonBlock
          width="40%"
          height={20}
          borderRadius={5}
          style={{ marginBottom: 30 }}
        />
        <View style={styles.streakBars}>
          {[...Array(7)].map((_, i) => (
            <View key={i} style={styles.barContainer}>
              <SkeletonBlock
                width={16}
                height={Math.random() * 80 + 40}
                borderRadius={5}
              />
              <SkeletonBlock
                width={20}
                height={12}
                borderRadius={5}
                style={{ marginTop: 8 }}
              />
            </View>
          ))}
        </View>
      </View>

      <View style={styles.sectionHeader}>
        <SkeletonBlock width={150} height={22} borderRadius={5} />
        <SkeletonBlock width={60} height={18} borderRadius={5} />
      </View>
      <View style={styles.progressRow}>
        <View style={[styles.card, styles.progressCard]}>
          <SkeletonBlock
            width="50%"
            height={18}
            borderRadius={5}
            style={{ marginBottom: 8 }}
          />
          <SkeletonBlock
            width="70%"
            height={14}
            borderRadius={5}
            style={{ marginBottom: 20 }}
          />
        </View>
        <View style={[styles.card, styles.progressCard]}>
          <SkeletonBlock
            width="50%"
            height={18}
            borderRadius={5}
            style={{ marginBottom: 8 }}
          />
          <SkeletonBlock
            width="70%"
            height={14}
            borderRadius={5}
            style={{ marginBottom: 20 }}
          />
        </View>
      </View>

      <View style={styles.sectionHeader}>
        <SkeletonBlock width={180} height={22} borderRadius={5} />
        <SkeletonBlock width={60} height={18} borderRadius={5} />
      </View>
      <View style={styles.articlesRow}>
        {[...Array(3)].map((_, i) => (
          <View key={i} style={[styles.card, styles.articleCard]}>
            <SkeletonBlock
              width="90%"
              height={18}
              borderRadius={5}
              style={{ marginBottom: 6 }}
            />
            <SkeletonBlock
              width="60%"
              height={18}
              borderRadius={5}
              style={{ marginBottom: 12 }}
            />
            <SkeletonBlock width="70%" height={14} borderRadius={5} />
          </View>
        ))}
      </View>

      <View style={styles.sectionHeader}>
        <SkeletonBlock width={150} height={22} borderRadius={5} />
      </View>
      <View style={[styles.card, styles.challengeCard]}>
        <SkeletonCircle size={36} />
        <View style={{ flex: 1, marginLeft: 12 }}>
          <SkeletonBlock
            width="80%"
            height={16}
            borderRadius={5}
            style={{ marginBottom: 6 }}
          />
          <SkeletonBlock width="60%" height={14} borderRadius={5} />
        </View>
        <SkeletonBlock width={10} height={16} borderRadius={5} />
      </View>
    </ScrollView>
  )
})

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff'
  },
  contentContainer: {
    padding: 20
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 30
  },
  headerText: {
    flex: 1,
    marginRight: 16
  },
  card: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
    elevation: 1,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: Colors.light.border
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 15,
    marginTop: 10
  },
  streakBars: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'flex-end',
    height: 120
  },
  barContainer: {
    alignItems: 'center'
  },
  progressRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginHorizontal: -5
  },
  progressCard: {
    flex: 1,
    marginHorizontal: 5,
    alignItems: 'flex-start'
  },
  articlesRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginHorizontal: -5
  },
  articleCard: {
    flex: 1,
    marginHorizontal: 5,
    minHeight: 120,
    alignItems: 'flex-start'
  },
  challengeCard: {
    flexDirection: 'row',
    alignItems: 'center'
  }
})

```
src/components/skeletons/DashboardSkeletonDesktop.tsx
```
import React from 'react'
import { View, StyleSheet } from 'react-native'
import { SkeletonBlock } from './SkeletonElements'
import { DashboardContentSkeleton } from './DashboardContentSkeleton'
import { Colors } from '@constants/Colors'

const SIDEBAR_WIDTH = 240

export const DashboardSkeletonDesktop: React.FC = React.memo(() => {
  return (
    <View style={styles.container}>
      <View style={styles.sidebar}>
        <SkeletonBlock
          width="60%"
          height={30}
          borderRadius={6}
          style={styles.sidebarItem}
        />
        <SkeletonBlock
          width="80%"
          height={24}
          borderRadius={4}
          style={styles.sidebarItem}
        />
        <SkeletonBlock
          width="80%"
          height={24}
          borderRadius={4}
          style={styles.sidebarItem}
        />
        <SkeletonBlock
          width="80%"
          height={24}
          borderRadius={4}
          style={styles.sidebarItem}
        />
        <SkeletonBlock
          width="80%"
          height={24}
          borderRadius={4}
          style={styles.sidebarItem}
        />
        <SkeletonBlock
          width="80%"
          height={24}
          borderRadius={4}
          style={styles.sidebarItem}
        />
        <View style={{ flex: 1 }} />
        <SkeletonBlock
          width="80%"
          height={24}
          borderRadius={4}
          style={styles.sidebarItem}
        />
      </View>

      <View style={styles.mainContent}>
        <DashboardContentSkeleton />
      </View>
    </View>
  )
})

const styles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'row',
    backgroundColor: Colors.light.background
  },
  sidebar: {
    width: SIDEBAR_WIDTH,
    height: '100%',
    backgroundColor: Colors.common.white,
    paddingTop: 40,
    paddingBottom: 20,
    paddingHorizontal: 20,
    borderRightWidth: StyleSheet.hairlineWidth,
    borderRightColor: Colors.light.border
  },
  mainContent: {
    flex: 1,
    height: '100%'
  },
  sidebarItem: {
    marginBottom: 25
  }
})

```
src/components/skeletons/DashboardSkeletonMobile.tsx
```
import React from 'react'
import { View, StyleSheet } from 'react-native'
import { SkeletonBlock } from './SkeletonElements'
import { DashboardContentSkeleton } from './DashboardContentSkeleton'
import { Colors } from '@constants/Colors'

const TAB_BAR_HEIGHT = 60

export const DashboardSkeletonMobile: React.FC = React.memo(() => {
  return (
    <View style={styles.container}>
      <View style={styles.mainContent}>
        <DashboardContentSkeleton />
      </View>

      <View style={styles.tabBar}>
        {[...Array(4)].map((_, i) => (
          <View key={i} style={styles.tabItem}>
            <SkeletonBlock
              width={24}
              height={24}
              borderRadius={4}
              style={{ marginBottom: 4 }}
            />
            <SkeletonBlock width={40} height={10} borderRadius={4} />
          </View>
        ))}
      </View>
    </View>
  )
})

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background
  },
  mainContent: {
    flex: 1
  },
  tabBar: {
    height: TAB_BAR_HEIGHT,
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
    backgroundColor: Colors.common.white,
    borderTopWidth: StyleSheet.hairlineWidth,
    borderTopColor: Colors.light.border,
    paddingHorizontal: 10,
    paddingBottom: 5,
    paddingTop: 5
  },
  tabItem: {
    alignItems: 'center',
    justifyContent: 'center'
  }
})

```
src/components/skeletons/SkeletonElements.tsx
```
import React, { useEffect, useRef } from 'react'
import { View, StyleSheet, Animated, Easing, ViewStyle } from 'react-native'
import { Colors } from '@constants/Colors'

const SKELETON_COLOR = Colors.light.border
const HIGHLIGHT_COLOR = Colors.light.backgroundLight

interface SkeletonProps {
  width?: number | string
  height?: number | string
  borderRadius?: number
  style?: ViewStyle
  children?: React.ReactNode
}

export const SkeletonBase: React.FC<SkeletonProps> = React.memo(
  ({ width = '100%', height = 20, borderRadius = 4, style, children }) => {
    const pulseAnim = useRef(new Animated.Value(0)).current

    useEffect(() => {
      const sharedAnimation = Animated.loop(
        Animated.sequence([
          Animated.timing(pulseAnim, {
            toValue: 1,
            duration: 750,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true
          }),
          Animated.timing(pulseAnim, {
            toValue: 0,
            duration: 750,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true
          })
        ])
      )
      sharedAnimation.start()
      return () => sharedAnimation.stop()
    }, [pulseAnim])

    const interpolatedOpacity = pulseAnim.interpolate({
      inputRange: [0, 1],
      outputRange: [0.6, 1]
    })

    return (
      <Animated.View
        style={[
          styles.base,
          { width, height, borderRadius },
          { opacity: interpolatedOpacity },
          style
        ]}
      >
        {children}
      </Animated.View>
    )
  }
)

export const SkeletonBlock: React.FC<SkeletonProps> = React.memo(props => {
  return <SkeletonBase {...props} />
})

export const SkeletonCircle: React.FC<
  Omit<SkeletonProps, 'borderRadius'> & { size: number }
> = React.memo(({ size, style, ...props }) => {
  return (
    <SkeletonBase
      {...props}
      width={size}
      height={size}
      borderRadius={size / 2}
      style={style}
    />
  )
})

const styles = StyleSheet.create({
  base: {
    backgroundColor: SKELETON_COLOR,
    overflow: 'hidden'
  }
})

```
src/components/common/CustomFlatList.tsx
```
// src/components/common/CustomFlatList.tsx
import React, {
  useRef,
  useState,
  useCallback,
  useEffect,
  ReactNode
} from 'react'
import {
  View,
  FlatList, // Changed from ScrollView
  StyleSheet,
  TouchableOpacity,
  Animated,
  NativeSyntheticEvent,
  NativeScrollEvent,
  LayoutChangeEvent,
  ViewStyle,
  FlatListProps,
  RefreshControlProps
} from 'react-native'
import { LinearGradient } from 'expo-linear-gradient'
import {
  ChevronUp,
  ChevronDown,
  ChevronLeft,
  ChevronRight
} from 'lucide-react-native'
import { Colors } from '@constants/Colors'

const SCROLL_ARROW_SIZE = 30
const SCROLL_ARROW_ICON_SIZE = 20
const SHADOW_SIZE = 15

interface CustomFlatListProps<ItemT>
  extends Omit<
    FlatListProps<ItemT>,
    | 'onScroll'
    | 'onLayout'
    | 'scrollEventThrottle'
    | 'ref'
    | 'style'
    | 'contentContainerStyle'
    | 'onContentSizeChange'
  > {
  scrollRef?: React.RefObject<FlatList<ItemT>>
  style?: ViewStyle
  containerStyle?: ViewStyle
  contentContainerStyle?: ViewStyle
  showScrollArrows?: boolean
  showScrollShadows?: boolean
  // horizontal is already a FlatList prop
  onScroll?: (event: NativeSyntheticEvent<NativeScrollEvent>) => void
  refreshControl?: React.ReactElement<RefreshControlProps>
}

export function CustomFlatList<ItemT>({
  scrollRef: externalScrollRef,
  style,
  containerStyle,
  contentContainerStyle,
  horizontal = false, // Default from FlatListProps might be different, ensure consistency
  showScrollArrows = true,
  showScrollShadows = true,
  onScroll: nativeOnScrollFromProps,
  ...flatListNativeProps
}: CustomFlatListProps<ItemT>) {
  const internalScrollRef = useRef<FlatList<ItemT>>(null)
  const scrollRef = externalScrollRef || internalScrollRef

  const flatListLayout = useRef({ width: 0, height: 0 })
  const [scrollPosition, setScrollPosition] = useState({ x: 0, y: 0 })
  const [isScrollable, setIsScrollable] = useState({ x: false, y: false })
  const [currentContentSize, setCurrentContentSize] = useState({
    width: 0,
    height: 0
  })

  const topShadowOpacity = useRef(new Animated.Value(0)).current
  const bottomShadowOpacity = useRef(new Animated.Value(0)).current
  const leftShadowOpacity = useRef(new Animated.Value(0)).current
  const rightShadowOpacity = useRef(new Animated.Value(0)).current

  const updateScrollState = useCallback(() => {
    const contentSize = currentContentSize
    const viewSize = flatListLayout.current

    if (
      (!viewSize.width && !viewSize.height) ||
      (!contentSize.width &&
        !contentSize.height &&
        flatListNativeProps.data?.length === 0)
    ) {
      // If FlatList has no data, contentSize can be 0, treat as not scrollable.
      if (isScrollable.x || isScrollable.y)
        setIsScrollable({ x: false, y: false })
      Animated.parallel([
        Animated.timing(topShadowOpacity, {
          toValue: 0,
          duration: 150,
          useNativeDriver: true
        }),
        Animated.timing(bottomShadowOpacity, {
          toValue: 0,
          duration: 150,
          useNativeDriver: true
        }),
        Animated.timing(leftShadowOpacity, {
          toValue: 0,
          duration: 150,
          useNativeDriver: true
        }),
        Animated.timing(rightShadowOpacity, {
          toValue: 0,
          duration: 150,
          useNativeDriver: true
        })
      ]).start()
      return
    }

    const canScrollX = contentSize.width > viewSize.width + 1
    const canScrollY = contentSize.height > viewSize.height + 1

    if (isScrollable.x !== canScrollX || isScrollable.y !== canScrollY) {
      setIsScrollable({ x: canScrollX, y: canScrollY })
    }

    const currentX = scrollPosition.x
    const currentY = scrollPosition.y

    Animated.parallel([
      Animated.timing(topShadowOpacity, {
        toValue: canScrollY && currentY > 5 ? 1 : 0,
        duration: 50,
        useNativeDriver: true
      }),
      Animated.timing(bottomShadowOpacity, {
        toValue:
          canScrollY &&
          viewSize.height > 0 &&
          currentY < contentSize.height - viewSize.height - 5
            ? 1
            : 0,
        duration: 50,
        useNativeDriver: true
      }),
      Animated.timing(leftShadowOpacity, {
        toValue: canScrollX && currentX > 5 ? 1 : 0,
        duration: 50,
        useNativeDriver: true
      }),
      Animated.timing(rightShadowOpacity, {
        toValue:
          canScrollX &&
          viewSize.width > 0 &&
          currentX < contentSize.width - viewSize.width - 5
            ? 1
            : 0,
        duration: 50,
        useNativeDriver: true
      })
    ]).start()
  }, [
    isScrollable,
    scrollPosition,
    currentContentSize,
    topShadowOpacity,
    bottomShadowOpacity,
    leftShadowOpacity,
    rightShadowOpacity
  ]) // Added flatListNativeProps.data

  useEffect(() => {
    updateScrollState()
  }, [
    updateScrollState,
    flatListLayout.current.width,
    flatListLayout.current.height,
    currentContentSize.width,
    currentContentSize.height
  ])

  const handleScroll = (event: NativeSyntheticEvent<NativeScrollEvent>) => {
    const { contentOffset, contentSize, layoutMeasurement } = event.nativeEvent
    setScrollPosition({ x: contentOffset.x, y: contentOffset.y })

    // contentSize from onScroll is reliable, update if different
    if (
      contentSize.width !== currentContentSize.width ||
      contentSize.height !== currentContentSize.height
    ) {
      setCurrentContentSize({
        width: contentSize.width,
        height: contentSize.height
      })
    }
    // Also update layoutMeasurement if it changed (e.g. screen rotation)
    if (
      layoutMeasurement.width !== flatListLayout.current.width ||
      layoutMeasurement.height !== flatListLayout.current.height
    ) {
      flatListLayout.current = {
        width: layoutMeasurement.width,
        height: layoutMeasurement.height
      }
    }

    if (nativeOnScrollFromProps) {
      nativeOnScrollFromProps(event)
    }
  }

  const handleFlatListLayout = (event: LayoutChangeEvent) => {
    const newLayout = {
      width: event.nativeEvent.layout.width,
      height: event.nativeEvent.layout.height
    }
    if (
      newLayout.width !== flatListLayout.current.width ||
      newLayout.height !== flatListLayout.current.height
    ) {
      flatListLayout.current = newLayout
      // updateScrollState(); // Will be called by useEffect watching flatListLayout.current
    }
  }

  const handleContentSizeChange = (width: number, height: number) => {
    if (
      width !== currentContentSize.width ||
      height !== currentContentSize.height
    ) {
      setCurrentContentSize({ width, height })
    }
    // If you have specific onContentSizeChange from props, forward it
    if (flatListNativeProps.onContentSizeChange) {
      flatListNativeProps.onContentSizeChange(width, height)
    }
  }

  const scrollByOffsetPixels = (dx: number, dy: number) => {
    if (
      scrollRef.current &&
      typeof scrollRef.current.scrollToOffset === 'function'
    ) {
      const targetOffset = horizontal
        ? scrollPosition.x + dx
        : scrollPosition.y + dy
      scrollRef.current.scrollToOffset({
        offset: targetOffset,
        animated: true
      })
    } else if (
      scrollRef.current &&
      typeof scrollRef.current.scrollTo === 'function'
    ) {
      // Fallback for older versions or if scrollToOffset isn't preferred, though less direct
      scrollRef.current.scrollTo({
        x: scrollPosition.x + dx,
        y: scrollPosition.y + dy,
        animated: true
      })
    } else {
      console.warn(
        'CustomFlatList: scrollRef.current is not available or scroll methods are not functions.'
      )
    }
  }

  return (
    <View style={[styles.outerWrapper, containerStyle]}>
      {/* Shadows (same as CustomScrollView) */}
      {showScrollShadows && !horizontal && (
        <>
          <Animated.View
            style={[
              styles.shadow,
              styles.shadowTop,
              { opacity: topShadowOpacity }
            ]}
          >
            <LinearGradient
              colors={['rgba(0,0,0,0.10)', 'transparent']}
              style={styles.gradientFill}
            />
          </Animated.View>
          <Animated.View
            style={[
              styles.shadow,
              styles.shadowBottom,
              { opacity: bottomShadowOpacity }
            ]}
          >
            <LinearGradient
              colors={['transparent', 'rgba(0,0,0,0.10)']}
              style={styles.gradientFill}
            />
          </Animated.View>
        </>
      )}
      {showScrollShadows && horizontal && (
        <>
          <Animated.View
            style={[
              styles.shadow,
              styles.shadowLeft,
              { opacity: leftShadowOpacity }
            ]}
          >
            <LinearGradient
              colors={['rgba(0,0,0,0.10)', 'transparent']}
              style={styles.gradientFillHorizontal}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 0 }}
            />
          </Animated.View>
          <Animated.View
            style={[
              styles.shadow,
              styles.shadowRight,
              { opacity: rightShadowOpacity }
            ]}
          >
            <LinearGradient
              colors={['transparent', 'rgba(0,0,0,0.10)']}
              style={styles.gradientFillHorizontal}
              start={{ x: 1, y: 0 }}
              end={{ x: 0, y: 0 }}
            />
          </Animated.View>
        </>
      )}

      <FlatList
        ref={scrollRef}
        style={[styles.scrollContent, style]}
        contentContainerStyle={contentContainerStyle}
        horizontal={horizontal}
        onScroll={handleScroll}
        onLayout={handleFlatListLayout}
        onContentSizeChange={handleContentSizeChange}
        scrollEventThrottle={16}
        showsHorizontalScrollIndicator={false}
        showsVerticalScrollIndicator={false}
        {...flatListNativeProps} // Spread all other FlatList props
      />

      {/* Arrows (use scrollByOffsetPixels) */}
      {showScrollArrows && !horizontal && isScrollable.y && (
        <>
          <Animated.View
            style={{
              opacity: topShadowOpacity,
              position: 'absolute',
              top: 5,
              alignSelf: 'center',
              zIndex: 3
            }}
          >
            <TouchableOpacity
              style={styles.arrowButton}
              onPress={() =>
                scrollByOffsetPixels(0, -flatListLayout.current.height * 0.8)
              }
            >
              <ChevronUp
                size={SCROLL_ARROW_ICON_SIZE}
                color={Colors.common.white}
              />
            </TouchableOpacity>
          </Animated.View>
          <Animated.View
            style={{
              opacity: bottomShadowOpacity,
              position: 'absolute',
              bottom: 5,
              alignSelf: 'center',
              zIndex: 3
            }}
          >
            <TouchableOpacity
              style={styles.arrowButton}
              onPress={() =>
                scrollByOffsetPixels(0, flatListLayout.current.height * 0.8)
              }
            >
              <ChevronDown
                size={SCROLL_ARROW_ICON_SIZE}
                color={Colors.common.white}
              />
            </TouchableOpacity>
          </Animated.View>
        </>
      )}
      {showScrollArrows && horizontal && isScrollable.x && (
        <>
          <Animated.View
            style={{
              opacity: leftShadowOpacity,
              position: 'absolute',
              left: 5,
              alignSelf: 'center',
              zIndex: 3,
              top: '50%',
              transform: [{ translateY: -SCROLL_ARROW_SIZE / 2 }]
            }}
          >
            <TouchableOpacity
              style={styles.arrowButton}
              onPress={() =>
                scrollByOffsetPixels(-flatListLayout.current.width * 0.8, 0)
              }
            >
              <ChevronLeft
                size={SCROLL_ARROW_ICON_SIZE}
                color={Colors.common.white}
              />
            </TouchableOpacity>
          </Animated.View>
          <Animated.View
            style={{
              opacity: rightShadowOpacity,
              position: 'absolute',
              right: 5,
              alignSelf: 'center',
              zIndex: 3,
              top: '50%',
              transform: [{ translateY: -SCROLL_ARROW_SIZE / 2 }]
            }}
          >
            <TouchableOpacity
              style={styles.arrowButton}
              onPress={() =>
                scrollByOffsetPixels(flatListLayout.current.width * 0.8, 0)
              }
            >
              <ChevronRight
                size={SCROLL_ARROW_ICON_SIZE}
                color={Colors.common.white}
              />
            </TouchableOpacity>
          </Animated.View>
        </>
      )}
    </View>
  )
}

const styles = StyleSheet.create({
  outerWrapper: { flex: 1, overflow: 'hidden', position: 'relative' },
  scrollContent: { flex: 1, zIndex: 1 },
  shadow: { position: 'absolute', pointerEvents: 'none', zIndex: 2 },
  shadowTop: { top: 0, left: 0, right: 0, height: SHADOW_SIZE },
  shadowBottom: { bottom: 0, left: 0, right: 0, height: SHADOW_SIZE },
  shadowLeft: { top: 0, bottom: 0, left: 0, width: SHADOW_SIZE },
  shadowRight: { top: 0, bottom: 0, right: 0, width: SHADOW_SIZE },
  gradientFill: { flex: 1 },
  gradientFillHorizontal: { flex: 1, width: '100%', height: '100%' },
  arrowButton: {
    backgroundColor: 'rgba(0, 0, 0, 0.75)',
    width: SCROLL_ARROW_SIZE,
    height: SCROLL_ARROW_SIZE,
    borderRadius: SCROLL_ARROW_SIZE / 2,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 3
  }
})

```
src/components/common/CustomScrollView.tsx
```
// src/components/common/CustomScrollView.tsx
import React, {
  useRef,
  useState,
  useCallback,
  useEffect,
  ReactNode
} from 'react'
import {
  View,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  Animated,
  NativeSyntheticEvent,
  NativeScrollEvent,
  LayoutChangeEvent,
  ViewStyle,
  ScrollViewProps
} from 'react-native'
import { LinearGradient } from 'expo-linear-gradient'
import {
  ChevronUp,
  ChevronDown,
  ChevronLeft,
  ChevronRight
} from 'lucide-react-native'
import { Colors } from '@constants/Colors'

const SCROLL_ARROW_SIZE = 30
const SCROLL_ARROW_ICON_SIZE = 20
const SHADOW_SIZE = 15

interface CustomScrollViewProps
  extends Omit<
    ScrollViewProps,
    | 'onScroll'
    | 'onLayout'
    | 'scrollEventThrottle'
    | 'ref'
    | 'style'
    | 'contentContainerStyle'
    | 'children'
  > {
  children: ReactNode
  scrollRef?: React.RefObject<ScrollView>
  style?: ViewStyle // Style for the ScrollView itself
  containerStyle?: ViewStyle // Style for the outer wrapper
  innerContentStyle?: ViewStyle // Style for the direct child View that wraps children (for onLayout)
  contentContainerStyle?: ViewStyle // Passed to ScrollView's contentContainerStyle
  horizontal?: boolean
  showScrollArrows?: boolean
  showScrollShadows?: boolean
}

export const CustomScrollView: React.FC<CustomScrollViewProps> = ({
  children,
  scrollRef: externalScrollRef,
  style,
  containerStyle,
  innerContentStyle,
  contentContainerStyle,
  horizontal = false,
  showScrollArrows = true,
  showScrollShadows = true,
  ...scrollViewNativeProps
}) => {
  const internalScrollRef = useRef<ScrollView>(null)
  const scrollRef = externalScrollRef || internalScrollRef

  const measuredContentLayout = useRef({ width: 0, height: 0 })
  const scrollViewLayout = useRef({ width: 0, height: 0 })
  const [scrollPosition, setScrollPosition] = useState({ x: 0, y: 0 })
  const [isScrollable, setIsScrollable] = useState({ x: false, y: false })

  const topShadowOpacity = useRef(new Animated.Value(0)).current
  const bottomShadowOpacity = useRef(new Animated.Value(0)).current
  const leftShadowOpacity = useRef(new Animated.Value(0)).current
  const rightShadowOpacity = useRef(new Animated.Value(0)).current

  const updateScrollState = useCallback(() => {
    const contentSize = measuredContentLayout.current
    const viewSize = scrollViewLayout.current

    if (!viewSize.width && !viewSize.height) return

    const canScrollX = contentSize.width > viewSize.width + 1
    const canScrollY = contentSize.height > viewSize.height + 1

    if (isScrollable.x !== canScrollX || isScrollable.y !== canScrollY) {
      setIsScrollable({ x: canScrollX, y: canScrollY })
    }

    const currentX = scrollPosition.x
    const currentY = scrollPosition.y

    Animated.parallel([
      Animated.timing(topShadowOpacity, {
        toValue: canScrollY && currentY > 5 ? 1 : 0,
        duration: 50,
        useNativeDriver: true
      }),
      Animated.timing(bottomShadowOpacity, {
        toValue:
          canScrollY &&
          viewSize.height > 0 &&
          currentY < contentSize.height - viewSize.height - 5
            ? 1
            : 0,
        duration: 50,
        useNativeDriver: true
      }),
      Animated.timing(leftShadowOpacity, {
        toValue: canScrollX && currentX > 5 ? 1 : 0,
        duration: 50,
        useNativeDriver: true
      }),
      Animated.timing(rightShadowOpacity, {
        toValue:
          canScrollX &&
          viewSize.width > 0 &&
          currentX < contentSize.width - viewSize.width - 5
            ? 1
            : 0,
        duration: 50,
        useNativeDriver: true
      })
    ]).start()
  }, [
    isScrollable,
    scrollPosition,
    topShadowOpacity,
    bottomShadowOpacity,
    leftShadowOpacity,
    rightShadowOpacity
  ])

  useEffect(() => {
    updateScrollState()
  }, [
    updateScrollState,
    measuredContentLayout.current,
    scrollViewLayout.current
  ])

  const handleScroll = (event: NativeSyntheticEvent<NativeScrollEvent>) => {
    const { contentOffset } = event.nativeEvent
    setScrollPosition({ x: contentOffset.x, y: contentOffset.y })
    // updateScrollState will be triggered by useEffect due to scrollPosition change
    if (scrollViewNativeProps.onScroll) {
      // Forward native onScroll
      scrollViewNativeProps.onScroll(event)
    }
  }

  const handleContentLayout = (event: LayoutChangeEvent) => {
    const newLayout = {
      width: event.nativeEvent.layout.width,
      height: event.nativeEvent.layout.height
    }
    if (
      newLayout.width !== measuredContentLayout.current.width ||
      newLayout.height !== measuredContentLayout.current.height
    ) {
      measuredContentLayout.current = newLayout
      updateScrollState() // Update immediately as content size is now known
    }
  }

  const handleScrollViewLayout = (event: LayoutChangeEvent) => {
    const newLayout = {
      width: event.nativeEvent.layout.width,
      height: event.nativeEvent.layout.height
    }
    if (
      newLayout.width !== scrollViewLayout.current.width ||
      newLayout.height !== scrollViewLayout.current.height
    ) {
      scrollViewLayout.current = newLayout
      updateScrollState() // Update immediately as view size is now known
    }
  }

  const scrollByOffset = (dx: number, dy: number) => {
    if (scrollRef.current && typeof scrollRef.current.scrollTo === 'function') {
      scrollRef.current.scrollTo({
        x: scrollPosition.x + dx,
        y: scrollPosition.y + dy,
        animated: true
      })
    } else {
      console.warn(
        'CustomScrollView: scrollRef.current is not available or scrollTo is not a function.'
      )
    }
  }

  return (
    <View style={[styles.outerWrapper, containerStyle]}>
      {/* Shadows */}
      {showScrollShadows && !horizontal && (
        <>
          <Animated.View
            style={[
              styles.shadow,
              styles.shadowTop,
              { opacity: topShadowOpacity }
            ]}
          >
            <LinearGradient
              colors={['rgba(0,0,0,0.10)', 'transparent']}
              style={styles.gradientFill}
            />
          </Animated.View>
          <Animated.View
            style={[
              styles.shadow,
              styles.shadowBottom,
              { opacity: bottomShadowOpacity }
            ]}
          >
            <LinearGradient
              colors={['transparent', 'rgba(0,0,0,0.10)']}
              style={styles.gradientFill}
            />
          </Animated.View>
        </>
      )}
      {showScrollShadows && horizontal && (
        <>
          <Animated.View
            style={[
              styles.shadow,
              styles.shadowLeft,
              { opacity: leftShadowOpacity }
            ]}
          >
            <LinearGradient
              colors={['rgba(0,0,0,0.10)', 'transparent']}
              style={styles.gradientFillHorizontal}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 0 }}
            />
          </Animated.View>
          <Animated.View
            style={[
              styles.shadow,
              styles.shadowRight,
              { opacity: rightShadowOpacity }
            ]}
          >
            <LinearGradient
              colors={['transparent', 'rgba(0,0,0,0.10)']}
              style={styles.gradientFillHorizontal}
              start={{ x: 1, y: 0 }}
              end={{ x: 0, y: 0 }}
            />
          </Animated.View>
        </>
      )}

      <ScrollView
        ref={scrollRef}
        style={[styles.scrollContent, style]}
        contentContainerStyle={contentContainerStyle}
        horizontal={horizontal}
        onScroll={handleScroll}
        onLayout={handleScrollViewLayout}
        scrollEventThrottle={16}
        showsHorizontalScrollIndicator={false}
        showsVerticalScrollIndicator={false}
        {...scrollViewNativeProps}
      >
        <View onLayout={handleContentLayout} style={innerContentStyle}>
          {children}
        </View>
      </ScrollView>

      {/* Arrows */}
      {showScrollArrows && !horizontal && isScrollable.y && (
        <>
          <Animated.View
            style={{
              opacity: topShadowOpacity,
              position: 'absolute',
              top: 5,
              alignSelf: 'center',
              zIndex: 3
            }}
          >
            <TouchableOpacity
              style={styles.arrowButton}
              onPress={() =>
                scrollByOffset(0, -scrollViewLayout.current.height * 0.8)
              }
            >
              <ChevronUp
                size={SCROLL_ARROW_ICON_SIZE}
                color={Colors.common.white}
              />
            </TouchableOpacity>
          </Animated.View>
          <Animated.View
            style={{
              opacity: bottomShadowOpacity,
              position: 'absolute',
              bottom: 5,
              alignSelf: 'center',
              zIndex: 3
            }}
          >
            <TouchableOpacity
              style={styles.arrowButton}
              onPress={() =>
                scrollByOffset(0, scrollViewLayout.current.height * 0.8)
              }
            >
              <ChevronDown
                size={SCROLL_ARROW_ICON_SIZE}
                color={Colors.common.white}
              />
            </TouchableOpacity>
          </Animated.View>
        </>
      )}
      {showScrollArrows && horizontal && isScrollable.x && (
        <>
          <Animated.View
            style={{
              opacity: leftShadowOpacity,
              position: 'absolute',
              left: 5,
              alignSelf: 'center',
              zIndex: 3,
              top: '50%',
              transform: [{ translateY: -SCROLL_ARROW_SIZE / 2 }]
            }}
          >
            <TouchableOpacity
              style={styles.arrowButton}
              onPress={() =>
                scrollByOffset(-scrollViewLayout.current.width * 0.8, 0)
              }
            >
              <ChevronLeft
                size={SCROLL_ARROW_ICON_SIZE}
                color={Colors.common.white}
              />
            </TouchableOpacity>
          </Animated.View>
          <Animated.View
            style={{
              opacity: rightShadowOpacity,
              position: 'absolute',
              right: 5,
              alignSelf: 'center',
              zIndex: 3,
              top: '50%',
              transform: [{ translateY: -SCROLL_ARROW_SIZE / 2 }]
            }}
          >
            <TouchableOpacity
              style={styles.arrowButton}
              onPress={() =>
                scrollByOffset(scrollViewLayout.current.width * 0.8, 0)
              }
            >
              <ChevronRight
                size={SCROLL_ARROW_ICON_SIZE}
                color={Colors.common.white}
              />
            </TouchableOpacity>
          </Animated.View>
        </>
      )}
    </View>
  )
}

const styles = StyleSheet.create({
  outerWrapper: { flex: 1, overflow: 'hidden', position: 'relative' },
  scrollContent: { flex: 1, zIndex: 1 },
  shadow: { position: 'absolute', pointerEvents: 'none', zIndex: 2 },
  shadowTop: { top: 0, left: 0, right: 0, height: SHADOW_SIZE },
  shadowBottom: { bottom: 0, left: 0, right: 0, height: SHADOW_SIZE },
  shadowLeft: { top: 0, bottom: 0, left: 0, width: SHADOW_SIZE },
  shadowRight: { top: 0, bottom: 0, right: 0, width: SHADOW_SIZE },
  gradientFill: { flex: 1 },
  gradientFillHorizontal: { flex: 1, width: '100%', height: '100%' },
  arrowButton: {
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    width: SCROLL_ARROW_SIZE,
    height: SCROLL_ARROW_SIZE,
    borderRadius: SCROLL_ARROW_SIZE / 2,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 3
  }
})

```
src/components/common/ErrorBoundary.tsx
```
import React, { Component, ErrorInfo, ReactNode } from 'react'
import { View, Text, StyleSheet, Button } from 'react-native'
import { Colors } from '@constants/Colors'

interface Props {
  children: ReactNode
  fallbackUI?: ReactNode
}

interface State {
  hasError: boolean
  error?: Error | null
}

class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null
  }

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo)
    // You could log this to an error reporting service (Sentry, Bugsnag)
  }

  private handleResetError = () => {
    this.setState({ hasError: false, error: null })
    // Optionally, try to navigate home or refresh
    // Be careful with this, as the underlying issue might persist.
  }

  public render() {
    if (this.state.hasError) {
      if (this.props.fallbackUI) {
        return this.props.fallbackUI
      }
      return (
        <View style={styles.container}>
          <Text style={styles.title}>Oops! Something went wrong.</Text>
          <Text style={styles.message}>
            We're sorry for the inconvenience. Please try again.
            {__DEV__ &&
              this.state.error &&
              `\n\nError: ${this.state.error.toString()}`}
          </Text>
          <Button
            title="Try Again"
            onPress={this.handleResetError}
            color={Colors.light.primary}
          />
        </View>
      )
    }

    return this.props.children
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
    backgroundColor: Colors.light.background
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    color: Colors.light.text,
    marginBottom: 15
  },
  message: {
    fontSize: 16,
    color: Colors.light.textSecondary,
    textAlign: 'center',
    marginBottom: 20
  }
})

export default ErrorBoundary

```
src/components/common/ErrorMessage.tsx
```
import React from 'react'
import { View, Text, StyleSheet } from 'react-native'
import { AlertCircle } from 'lucide-react-native'
import { Colors } from '@constants/Colors'

interface ErrorMessageProps {
  message: string | null
  title?: string
  style?: object
}

export const ErrorMessage: React.FC<ErrorMessageProps> = ({
  message,
  title = 'Error',
  style
}) => {
  if (!message) return null
  return (
    <View style={[styles.errorContainer, style]}>
      <AlertCircle size={20} color={Colors.light.error} style={styles.icon} />
      <View>
        <Text style={styles.errorTitle}>{title}</Text>
        <Text style={styles.errorMessageText}>{message}</Text>
      </View>
    </View>
  )
}

const styles = StyleSheet.create({
  errorContainer: {
    backgroundColor: Colors.light.errorBackground,
    padding: 12,
    borderRadius: 8,
    marginVertical: 10,
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: Colors.light.error
  },
  icon: {
    marginRight: 10
  },
  errorTitle: {
    color: Colors.light.error,
    fontWeight: 'bold',
    fontSize: 15
  },
  errorMessageText: {
    color: Colors.light.error,
    fontSize: 14
  }
})

```
src/components/common/LearningTipCard.tsx
```
import React from 'react'
import { View, Text, StyleSheet, Image } from 'react-native'
import { Colors } from '@constants/Colors'

const mascotIconUrl = 'https://cdn-icons-png.flaticon.com/512/2490/2490309.png'
const rocketIconUrl = 'https://cdn-icons-png.flaticon.com/512/1283/1283400.png'

interface LearningTipCardProps {
  tipTitle?: string
  tipDescription: string
  iconType?: 'mascot' | 'rocket'
  style?: ViewStyle
}

export function LearningTipCard({
  tipTitle = 'Learning Tip',
  tipDescription,
  iconType = 'mascot',
  style
}: LearningTipCardProps): React.ReactElement {
  const iconSource = iconType === 'mascot' ? mascotIconUrl : rocketIconUrl

  return (
    <View style={[styles.tipCard, style]}>
      <Image source={{ uri: iconSource }} style={styles.tipIcon} />
      <View style={styles.tipTextContainer}>
        <Text style={styles.tipTitle}>{tipTitle}</Text>
        <Text style={styles.tipDescription}>{tipDescription}</Text>
      </View>
    </View>
  )
}

const styles = StyleSheet.create({
  tipCard: {
    backgroundColor: Colors.light.flashcardTipBackground,
    borderRadius: 16,
    padding: 16,
    flexDirection: 'row',
    alignItems: 'center',
    width: '100%',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.06,
    shadowRadius: 5,
    elevation: 2
  },
  tipIcon: {
    width: 40,
    height: 40,
    marginRight: 12,
    resizeMode: 'contain'
  },
  tipTextContainer: {
    flex: 1
  },
  tipTitle: {
    fontFamily: 'Inter-Bold',
    color: Colors.light.text,
    fontSize: 14,
    marginBottom: 2
  },
  tipDescription: {
    fontFamily: 'Inter-Regular',
    color: Colors.light.text,
    opacity: 0.7,
    fontSize: 12,
    lineHeight: 16
  }
})

```
src/components/common/ScreenHeader.tsx
```
import React from 'react'
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  Platform
} from 'react-native'
import { useRouter } from 'expo-router'
import { ChevronLeft } from 'lucide-react-native'
import { Colors } from '@constants/Colors'
import { SafeAreaView } from 'react-native-safe-area-context'

type ScreenHeaderProps = {
  title: string
  canGoBack?: boolean
  fallbackPath?: string // Path to go if router.canGoBack() is false
}

/**
 * Reusable header component primarily for screens within a Stack navigator
 * that doesn't have a shared header, or needs a custom back behavior.
 */
export const ScreenHeader: React.FC<ScreenHeaderProps> = ({
  title,
  fallbackPath = '/(main)/(tabs)/' // Default fallback to main tabs
}) => {
  const router = useRouter()

  const handleGoBack = () => {
    if (router.canGoBack()) router.back()
    else router.replace(fallbackPath)
  }

  return (
    <SafeAreaView edges={['top']} style={styles.safeArea}>
      <View style={styles.headerContainer}>
        <View style={styles.leftContainer}>
          <TouchableOpacity
            onPress={handleGoBack}
            style={styles.backButton}
            hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
            accessibilityRole="button"
            accessibilityLabel="Go back"
          >
            <ChevronLeft size={24} color={Colors.light.text} />
          </TouchableOpacity>
        </View>
        <View style={styles.titleContainer}>
          <Text style={styles.headerTitle} numberOfLines={1}>
            {title}
          </Text>
        </View>
        <View style={styles.rightContainer} />
      </View>
    </SafeAreaView>
  )
}

const styles = StyleSheet.create({
  safeArea: {
    backgroundColor: Colors.light.background,
    borderBottomWidth: 1,
    borderBottomColor: Colors.light.border
  },
  headerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    height: Platform.OS === 'ios' ? 44 : 56,
    backgroundColor: Colors.light.background
  },
  leftContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'flex-start'
  },
  titleContainer: {
    flex: 3,
    justifyContent: 'center',
    alignItems: 'center'
  },
  rightContainer: {
    flex: 1
  },
  backButton: {
    padding: 4,
    marginLeft: -4
  },
  headerTitle: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 18,
    color: Colors.light.text
  }
})

```
src/components/profile/AchievementCard.tsx
```
import React from 'react'
import { View, Text, StyleSheet } from 'react-native'
import { Colors } from '@constants/Colors'
import { CircleCheck } from 'lucide-react-native'

type AchievementProps = {
  id: string
  title: string
  description: string
  progress: number
  total: number
  color: string
  earned: boolean
}

type AchievementCardProps = {
  achievement: AchievementProps
}

export const AchievementCard: React.FC<AchievementCardProps> = ({
  achievement
}) => {
  const progressPercent = Math.min(
    100,
    Math.round((achievement.progress / achievement.total) * 100)
  )

  return (
    <View style={styles.card}>
      <View style={styles.header}>
        <View
          style={[
            styles.iconContainer,
            {
              backgroundColor: achievement.earned
                ? achievement.color
                : Colors.light.backgroundLight
            }
          ]}
        >
          {achievement.earned && (
            <CircleCheck size={16} color={Colors.common.white} />
          )}
        </View>
        <Text
          style={[
            styles.title,
            achievement.earned ? styles.earnedTitle : styles.unearnedTitle
          ]}
        >
          {achievement.title}
        </Text>
      </View>

      <Text style={styles.description}>{achievement.description}</Text>

      <View style={styles.progressContainer}>
        <View style={styles.progressBarContainer}>
          <View
            style={[
              styles.progressBar,
              {
                width: `${progressPercent}%`,
                backgroundColor: achievement.color
              }
            ]}
          />
        </View>
        <Text style={styles.progressText}>
          {achievement.progress}/{achievement.total}
        </Text>
      </View>
    </View>
  )
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    shadowColor: Colors.light.shadow,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 2
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8
  },
  iconContainer: {
    width: 24,
    height: 24,
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 8
  },
  title: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 16
  },
  earnedTitle: {
    color: Colors.light.text
  },
  unearnedTitle: {
    color: Colors.light.textSecondary
  },
  description: {
    fontFamily: 'Inter-Regular',
    fontSize: 14,
    color: Colors.light.textSecondary,
    marginBottom: 12
  },
  progressContainer: {
    flexDirection: 'row',
    alignItems: 'center'
  },
  progressBarContainer: {
    flex: 1,
    height: 6,
    backgroundColor: Colors.light.backgroundLight,
    borderRadius: 3,
    marginRight: 8,
    overflow: 'hidden'
  },
  progressBar: {
    height: '100%',
    borderRadius: 3
  },
  progressText: {
    fontFamily: 'Inter-Medium',
    fontSize: 12,
    color: Colors.light.textSecondary
  }
})

```
src/components/profile/ProgressRing.tsx
```
import React from 'react'
import { View, StyleSheet } from 'react-native'
import Svg, { Circle } from 'react-native-svg'
import { Colors } from '@constants/Colors'

type ProgressRingProps = {
  progress: number // 0 to 1
  size: number
  strokeWidth: number
  color: string
}

export const ProgressRing: React.FC<ProgressRingProps> = ({
  progress,
  size,
  strokeWidth,
  color
}) => {
  // Ensure progress is between 0 and 1
  const clampedProgress = Math.max(0, Math.min(1, progress))

  const radius = (size - strokeWidth) / 2
  const circumference = radius * 2 * Math.PI
  const strokeDashoffset = circumference - clampedProgress * circumference

  return (
    <View style={[styles.container, { width: size, height: size }]}>
      <Svg width={size} height={size}>
        {/* Background Circle */}
        <Circle
          stroke={Colors.light.backgroundSecondary}
          fill="none"
          cx={size / 2}
          cy={size / 2}
          r={radius}
          strokeWidth={strokeWidth}
        />

        {/* Progress Circle */}
        <Circle
          stroke={color}
          fill="none"
          cx={size / 2}
          cy={size / 2}
          r={radius}
          strokeWidth={strokeWidth}
          strokeDasharray={circumference}
          strokeDashoffset={strokeDashoffset}
          strokeLinecap="round"
          rotation="-90"
          originX={size / 2}
          originY={size / 2}
        />
      </Svg>
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    justifyContent: 'center',
    alignItems: 'center'
  }
})

```
src/components/exercises/FillInTheBlankExerciseCard.tsx
```
// src/components/exercises/FillInTheBlankExerciseCard.tsx
import React, { useState, useEffect } from 'react' // Added useEffect
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  TextInput,
  Image
} from 'react-native'
import { Colors } from '@constants/Colors'
import { Check, X, Lightbulb } from 'lucide-react-native' // Lightbulb for Hint

// Icon for visual aid - could be related to grammar or the sentence context
const fillInBlankVisualAidPlaceholder =
  'https://cdn-icons-png.flaticon.com/512/3259/3259689.png' // Example: book/document icon

export interface FillInTheBlankExercise {
  exercise_type: 'fill_in_the_blank'
  prompt: string // e.g., "Apply grammar: 'adessiivi'" OR "Complete the sentence:"
  sentence_with_blank: string // e.g., "Kissa on _____ (tuoli)." or "Aurinko paistaa ja linnut _____."
  correct_answer: string
  options?: string[] | null
  explanation?: string // Feedback if wrong
  hint?: string // Optional hint for the user
  item_id_fk: string
  item_type_fk: 'word' | 'grammar' | string
}

interface FillInTheBlankExerciseCardProps {
  exercise: FillInTheBlankExercise
  onAnswered: (isCorrect: boolean, userAnswer: string) => void
}

export const FillInTheBlankExerciseCard: React.FC<
  FillInTheBlankExerciseCardProps
> = ({ exercise, onAnswered }) => {
  const [userAnswer, setUserAnswer] = useState('')
  const [isSubmitted, setIsSubmitted] = useState(false)
  const [showHint, setShowHint] = useState(false)

  // Calculate isCorrect only when submitted, to avoid premature UI updates
  const [isCorrectOnSubmit, setIsCorrectOnSubmit] = useState<boolean | null>(
    null
  )

  useEffect(() => {
    // Reset state when the exercise changes
    setUserAnswer('')
    setIsSubmitted(false)
    setShowHint(false)
    setIsCorrectOnSubmit(null)
  }, [exercise])

  const isMcqFill = exercise.options && exercise.options.length > 0

  const handleSubmit = () => {
    if (!userAnswer && !isMcqFill) return
    if (isMcqFill && !userAnswer) return

    const correct =
      userAnswer.trim().toLowerCase() === exercise.correct_answer.toLowerCase()
    setIsCorrectOnSubmit(correct) // Set correctness state
    setIsSubmitted(true)
  }

  const handleNext = () => {
    // isCorrectOnSubmit should be set by handleSubmit before this is called
    if (isCorrectOnSubmit === null) return
    onAnswered(isCorrectOnSubmit, userAnswer)
    // State reset is now handled by useEffect on exercise change
  }

  const renderInputMethod = () => {
    if (isMcqFill) {
      return (
        <View style={styles.optionsContainer}>
          {exercise.options?.map((option, index) => (
            <TouchableOpacity
              key={index}
              style={[
                styles.optionButton,
                userAnswer === option && styles.optionSelected,
                isSubmitted &&
                  option === exercise.correct_answer &&
                  styles.optionCorrect,
                isSubmitted &&
                  userAnswer === option &&
                  option !== exercise.correct_answer &&
                  styles.optionIncorrect
              ]}
              onPress={() => {
                if (!isSubmitted) setUserAnswer(option)
              }}
              disabled={isSubmitted}
            >
              <Text style={styles.optionButtonText}>{option}</Text>
            </TouchableOpacity>
          ))}
        </View>
      )
    } else {
      return (
        <TextInput
          style={[
            styles.textInputFill,
            isSubmitted &&
              (isCorrectOnSubmit ? styles.inputCorrect : styles.inputIncorrect)
          ]}
          value={userAnswer}
          onChangeText={setUserAnswer}
          placeholder="Type your answer here"
          placeholderTextColor={Colors.light.textTertiary}
          editable={!isSubmitted}
          onSubmitEditing={handleSubmit}
          autoCapitalize="none"
        />
      )
    }
  }

  // Process sentence_with_blank to highlight the blank space more visually
  const formattedSentence = exercise.sentence_with_blank
    .replace(/_____/g, ' __ __ __ __ __ ') // Make underscores more distinct
    .replace(/\(.*\)/g, match => `(${match.slice(1, -1).italics()})`) // Italicize hint in parentheses (conceptual)
  // Actual italicization needs <Text> styling

  return (
    <View style={styles.card}>
      <View style={styles.contentContainer}>
        <Text style={styles.instructionText}>{exercise.prompt}</Text>

        <Text style={styles.sentenceToFill}>
          {/* Split sentence to style the blank part if needed, or just display as is */}
          {formattedSentence}
        </Text>

        <View style={styles.visualAidContainer}>
          <Image
            source={{ uri: fillInBlankVisualAidPlaceholder }}
            style={styles.visualAidIcon}
          />
        </View>

        {renderInputMethod()}

        {exercise.hint && !isSubmitted && (
          <TouchableOpacity
            style={styles.hintButton}
            onPress={() => setShowHint(true)}
          >
            <Lightbulb size={16} color={Colors.light.accentOrange} />
            <Text style={styles.hintButtonText}>Show Hint</Text>
          </TouchableOpacity>
        )}
        {showHint && !isSubmitted && exercise.hint && (
          <Text style={styles.hintText}>{exercise.hint}</Text>
        )}
      </View>

      {isSubmitted && (
        <View style={styles.feedbackSection}>
          <View
            style={[
              styles.feedbackBox,
              isCorrectOnSubmit
                ? styles.feedbackBoxCorrect
                : styles.feedbackBoxIncorrect
            ]}
          >
            {isCorrectOnSubmit ? (
              <Check size={18} color={Colors.light.success} />
            ) : (
              <X size={18} color={Colors.light.error} />
            )}
            <Text
              style={[
                styles.feedbackText,
                isCorrectOnSubmit
                  ? { color: Colors.light.success }
                  : { color: Colors.light.error }
              ]}
            >
              {isCorrectOnSubmit
                ? 'Correct!'
                : `Correct answer: ${exercise.correct_answer}`}
            </Text>
          </View>
          {exercise.explanation && !isCorrectOnSubmit && (
            <Text style={styles.explanationText}>{exercise.explanation}</Text>
          )}
        </View>
      )}

      <View style={styles.actionBar}>
        {!isSubmitted ? (
          <TouchableOpacity
            style={[
              styles.actionButton,
              styles.submitButton,
              !userAnswer && !isMcqFill && styles.buttonDisabled
            ]}
            onPress={handleSubmit}
            disabled={(!userAnswer && !isMcqFill) || (isMcqFill && !userAnswer)}
          >
            <Text style={styles.actionButtonText}>Check</Text>
          </TouchableOpacity>
        ) : (
          <TouchableOpacity
            style={[styles.actionButton, styles.nextButton]}
            onPress={handleNext}
          >
            <Text style={styles.actionButtonText}>Next</Text>
          </TouchableOpacity>
        )}
      </View>
    </View>
  )
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 24,
    padding: 20,
    marginVertical: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.08,
    shadowRadius: 4,
    elevation: 5
    // Mimicking the Pronunciation screen's card feel
  },
  contentContainer: {
    alignItems: 'center',
    marginBottom: 20
  },
  instructionText: {
    fontSize: 16, // Adjusted size
    fontFamily: 'Inter-SemiBold', // More prominent
    color: Colors.light.textSecondary, // Softer color
    marginBottom: 10, // Spacing
    textAlign: 'center'
  },
  sentenceToFill: {
    fontSize: 22, // Prominent sentence
    fontFamily: 'Inter-Medium', // Not too bold, to let blank stand out
    color: Colors.light.text,
    marginBottom: 15,
    textAlign: 'center',
    lineHeight: 32,
    paddingHorizontal: 10 // Ensure it doesn't touch edges
  },
  visualAidContainer: {
    width: 60,
    height: 60, // Smaller visual aid
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 20,
    opacity: 0.7 // Subtler
  },
  visualAidIcon: { width: '100%', height: '100%', resizeMode: 'contain' },

  textInputFill: {
    borderWidth: 1.5, // Slightly thicker border
    borderColor: Colors.light.border, // Use a theme green if active: Colors.light.accentGreen
    backgroundColor: Colors.common.white, // Clean white background
    borderRadius: 12,
    paddingVertical: 16, // Taller input
    paddingHorizontal: 20,
    fontSize: 18,
    textAlign: 'center',
    marginBottom: 15, // Space before hint/submit
    width: '90%',
    alignSelf: 'center',
    fontFamily: 'Inter-Regular',
    color: Colors.light.text
  },
  inputCorrect: {
    borderColor: Colors.light.success,
    backgroundColor: Colors.light.successBackground,
    color: Colors.light.success
  },
  inputIncorrect: {
    borderColor: Colors.light.error,
    backgroundColor: Colors.light.errorBackground,
    color: Colors.light.error
  },

  optionsContainer: { marginBottom: 15, width: '100%' },
  optionButton: {
    backgroundColor: Colors.common.white,
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderRadius: 12,
    marginBottom: 10,
    borderWidth: 1.5,
    borderColor: Colors.light.border,
    alignItems: 'center'
  },
  // Using accentGreen from your Colors.ts (or a similar theme green)
  optionSelected: {
    borderColor: Colors.light.accentGreen,
    backgroundColor: Colors.light.accentGreen + '20'
  },
  optionCorrect: {
    borderColor: Colors.light.success,
    backgroundColor: Colors.light.successBackground
  },
  optionIncorrect: {
    borderColor: Colors.light.error,
    backgroundColor: Colors.light.errorBackground
  },
  optionButtonText: {
    fontSize: 16,
    fontFamily: 'Inter-Medium',
    color: Colors.light.text
  },

  hintButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    marginBottom: 10
  },
  hintButtonText: {
    marginLeft: 6,
    fontSize: 14,
    fontFamily: 'Inter-Medium',
    color: Colors.light.accentOrange
  },
  hintText: {
    fontSize: 14,
    fontFamily: 'Inter-Regular',
    color: Colors.light.textSecondary,
    fontStyle: 'italic',
    textAlign: 'center',
    paddingHorizontal: 10,
    marginBottom: 15
  },

  feedbackSection: { marginVertical: 10, paddingHorizontal: 0 }, // No extra horizontal padding
  feedbackBox: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderRadius: 10,
    borderWidth: 1
  },
  feedbackBoxCorrect: {
    borderColor: Colors.light.success,
    backgroundColor: Colors.light.successBackground
  },
  feedbackBoxIncorrect: {
    borderColor: Colors.light.error,
    backgroundColor: Colors.light.errorBackground
  },
  feedbackText: { marginLeft: 8, fontSize: 15, fontFamily: 'Inter-Medium' },
  explanationText: {
    marginTop: 8,
    fontSize: 14,
    color: Colors.light.textSecondary,
    paddingLeft: 30
  },

  actionBar: {
    marginTop: 15,
    paddingTop: 15,
    borderTopWidth: 1,
    borderTopColor: Colors.light.border
  },
  actionButton: { paddingVertical: 14, borderRadius: 12, alignItems: 'center' },
  // Using accentGreen for "Check" and a different color for "Next" to match pronunciation screen buttons
  submitButton: { backgroundColor: Colors.light.accentGreen },
  nextButton: { backgroundColor: Colors.light.primary },
  buttonDisabled: { backgroundColor: Colors.light.border, opacity: 0.7 },
  actionButtonText: {
    color: Colors.common.white,
    fontFamily: 'Inter-Bold',
    fontSize: 16
  }
})

```
src/components/exercises/FlashcardExerciseCard.tsx
```
import React, { useState, useEffect } from 'react'
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator
} from 'react-native'
import { useDispatch } from 'react-redux'
import { Colors } from '@constants/Colors'
import { KLearnFlashcardExercise } from '@features/lessons/types'
import { AppDispatch } from '@/store/store'

interface FlashcardExerciseCardProps {
  exercise: KLearnFlashcardExercise
  onAnswered: (isCorrect: boolean, userAnswer: string) => void
}

export const FlashcardExerciseCard: React.FC<FlashcardExerciseCardProps> = ({
  exercise,
  onAnswered
}) => {
  const [isFlipped, setIsFlipped] = useState(false)
  const [fetchedAnswer, setFetchedAnswer] = useState<string | null>(null)
  const [isLoadingAnswer, setIsLoadingAnswer] = useState(false)
  const dispatch = useDispatch<AppDispatch>()

  useEffect(() => {
    setIsFlipped(false)
    setFetchedAnswer(null)
    setIsLoadingAnswer(false)

    if (
      !exercise.answer_text &&
      exercise.item_id_fk &&
      exercise.item_type_fk === 'word'
    ) {
      setIsLoadingAnswer(true)
      console.log(
        `Flashcard: Would fetch details for word ID: ${exercise.item_id_fk}`
      )

      setTimeout(() => {
        const mockDetails = {
          primary_translation_en: `Translation for ${
            exercise.prompt.split(' ')[0]
          }`
        }
        setFetchedAnswer(mockDetails.primary_translation_en)
        setIsLoadingAnswer(false)
      }, 1000)
    }
  }, [exercise, dispatch])

  const displayAnswer =
    exercise.answer_text || fetchedAnswer || 'Loading answer...'

  const handleSelfAssessment = (knewIt: boolean) => {
    onAnswered(
      knewIt,
      knewIt ? 'self_assessed_correct' : 'self_assessed_incorrect'
    )
    setIsFlipped(false)
  }

  return (
    <View style={styles.card}>
      <TouchableOpacity
        style={styles.flipContainer}
        onPress={() => setIsFlipped(!isFlipped)}
        activeOpacity={0.7}
      >
        {!isFlipped ? (
          <View style={styles.front}>
            <Text style={styles.promptTextContent}>{exercise.prompt}</Text>
            <Text style={styles.tapToRevealText}>(Tap to reveal)</Text>
          </View>
        ) : (
          <View style={styles.back}>
            {isLoadingAnswer ? (
              <ActivityIndicator color={Colors.light.primary} size="small" />
            ) : (
              <Text style={styles.answerTextContent}>{displayAnswer}</Text>
            )}
          </View>
        )}
      </TouchableOpacity>

      {isFlipped && (
        <View style={styles.actions}>
          <TouchableOpacity
            style={[styles.button, styles.buttonBad]}
            onPress={() => handleSelfAssessment(false)}
          >
            <Text style={styles.buttonText}>Didn't Know</Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={[styles.button, styles.buttonGood]}
            onPress={() => handleSelfAssessment(true)}
          >
            <Text style={styles.buttonText}>Knew It!</Text>
          </TouchableOpacity>
        </View>
      )}
    </View>
  )
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: Colors.light.quizQuestionCardBg,
    borderRadius: 24,
    padding: 20,
    marginVertical: 10,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 6,
    minHeight: 250,
    justifyContent: 'space-between'
  },
  flipContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingBottom: 20
  },
  front: { alignItems: 'center', padding: 10 },
  back: { alignItems: 'center', padding: 10 },
  promptTextContent: {
    fontSize: 26,
    fontWeight: 'bold',
    color: Colors.light.text,
    textAlign: 'center',
    marginBottom: 10
  },
  tapToRevealText: {
    fontSize: 14,
    color: Colors.light.textSecondary
  },
  answerTextContent: {
    fontSize: 22,
    color: Colors.light.primary,
    textAlign: 'center',
    fontWeight: '500'
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    paddingTop: 15,
    borderTopWidth: 1,
    borderTopColor: Colors.light.border
  },
  button: {
    paddingVertical: 12,
    paddingHorizontal: 25,
    borderRadius: 8,
    minWidth: 130,
    alignItems: 'center'
  },
  buttonGood: { backgroundColor: Colors.light.success },
  buttonBad: { backgroundColor: Colors.light.error },
  buttonText: {
    color: Colors.common.white,
    fontWeight: 'bold',
    fontSize: 16
  }
})

```
src/components/exercises/GrammarRuleExplanationCard.tsx
```
// src/components/exercises/GrammarRuleExplanationCard.tsx
import React from 'react'
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView
} from 'react-native'
import { Colors } from '@constants/Colors'
import { KLearnGrammarRuleExplanationExercise } from '@features/lessons/types'
import Markdown from 'react-native-markdown-display' // +++ Import Markdown

interface GrammarRuleExplanationCardProps {
  exercise: KLearnGrammarRuleExplanationExercise
  onAnswered: (isCorrect: boolean, userAnswer: string) => void
}

export const GrammarRuleExplanationCard: React.FC<
  GrammarRuleExplanationCardProps
> = ({ exercise, onAnswered }) => {
  const handleAcknowledge = () => {
    onAnswered(true, 'acknowledged')
  }

  // Define styles for Markdown elements if needed
  const markdownStyles = StyleSheet.create({
    body: {
      fontSize: 16,
      lineHeight: 24,
      color: Colors.light.text
    },
    heading1: {
      fontSize: 22,
      fontWeight: 'bold',
      marginTop: 10,
      marginBottom: 5,
      color: Colors.light.secondary
    },
    heading2: {
      fontSize: 20,
      fontWeight: 'bold',
      marginTop: 8,
      marginBottom: 4,
      color: Colors.light.secondary
    },
    strong: { fontWeight: 'bold', color: Colors.light.text }, // Ensure bold text is visible
    em: { fontStyle: 'italic' },
    list_item: { marginVertical: 4 }
    // Add other styles as needed
  })

  return (
    <View style={styles.card}>
      <ScrollView
        style={styles.scrollContainer}
        contentContainerStyle={styles.scrollContentContainer}
      >
        <Text style={styles.title}>Grammar Explanation</Text>
        {/* item_id_fk is now part of KLearnExerciseBase, so it's always available if KLearn sends it */}
        {/* <Text style={styles.conceptInfo}>Focus: {exercise.item_id_fk}</Text> */}

        <Markdown style={markdownStyles}>{exercise.prompt}</Markdown>
      </ScrollView>
      <View style={styles.actions}>
        <TouchableOpacity
          style={[styles.button, styles.acknowledgeButton]}
          onPress={handleAcknowledge}
        >
          <Text style={styles.buttonText}>Continue</Text>
        </TouchableOpacity>
      </View>
    </View>
  )
}

// Styles (mostly the same, ensure explanationText or markdown body style is appropriate)
const styles = StyleSheet.create({
  card: {
    backgroundColor: Colors.light.quizQuestionCardBg,
    borderRadius: 24,
    padding: 20,
    marginVertical: 10,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 6,
    flex: 1
  },
  scrollContainer: {
    flex: 1
  },
  scrollContentContainer: {
    paddingHorizontal: 20,
    paddingBottom: 10
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    fontFamily: 'Inter-Bold',
    color: Colors.light.secondary,
    marginBottom: 15
  },
  conceptInfo: {
    fontSize: 13,
    fontFamily: 'Inter-Medium',
    color: Colors.light.textSecondary,
    marginBottom: 10,
    fontStyle: 'italic'
  },
  // `explanationText` style is now handled by Markdown styles `body`
  actions: {
    marginTop: 15,
    paddingTop: 15,
    paddingHorizontal: 20,
    borderTopWidth: 1,
    borderTopColor: Colors.light.border
  },
  button: {
    paddingVertical: 12,
    borderRadius: 8,
    alignItems: 'center'
  },
  acknowledgeButton: {
    backgroundColor: Colors.light.secondary
  },
  buttonText: {
    color: Colors.common.white,
    fontWeight: 'bold',
    fontSize: 16,
    fontFamily: 'Inter-SemiBold'
  }
})

```
src/components/exercises/IdentifyTheConceptExerciseCard.tsx
```
import React, { useState } from 'react'
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native'
import { Colors } from '@constants/Colors'
import { KLearnIdentifyTheConceptExercise } from '@features/lessons/types'
import { Check, X } from 'lucide-react-native'

interface IdentifyTheConceptCardProps {
  exercise: KLearnIdentifyTheConceptExercise
  onAnswered: (isCorrect: boolean, userAnswer: string) => void
}

export const IdentifyTheConceptExerciseCard: React.FC<
  IdentifyTheConceptCardProps
> = ({ exercise, onAnswered }) => {
  const [selectedOptionId, setSelectedOptionId] = useState<string | null>(null)
  const [isSubmitted, setIsSubmitted] = useState(false)
  const isCorrect = selectedOptionId === exercise.correct_concept_id

  const handleSelectOption = (optionId: string) => {
    if (isSubmitted) return
    setSelectedOptionId(optionId)
  }

  const handleSubmit = () => {
    if (!selectedOptionId) return
    setIsSubmitted(true)
  }

  const handleNext = () => {
    onAnswered(isCorrect, selectedOptionId || '')
    setSelectedOptionId(null)
    setIsSubmitted(false)
  }

  return (
    <View style={styles.card}>
      <Text style={styles.prompt}>{exercise.prompt}</Text>
      <View style={styles.sentenceBox}>
        <Text style={styles.sentenceFi}>{exercise.sentence_fi}</Text>
      </View>

      <View style={styles.optionsContainer}>
        {exercise.options.map(option => (
          <TouchableOpacity
            key={option.id}
            style={[
              styles.optionButton,
              selectedOptionId === option.id && styles.optionSelected,
              isSubmitted &&
                option.id === exercise.correct_concept_id &&
                styles.optionCorrect,
              isSubmitted &&
                selectedOptionId === option.id &&
                option.id !== exercise.correct_concept_id &&
                styles.optionIncorrect
            ]}
            onPress={() => handleSelectOption(option.id)}
            disabled={isSubmitted}
          >
            <Text style={styles.optionText}>{option.text}</Text>
          </TouchableOpacity>
        ))}
      </View>

      {isSubmitted && (
        <View style={styles.feedbackContainer}>
          {isCorrect ? (
            <Check size={20} color={Colors.light.success} />
          ) : (
            <X size={20} color={Colors.light.error} />
          )}
          <Text
            style={[
              styles.feedbackText,
              isCorrect
                ? styles.feedbackCorrectText
                : styles.feedbackIncorrectText
            ]}
          >
            {isCorrect
              ? 'Correct!'
              : `Correct concept: ${
                  exercise.options.find(
                    o => o.id === exercise.correct_concept_id
                  )?.text || 'N/A'
                }`}
          </Text>
          {exercise.explanation && !isCorrect && (
            <Text style={styles.explanationText}>{exercise.explanation}</Text>
          )}
        </View>
      )}

      <View style={styles.actions}>
        {!isSubmitted ? (
          <TouchableOpacity
            style={[
              styles.button,
              styles.submitButton,
              !selectedOptionId && styles.buttonDisabled
            ]}
            onPress={handleSubmit}
            disabled={!selectedOptionId}
          >
            <Text style={styles.buttonText}>Submit</Text>
          </TouchableOpacity>
        ) : (
          <TouchableOpacity
            style={[styles.button, styles.nextButton]}
            onPress={handleNext}
          >
            <Text style={styles.buttonText}>Next</Text>
          </TouchableOpacity>
        )}
      </View>
    </View>
  )
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 12,
    padding: 20,
    marginVertical: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.08,
    shadowRadius: 3,
    elevation: 2
  },
  prompt: {
    fontSize: 17,
    color: Colors.light.textSecondary,
    marginBottom: 10,
    textAlign: 'center'
  },
  sentenceBox: {
    backgroundColor: Colors.light.backgroundSecondary,
    paddingVertical: 12,
    paddingHorizontal: 15,
    borderRadius: 8,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: Colors.light.border
  },
  sentenceFi: {
    fontSize: 18,
    fontWeight: '500',
    color: Colors.light.text,
    textAlign: 'center',
    lineHeight: 26
  },
  optionsContainer: { marginBottom: 20 },
  optionButton: {
    backgroundColor: Colors.common.white,
    padding: 15,
    borderRadius: 8,
    marginBottom: 10,
    borderWidth: 1,
    borderColor: Colors.light.border,
    alignItems: 'center'
  },
  optionSelected: {
    borderColor: Colors.light.primary,
    backgroundColor: Colors.light.primaryLight
  },
  optionCorrect: {
    borderColor: Colors.light.success,
    backgroundColor: Colors.light.successBackground
  },
  optionIncorrect: {
    borderColor: Colors.light.error,
    backgroundColor: Colors.light.errorBackground
  },
  optionText: {
    fontSize: 16,
    color: Colors.light.text
  },
  feedbackContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 10,
    borderRadius: 8,
    marginVertical: 10
  },
  feedbackText: { marginLeft: 8, fontSize: 16, fontWeight: '500' },
  feedbackCorrectText: { color: Colors.light.success },
  feedbackIncorrectText: { color: Colors.light.error },
  explanationText: {
    marginTop: 5,
    fontSize: 14,
    color: Colors.light.textSecondary,
    marginLeft: 28
  },
  actions: { marginTop: 10 },
  button: { paddingVertical: 12, borderRadius: 8, alignItems: 'center' },
  submitButton: { backgroundColor: Colors.light.primary },
  nextButton: { backgroundColor: Colors.light.accentGreen },
  buttonDisabled: { backgroundColor: Colors.light.border },
  buttonText: { color: Colors.common.white, fontWeight: 'bold', fontSize: 16 }
})

```
src/components/exercises/MultipleChoiceTranslationExerciseCard.tsx
```
import React, { useState, useMemo, useEffect } from 'react'
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Image,
  Alert
} from 'react-native'
import { Colors } from '@constants/Colors'
import { Check, X as IconX, Volume2 } from 'lucide-react-native'
import { KLearnMCTranslationExercise } from '@features/lessons/types'

const quizIconPlaceholder =
  'https://cdn-icons-png.flaticon.com/512/2490/2490421.png'

interface MCTranslationCardProps {
  exercise: KLearnMCTranslationExercise
  onAnswered: (isCorrect: boolean, userAnswer: string) => void
  currentQuestionNumber?: number
  totalQuestions?: number
  questionPoints?: number
  questionTimeLimit?: number
}

export function MultipleChoiceTranslationExerciseCard({
  exercise,
  onAnswered,
  currentQuestionNumber,
  totalQuestions,
  questionPoints,
  questionTimeLimit
}: MCTranslationCardProps): React.ReactElement {
  const [selectedAnswer, setSelectedAnswer] = useState<string | null>(null)
  const [isSubmitted, setIsSubmitted] = useState(false)
  const [timeLeft, setTimeLeft] = useState<number | undefined>(
    questionTimeLimit
  )

  const options = useMemo(() => {
    const allOptionTexts = [
      exercise.correct_translation,
      ...exercise.distractor_translations
    ]
    return allOptionTexts.sort(() => Math.random() - 0.5)
  }, [exercise.correct_translation, exercise.distractor_translations])

  const isCorrect = useMemo(() => {
    if (!selectedAnswer) return false
    return (
      selectedAnswer.trim().toLowerCase() ===
      exercise.correct_translation.trim().toLowerCase()
    )
  }, [selectedAnswer, exercise.correct_translation])

  useEffect(() => {
    setSelectedAnswer(null)
    setIsSubmitted(false)
    setTimeLeft(questionTimeLimit)
  }, [exercise, questionTimeLimit])

  useEffect(() => {
    if (timeLeft === undefined || timeLeft <= 0 || isSubmitted) {
      if (timeLeft === 0 && !isSubmitted) {
        handleSubmit(true)
      }
      return
    }
    const timerId = setTimeout(() => {
      setTimeLeft(timeLeft - 1)
    }, 1000)
    return () => clearTimeout(timerId)
  }, [timeLeft, isSubmitted])

  const handleSelectOption = (optionText: string) => {
    if (isSubmitted) return
    setSelectedAnswer(optionText)
  }

  const handleSubmit = (timeout: boolean = false) => {
    if (!selectedAnswer && !timeout) return
    setIsSubmitted(true)
  }

  const handleNext = () => {
    onAnswered(isCorrect, selectedAnswer || 'timeout')
  }

  const playSourcePhraseAudio = () => {
    Alert.alert('Play Audio', `Playing: ${exercise.source_phrase}`)
  }

  return (
    <View style={styles.card}>
      {(currentQuestionNumber ||
        questionPoints !== undefined ||
        timeLeft !== undefined) && (
        <View style={styles.questionInfoHeader}>
          {currentQuestionNumber && totalQuestions > 1 && (
            <View style={styles.questionNumberBadge}>
              <Text style={styles.questionNumberText}>
                Q{currentQuestionNumber}
              </Text>
            </View>
          )}
          {questionPoints !== undefined && (
            <Text style={styles.pointsText}>{questionPoints} points</Text>
          )}
          {timeLeft !== undefined && (
            <Text style={styles.timerText}>
              {Math.floor(timeLeft / 60)}:
              {String(timeLeft % 60).padStart(2, '0')}
            </Text>
          )}
        </View>
      )}

      <View style={styles.questionContentContainer}>
        <Text style={styles.questionText}>{exercise.prompt}</Text>
        <TouchableOpacity
          style={styles.audioPromptContainer}
          onPress={playSourcePhraseAudio}
        >
          <Volume2 size={20} color={Colors.light.secondary} />
          <Text style={styles.audioPromptText}>
            Tap to hear "{exercise.source_phrase}"
          </Text>
        </TouchableOpacity>
        <View style={styles.visualAidContainer}>
          <Image
            source={{ uri: quizIconPlaceholder }}
            style={styles.visualAidIcon}
          />
        </View>
      </View>

      <View style={styles.optionsGridContainer}>
        {options.map((optionText, index) => (
          <TouchableOpacity
            key={`mcq-opt-${index}-${optionText.substring(0, 5)}`}
            style={[
              styles.optionButton,
              selectedAnswer === optionText && styles.optionSelected,
              isSubmitted &&
                optionText === exercise.correct_translation &&
                styles.optionCorrect,
              isSubmitted &&
                selectedAnswer === optionText &&
                optionText !== exercise.correct_translation &&
                styles.optionIncorrect
            ]}
            onPress={() => handleSelectOption(optionText)}
            disabled={isSubmitted}
          >
            <View style={styles.optionLabelContainer}>
              <Text style={styles.optionLabel}>
                {String.fromCharCode(65 + index)}
              </Text>
            </View>
            <Text style={styles.optionButtonText}>{optionText}</Text>
          </TouchableOpacity>
        ))}
      </View>

      {isSubmitted && (
        <View style={styles.feedbackSection}>
          <View
            style={[
              styles.feedbackBox,
              isCorrect
                ? styles.feedbackBoxCorrect
                : styles.feedbackBoxIncorrect
            ]}
          >
            {isCorrect ? (
              <Check size={20} color={Colors.light.success} />
            ) : (
              <IconX size={20} color={Colors.light.error} />
            )}
            <Text
              style={[
                styles.feedbackText,
                isCorrect
                  ? { color: Colors.light.success }
                  : { color: Colors.light.error }
              ]}
            >
              {isCorrect
                ? 'Correct!'
                : `Correct: ${exercise.correct_translation}`}
            </Text>
          </View>
          {exercise.explanation && !isCorrect && (
            <Text style={styles.explanationText}>{exercise.explanation}</Text>
          )}
        </View>
      )}

      <View style={styles.actionBar}>
        {!isSubmitted ? (
          <TouchableOpacity
            style={[
              styles.actionButton,
              styles.submitButton,
              !selectedAnswer && styles.buttonDisabled
            ]}
            onPress={() => handleSubmit()}
            disabled={!selectedAnswer}
          >
            <Text style={styles.actionButtonText}>Check Answer</Text>
          </TouchableOpacity>
        ) : (
          <TouchableOpacity
            style={[styles.actionButton, styles.nextButton]}
            onPress={handleNext}
          >
            <Text style={styles.actionButtonText}>Next</Text>
          </TouchableOpacity>
        )}
      </View>
    </View>
  )
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: Colors.light.quizQuestionCardBg,
    borderRadius: 24,
    padding: 20,
    marginVertical: 10,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 6
  },
  questionInfoHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
    paddingHorizontal: 4
  },
  questionNumberBadge: {
    backgroundColor: Colors.light.secondaryLight,
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12
  },
  questionNumberText: {
    fontFamily: 'Inter-Bold',
    fontSize: 12,
    color: Colors.light.secondary
  },
  pointsText: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 14,
    color: Colors.light.warning
  },
  timerText: {
    fontFamily: 'Inter-Medium',
    fontSize: 14,
    color: Colors.light.textSecondary
  },
  questionContentContainer: {
    backgroundColor: Colors.light.quizQuestionCardBg,
    borderRadius: 20,
    padding: 16,
    marginBottom: 20,
    alignItems: 'center'
  },
  questionText: {
    fontFamily: 'Inter-Bold',
    fontSize: 18,
    color: Colors.light.text,
    textAlign: 'center',
    marginBottom: 8
  },
  audioPromptContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 6,
    marginBottom: 12
  },
  audioPromptText: {
    marginLeft: 8,
    fontSize: 13,
    fontFamily: 'Inter-Regular',
    color: Colors.light.secondary
  },
  visualAidContainer: {
    width: 72,
    height: 72,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 10
  },
  visualAidIcon: {
    width: '100%',
    height: '100%',
    resizeMode: 'contain'
  },
  optionsGridContainer: {
    marginBottom: 20
  },
  optionButton: {
    backgroundColor: Colors.light.quizOptionBg,
    borderRadius: 12,
    paddingVertical: 14,
    paddingHorizontal: 12,
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 10,
    borderWidth: 1.5,
    borderColor: Colors.light.quizOptionBorder
  },
  optionLabelContainer: {
    width: 28,
    height: 28,
    borderRadius: 14,
    backgroundColor: Colors.light.borderSubtle,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 10
  },
  optionLabel: {
    fontFamily: 'Inter-SemiBold',
    color: Colors.light.textSecondary,
    fontSize: 13
  },
  optionButtonText: {
    fontFamily: 'Inter-Medium',
    color: Colors.light.text,
    fontSize: 15,
    flex: 1
  },
  optionSelected: {
    borderColor: Colors.light.quizOptionSelectedBorder,
    backgroundColor: Colors.light.quizOptionSelectedBg
  },
  optionCorrect: {
    borderColor: Colors.light.quizCorrectBorder,
    backgroundColor: Colors.light.quizCorrectBg
  },
  optionIncorrect: {
    borderColor: Colors.light.quizIncorrectBorder,
    backgroundColor: Colors.light.quizIncorrectBg
  },
  feedbackSection: {
    marginBottom: 15
  },
  feedbackBox: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 10,
    borderRadius: 8,
    borderWidth: 1,
    marginTop: 8
  },
  feedbackBoxCorrect: {
    borderColor: Colors.light.success,
    backgroundColor: Colors.light.successBackground
  },
  feedbackBoxIncorrect: {
    borderColor: Colors.light.error,
    backgroundColor: Colors.light.errorBackground
  },
  feedbackText: {
    marginLeft: 8,
    fontSize: 14,
    fontFamily: 'Inter-Medium'
  },
  explanationText: {
    marginTop: 6,
    fontSize: 12,
    fontFamily: 'Inter-Regular',
    color: Colors.light.textSecondary,
    paddingLeft: 28
  },
  actionBar: {
    marginTop: 10,
    paddingTop: 10
  },
  actionButton: {
    paddingVertical: 13,
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center'
  },
  submitButton: {
    backgroundColor: Colors.light.quizSubmitButtonBg
  },
  nextButton: {
    backgroundColor: Colors.light.quizNextButtonBg
  },
  buttonDisabled: {
    backgroundColor: Colors.light.buttonDisabledBackground,
    opacity: 0.7
  },
  actionButtonText: {
    color: Colors.light.primaryContent,
    fontFamily: 'Inter-Bold',
    fontSize: 15
  }
})

```
src/components/exercises/SentenceConstructionExerciseCard.tsx
```
import React, { useState, useEffect, useMemo } from 'react'
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView
} from 'react-native'
import { Colors } from '@constants/Colors'
import { RotateCw, ThumbsUp, X } from 'lucide-react-native'

export interface SentenceConstructionExerciseCardExercise {
  exercise_type: 'sentence_builder'
  target_sentence_fi: string
  translation_en: string
  grammar_focus?: string
}

interface SentenceConstructionExerciseCardCardProps {
  exercise: SentenceConstructionExerciseCardExercise
  onAnswered: (isCorrect: boolean, userAnswer: string) => void
}

export const SentenceConstructionExerciseCard: React.FC<
  SentenceConstructionExerciseCardCardProps
> = ({ exercise, onAnswered }) => {
  const originalWords = useMemo(
    () => exercise.target_sentence_fi.split(' '),
    [exercise.target_sentence_fi]
  )

  const [scrambledWords, setScrambledWords] = useState<string[]>([])
  const [userAnswerWords, setUserAnswerWords] = useState<string[]>([])
  const [isSubmitted, setIsSubmitted] = useState(false)
  const [isCorrect, setIsCorrect] = useState<boolean | null>(null)

  useEffect(() => {
    setScrambledWords([...originalWords].sort(() => Math.random() - 0.5))
    setUserAnswerWords([])
    setIsSubmitted(false)
    setIsCorrect(null)
  }, [exercise, originalWords])

  const handleWordSelect = (word: string, index: number) => {
    if (isSubmitted) return
    const newScrambled = [...scrambledWords]
    newScrambled.splice(index, 1)
    setScrambledWords(newScrambled)
    setUserAnswerWords([...userAnswerWords, word])
  }

  const handleWordRemove = (word: string, index: number) => {
    if (isSubmitted) return
    const newUserAnswer = [...userAnswerWords]
    newUserAnswer.splice(index, 1)
    setUserAnswerWords(newUserAnswer)
    setScrambledWords([...scrambledWords, word].sort(() => Math.random() - 0.5))
  }

  const handleSubmit = () => {
    if (userAnswerWords.length === 0) return
    const correct = userAnswerWords.join(' ') === exercise.target_sentence_fi
    setIsCorrect(correct)
    setIsSubmitted(true)
  }

  const handleNext = () => {
    if (isCorrect === null) return
    onAnswered(isCorrect, userAnswerWords.join(' '))
  }

  const handleReset = () => {
    setUserAnswerWords([])
    setScrambledWords([...originalWords].sort(() => Math.random() - 0.5))
    setIsSubmitted(false)
    setIsCorrect(null)
  }

  return (
    <View style={styles.card}>
      <ScrollView>
        <Text style={styles.instruction}>
          Unscramble the words to form a correct Finnish sentence.
        </Text>
        <Text style={styles.translationHint}>"{exercise.translation_en}"</Text>
        {exercise.grammar_focus && (
          <Text style={styles.grammarFocus}>
            Focus: {exercise.grammar_focus}
          </Text>
        )}

        <View style={styles.answerArea}>
          {userAnswerWords.length === 0 && !isSubmitted ? (
            <Text style={styles.placeholderText}>Tap words below</Text>
          ) : (
            userAnswerWords.map((word, index) => (
              <TouchableOpacity
                key={`ans-${index}`}
                style={styles.wordChipAnswer}
                onPress={() => handleWordRemove(word, index)}
                disabled={isSubmitted}
              >
                <Text style={styles.chipText}>{word}</Text>
              </TouchableOpacity>
            ))
          )}
        </View>

        <View style={styles.wordBank}>
          {scrambledWords.map((word, index) => (
            <TouchableOpacity
              key={`bank-${index}`}
              style={styles.wordChipBank}
              onPress={() => handleWordSelect(word, index)}
              disabled={isSubmitted}
            >
              <Text style={styles.chipText}>{word}</Text>
            </TouchableOpacity>
          ))}
        </View>

        {isSubmitted && (
          <View
            style={[
              styles.feedbackContainer,
              isCorrect ? styles.feedbackCorrectBg : styles.feedbackIncorrectBg
            ]}
          >
            {isCorrect ? (
              <ThumbsUp size={20} color={Colors.light.success} />
            ) : (
              <X size={20} color={Colors.light.error} />
            )}
            <Text
              style={[
                styles.feedbackText,
                isCorrect
                  ? { color: Colors.light.success }
                  : { color: Colors.light.error }
              ]}
            >
              {isCorrect
                ? 'Excellent!'
                : `Correct sentence: ${exercise.target_sentence_fi}`}
            </Text>
          </View>
        )}
      </ScrollView>

      <View style={styles.actions}>
        {!isSubmitted ? (
          <>
            <TouchableOpacity
              style={[styles.button, styles.secondaryButton]}
              onPress={handleReset}
              disabled={userAnswerWords.length === 0}
            >
              <RotateCw size={18} color={Colors.light.textSecondary} />
              <Text style={[styles.buttonText, styles.secondaryButtonText]}>
                Reset
              </Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[
                styles.button,
                styles.submitButton,
                userAnswerWords.length !== originalWords.length &&
                  styles.buttonDisabled
              ]}
              onPress={handleSubmit}
              disabled={userAnswerWords.length !== originalWords.length}
            >
              <Text style={styles.buttonText}>Check</Text>
            </TouchableOpacity>
          </>
        ) : (
          <TouchableOpacity
            style={[styles.button, styles.nextButton]}
            onPress={handleNext}
          >
            <Text style={styles.buttonText}>Next</Text>
          </TouchableOpacity>
        )}
      </View>
    </View>
  )
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 12,
    padding: 20,
    marginVertical: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.08,
    shadowRadius: 3,
    elevation: 2,
    minHeight: 350,
    justifyContent: 'space-between'
  },
  instruction: {
    fontSize: 17,
    color: Colors.light.text,
    marginBottom: 8,
    textAlign: 'center'
  },
  translationHint: {
    fontSize: 15,
    color: Colors.light.textSecondary,
    marginBottom: 15,
    fontStyle: 'italic',
    textAlign: 'center'
  },
  grammarFocus: {
    fontSize: 14,
    color: Colors.light.primary,
    marginBottom: 15,
    textAlign: 'center',
    fontWeight: '500'
  },
  answerArea: {
    minHeight: 60,
    backgroundColor: Colors.light.background,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: Colors.light.border,
    padding: 10,
    marginBottom: 20,
    flexDirection: 'row',
    flexWrap: 'wrap',
    alignItems: 'center',
    justifyContent: 'center'
  },
  placeholderText: {
    color: Colors.light.textTertiary,
    fontSize: 15
  },
  wordBank: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    gap: 8,
    marginBottom: 20,
    paddingVertical: 10,
    borderTopWidth: 1,
    borderBottomWidth: 1,
    borderColor: Colors.light.border
  },
  wordChipAnswer: {
    backgroundColor: Colors.light.primaryLight,
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 15,
    margin: 4
  },
  wordChipBank: {
    backgroundColor: Colors.light.backgroundSecondary,
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 15,
    borderWidth: 1,
    borderColor: Colors.light.border
  },
  chipText: {
    fontSize: 16,
    color: Colors.light.text,
    fontWeight: '500'
  },
  feedbackContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    borderRadius: 8,
    marginVertical: 10
  },
  feedbackCorrectBg: { backgroundColor: Colors.light.successBackground },
  feedbackIncorrectBg: { backgroundColor: Colors.light.errorBackground },
  feedbackText: {
    marginLeft: 8,
    fontSize: 16,
    fontWeight: '500'
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 15,
    paddingTop: 15,
    borderTopWidth: 1,
    borderTopColor: Colors.light.border
  },
  button: {
    paddingVertical: 12,
    paddingHorizontal: 15,
    borderRadius: 8,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    minWidth: 100
  },
  secondaryButton: {
    backgroundColor: Colors.light.backgroundSecondary,
    borderWidth: 1,
    borderColor: Colors.light.border
  },
  secondaryButtonText: {
    color: Colors.light.textSecondary,
    marginLeft: 6
  },
  submitButton: {
    backgroundColor: Colors.light.primary
  },
  nextButton: {
    backgroundColor: Colors.light.accentGreen,
    flex: 1
  },
  buttonDisabled: {
    backgroundColor: Colors.light.border,
    opacity: 0.7
  },
  buttonText: {
    color: Colors.common.white,
    fontWeight: 'bold',
    fontSize: 16
  }
})

```
src/components/reviews/GrammarReviewCard.tsx
```
import React from 'react'
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  Image
} from 'react-native'
import { ReviewItem } from '@features/reviews/types'
import { Colors } from '@constants/Colors'
import {
  BookText,
  Info,
  AlertTriangle as IconAlertTriangle
} from 'lucide-react-native'
import Markdown from 'react-native-markdown-display'

const grammarIconUrl = 'https://cdn-icons-png.flaticon.com/512/3259/3259689.png'

interface GrammarReviewCardProps {
  item: ReviewItem
  isFlipped: boolean
  onFlip: () => void
}

export function GrammarReviewCard({
  item,
  isFlipped,
  onFlip
}: GrammarReviewCardProps): React.ReactElement {
  const markdownBodyStyle = {
    fontSize: 14,
    lineHeight: 20,
    color: Colors.light.textSecondary
  }
  const markdownHeadingStyle = {
    fontFamily: 'Inter-SemiBold',
    color: Colors.light.primary,
    marginTop: 8,
    marginBottom: 4
  }
  const markdownStyles = StyleSheet.create({
    body: markdownBodyStyle,
    heading2: { ...markdownHeadingStyle, fontSize: 15 },
    heading3: { ...markdownHeadingStyle, fontSize: 14 },
    list_item: { marginVertical: 2 },
    bullet_list_icon: {
      color: Colors.light.primary,
      marginRight: 4,
      fontSize: 16
    },
    ordered_list_icon: {
      color: Colors.light.primary,
      marginRight: 4,
      fontSize: 14,
      fontFamily: 'Inter-Medium'
    }
  })

  if (!isFlipped) {
    return (
      <TouchableOpacity
        onPress={onFlip}
        activeOpacity={0.95}
        style={styles.flashcardShell}
      >
        <View style={[styles.cardFace, styles.cardFront]}>
          {item.cefr_level && (
            <View style={styles.cefrBadge}>
              <Text style={styles.cefrText}>{item.cefr_level}</Text>
            </View>
          )}
          <View
            style={[
              styles.cardIconContainer,
              { backgroundColor: Colors.light.secondaryLight }
            ]}
          >
            <Image
              source={{ uri: grammarIconUrl }}
              style={styles.cardIconImage}
            />
          </View>
          <Text style={styles.termText}>
            {item.display_text || item.grammar_name_fi || 'Grammar Concept'}
          </Text>
          {item.grammar_category && (
            <Text style={styles.categoryText}>{item.grammar_category}</Text>
          )}
          <Text style={styles.instructionText}>
            Tap to see details & examples
          </Text>
        </View>
      </TouchableOpacity>
    )
  }

  return (
    <TouchableOpacity
      onPress={onFlip}
      activeOpacity={0.95}
      style={styles.flashcardShell}
    >
      <View style={[styles.cardFace, styles.cardBack]}>
        <ScrollView
          showsVerticalScrollIndicator={false}
          contentContainerStyle={{ flexGrow: 1, paddingBottom: 10 }}
        >
          <Text style={styles.termTextBack}>
            {item.display_text || item.grammar_name_fi}
          </Text>

          {item.grammar_explanation_en && (
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>
                <Info
                  size={15}
                  color={Colors.light.primary}
                  style={{ marginRight: 4 }}
                />{' '}
                Key Idea
              </Text>
              <Markdown style={markdownStyles}>
                {item.grammar_explanation_en}
              </Markdown>
            </View>
          )}

          {item.grammar_examples && item.grammar_examples.length > 0 && (
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>
                <BookText
                  size={15}
                  color={Colors.light.primary}
                  style={{ marginRight: 4 }}
                />{' '}
                Examples
              </Text>
              {item.grammar_examples.slice(0, 2).map((ex, index) => (
                <View key={index} style={styles.exampleItem}>
                  <Text style={styles.exampleFi}>{ex.sentence_fi}</Text>
                  {ex.translation_en && (
                    <Text style={styles.exampleEn}>"{ex.translation_en}"</Text>
                  )}
                </View>
              ))}
            </View>
          )}

          {item.common_mistakes_en && (
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>
                <IconAlertTriangle
                  size={15}
                  color={Colors.light.warning}
                  style={{ marginRight: 4 }}
                />{' '}
                Common Mistake
              </Text>
              <Text style={styles.detailTextNormal}>
                {item.common_mistakes_en}
              </Text>
            </View>
          )}
        </ScrollView>
      </View>
    </TouchableOpacity>
  )
}

const styles = StyleSheet.create({
  flashcardShell: {
    width: '100%',
    height: '100%',
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 24,
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 5 },
    shadowOpacity: 0.2,
    shadowRadius: 12,
    elevation: 8,
    overflow: 'hidden'
  },
  cardFace: {
    flex: 1,
    paddingHorizontal: 20,
    paddingVertical: 24,
    alignItems: 'center'
  },
  cardFront: {
    justifyContent: 'center'
  },
  cardBack: {
    justifyContent: 'flex-start'
  },
  cefrBadge: {
    position: 'absolute',
    top: 16,
    right: 16,
    backgroundColor: Colors.light.backgroundSecondary,
    paddingHorizontal: 8,
    paddingVertical: 3,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: Colors.light.borderSubtle
  },
  cefrText: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 10,
    color: Colors.light.textSecondary
  },
  cardIconContainer: {
    width: 64,
    height: 64,
    borderRadius: 32,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 12
  },
  cardIconImage: {
    width: 36,
    height: 36,
    resizeMode: 'contain'
  },
  termText: {
    fontSize: 26,
    fontFamily: 'Inter-Bold',
    color: Colors.light.text,
    textAlign: 'center',
    marginBottom: 4
  },
  termTextBack: {
    fontSize: 22,
    fontFamily: 'Inter-Bold',
    color: Colors.light.text,
    textAlign: 'center',
    marginBottom: 12
  },
  categoryText: {
    fontSize: 14,
    fontFamily: 'Inter-Regular',
    color: Colors.light.textSecondary,
    textAlign: 'center',
    marginBottom: 20
  },
  instructionText: {
    fontSize: 13,
    fontFamily: 'Inter-Regular',
    color: Colors.light.textTertiary,
    textAlign: 'center',
    marginTop: 8
  },
  section: {
    alignSelf: 'stretch',
    marginBottom: 14,
    paddingBottom: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: Colors.light.borderSubtle
  },
  sectionLast: {
    borderBottomWidth: 0,
    marginBottom: 0,
    paddingBottom: 0
  },
  sectionTitle: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 15,
    color: Colors.light.text,
    marginBottom: 6,
    flexDirection: 'row',
    alignItems: 'center'
  },
  detailTextNormal: {
    fontFamily: 'Inter-Regular',
    fontSize: 14,
    color: Colors.light.textSecondary,
    lineHeight: 20
  },
  exampleItem: {
    marginBottom: 8,
    backgroundColor: Colors.light.backgroundSecondary,
    padding: 8,
    borderRadius: 6
  },
  exampleFi: {
    fontFamily: 'Inter-Medium',
    fontSize: 14,
    color: Colors.light.text,
    marginBottom: 2
  },
  exampleEn: {
    fontFamily: 'Inter-RegularItalic',
    fontSize: 13,
    color: Colors.light.textSecondary
  }
})

```
src/components/reviews/WordReviewCard.tsx
```
import React from 'react'
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Image,
  Alert
} from 'react-native'
import { Volume2, Star } from 'lucide-react-native'
import { ReviewItem } from '@features/reviews/types'
import { Colors } from '@constants/Colors'

const wordIconUrl = 'https://cdn-icons-png.flaticon.com/512/2490/2490396.png'

interface WordReviewCardProps {
  item: ReviewItem
  isFlipped: boolean
  onFlip: () => void
}

export function WordReviewCard({
  item,
  isFlipped,
  onFlip
}: WordReviewCardProps): React.ReactElement {
  const playPronunciation = (
    textToSpeak?: string | null,
    lang?: 'fi' | 'en'
  ) => {
    const text =
      textToSpeak ||
      (isFlipped ? item.primary_translation_en : item.display_text)
    if (!text) return
    const actualLang = lang || (isFlipped ? 'en' : 'fi')
    Alert.alert('Play Audio', `Playing: "${text}" (lang: ${actualLang})`)
  }

  if (!isFlipped) {
    return (
      <TouchableOpacity
        onPress={onFlip}
        activeOpacity={0.95}
        style={styles.flashcardShell}
      >
        <View style={[styles.cardFace, styles.cardFront]}>
          {item.cefr_level && (
            <View style={styles.cefrBadge}>
              <Star
                size={12}
                color={Colors.light.warning}
                style={{ marginRight: 4 }}
                fill={Colors.light.warning}
              />
              <Text style={styles.cefrText}>{item.cefr_level}</Text>
            </View>
          )}
          <View
            style={[
              styles.cardIconContainer,
              { backgroundColor: Colors.light.flashcardIconBgFront }
            ]}
          >
            <Image source={{ uri: wordIconUrl }} style={styles.cardIconImage} />
          </View>
          <Text style={styles.termText}>{item.display_text}</Text>
          {item.review_reason && (
            <Text style={styles.reviewReasonText}>{item.review_reason}</Text>
          )}
          {!item.review_reason && (
            <Text style={styles.instructionText}>Tap to see translation</Text>
          )}

          <TouchableOpacity
            style={[
              styles.playButton,
              { backgroundColor: Colors.light.flashcardAudioButtonFrontBg }
            ]}
            onPress={e => {
              e.stopPropagation()
              playPronunciation(item.display_text, 'fi')
            }}
          >
            <Volume2
              size={24}
              color={Colors.light.flashcardAudioButtonFrontIcon}
            />
          </TouchableOpacity>

          <View style={styles.langFooter}>
            <View
              style={[
                styles.langCircle,
                { backgroundColor: Colors.light.flashcardLangCircleFI }
              ]}
            >
              <Text
                style={[
                  styles.langAbbreviation,
                  { color: Colors.light.flashcardLangTextFI }
                ]}
              >
                FI
              </Text>
            </View>
            <Text style={styles.langName}>Finnish</Text>
          </View>
        </View>
      </TouchableOpacity>
    )
  }

  return (
    <TouchableOpacity
      onPress={onFlip}
      activeOpacity={0.95}
      style={styles.flashcardShell}
    >
      <View style={[styles.cardFace, styles.cardBack]}>
        {item.cefr_level && (
          <View style={styles.cefrBadge}>
            <Star
              size={12}
              color={Colors.light.warning}
              style={{ marginRight: 4 }}
              fill={Colors.light.warning}
            />
            <Text style={styles.cefrText}>{item.cefr_level}</Text>
          </View>
        )}
        <View
          style={[
            styles.cardIconContainer,
            { backgroundColor: Colors.light.flashcardIconBgBack }
          ]}
        >
          <Image source={{ uri: wordIconUrl }} style={styles.cardIconImage} />
        </View>
        <Text style={styles.termText}>
          {item.primary_translation_en || 'N/A'}
        </Text>
        {item.part_of_speech && (
          <Text style={styles.detailTextSmallSemibold}>
            {item.part_of_speech}
          </Text>
        )}
        {item.pronunciation_ipa && (
          <Text style={styles.pronunciationText}>{item.pronunciation_ipa}</Text>
        )}
        {item.word_examples &&
          item.word_examples.length > 0 &&
          item.word_examples[0].sentence_fi && (
            <View style={styles.exampleBox}>
              <Text style={styles.exampleLabel}>Example:</Text>
              <Text style={styles.exampleSentence}>
                {item.word_examples[0].sentence_fi}
              </Text>
            </View>
          )}

        <TouchableOpacity
          style={[
            styles.playButton,
            { backgroundColor: Colors.light.flashcardAudioButtonBackBg }
          ]}
          onPress={e => {
            e.stopPropagation()
            playPronunciation(item.primary_translation_en, 'en')
          }}
        >
          <Volume2
            size={24}
            color={Colors.light.flashcardAudioButtonBackIcon}
          />
        </TouchableOpacity>

        <View style={styles.langFooter}>
          <View
            style={[
              styles.langCircle,
              { backgroundColor: Colors.light.flashcardLangCircleEnBg }
            ]}
          >
            <Text
              style={[
                styles.langAbbreviation,
                { color: Colors.light.flashcardLangCircleEnText }
              ]}
            >
              EN
            </Text>
          </View>
          <Text style={styles.langName}>English</Text>
        </View>
      </View>
    </TouchableOpacity>
  )
}

const styles = StyleSheet.create({
  flashcardShell: {
    width: '100%',
    height: '100%',
    backgroundColor: Colors.light.cardBackground,
    borderRadius: 24,
    shadowColor: Colors.light.shadowSoft,
    shadowOffset: { width: 0, height: 5 },
    shadowOpacity: 0.2,
    shadowRadius: 12,
    elevation: 8
  },
  cardFace: {
    flex: 1,
    padding: 20,
    alignItems: 'center',
    justifyContent: 'center',
    position: 'relative'
  },
  cardFront: {},
  cardBack: {},
  cefrBadge: {
    position: 'absolute',
    top: 16,
    right: 16,
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.light.backgroundSecondary,
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12
  },
  cefrText: {
    fontFamily: 'Inter-SemiBold',
    fontSize: 11,
    color: Colors.light.textSecondary
  },
  cardIconContainer: {
    width: 72,
    height: 72,
    borderRadius: 36,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 12
  },
  cardIconImage: {
    width: 40,
    height: 40,
    resizeMode: 'contain'
  },
  termText: {
    fontSize: 28,
    fontFamily: 'Inter-Bold',
    color: Colors.light.flashcardTermText,
    textAlign: 'center',
    marginHorizontal: 10,
    marginBottom: 4
  },
  reviewReasonText: {
    fontSize: 13,
    fontFamily: 'Inter-Regular',
    color: Colors.light.textSecondary,
    textAlign: 'center',
    marginBottom: 16,
    lineHeight: 18,
    paddingHorizontal: 10
  },
  instructionText: {
    fontSize: 13,
    fontFamily: 'Inter-Regular',
    color: Colors.light.flashcardInstructionText,
    textAlign: 'center',
    marginBottom: 16
  },
  detailTextSmallSemibold: {
    fontSize: 14,
    fontFamily: 'Inter-SemiBold',
    color: Colors.light.textSecondary,
    marginBottom: 4
  },
  pronunciationText: {
    fontSize: 14,
    fontFamily: 'Inter-MediumItalic',
    color: Colors.light.flashcardPronunciationText,
    marginBottom: 10
  },
  exampleBox: {
    backgroundColor: Colors.light.backgroundSecondary,
    borderRadius: 8,
    paddingVertical: 8,
    paddingHorizontal: 12,
    marginVertical: 8,
    alignSelf: 'stretch'
  },
  exampleLabel: {
    fontFamily: 'Inter-Medium',
    fontSize: 11,
    color: Colors.light.textTertiary,
    marginBottom: 2
  },
  exampleSentence: {
    fontFamily: 'Inter-Regular',
    fontSize: 13,
    color: Colors.light.textSecondary,
    lineHeight: 18,
    textAlign: 'center'
  },
  playButton: {
    width: 48,
    height: 48,
    borderRadius: 24,
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 12
  },
  langFooter: {
    position: 'absolute',
    bottom: 20,
    left: 20,
    flexDirection: 'row',
    alignItems: 'center'
  },
  langCircle: {
    width: 28,
    height: 28,
    borderRadius: 14,
    justifyContent: 'center',
    alignItems: 'center'
  },
  langAbbreviation: {
    fontSize: 10,
    fontFamily: 'Inter-Bold'
  },
  langName: {
    fontSize: 12,
    fontFamily: 'Inter-Regular',
    color: Colors.light.flashcardTermText,
    marginLeft: 6
  }
})

```
src/hooks/useColorScheme.ts
```typescript
export { useColorScheme } from 'react-native';

```
src/hooks/useColorScheme.web.ts
```typescript
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}

```
src/hooks/useEntity.ts
```typescript
// src/hooks/useEntity.ts
import { useEffect, useMemo } from 'react' // Added useMemo
import { useSelector, useDispatch } from 'react-redux'
import { RootState, AppDispatch } from '@store/store'
import { fetchEntityByIdIfNeededThunk } from '@features/entities/entityActions'
import { Schema } from 'normalizr'
import {
  selectEntityLoadingStatus,
  selectEntityError
} from '@features/entities/entitySelectors'
import { FetchPolicy } from '@pagination/types'

const STALE_THRESHOLD_MS = 5 * 60 * 1000 // 5 minutes (already in entityActions, ensure consistency)

interface UseEntityOptions {
  fetchPolicy?: FetchPolicy
  forceRefresh?: boolean
  skip?: boolean
}

export function useEntity<T extends { _lastFetchedAt?: number }>( // Entity T now expected to have _lastFetchedAt
  entityType: keyof RootState['entities'], // Make this more specific if possible, excluding _meta
  id: string | undefined | null,
  schema: Schema,
  endpointGenerator: (entityId: string) => string,
  options?: UseEntityOptions
) {
  const dispatch = useDispatch<AppDispatch>()
  const {
    fetchPolicy = 'cache-first',
    forceRefresh = false,
    skip = false
  } = options || {}

  const entity = useSelector(
    (state: RootState) =>
      id
        ? (state.entities[entityType as string]?.[id] as T | undefined)
        : undefined // Cast entityType to string for indexing
  )

  const isLoading = useSelector((state: RootState) =>
    id
      ? selectEntityLoadingStatus(state, entityType as string, id) === 'pending'
      : false
  )
  const error = useSelector((state: RootState) =>
    id ? selectEntityError(state, entityType as string, id) : null
  )

  // Memoize endpoint to prevent unnecessary useEffect runs if endpointGenerator is inline
  const endpoint = useMemo(
    () => (id ? endpointGenerator(id) : undefined),
    [id, endpointGenerator]
  )

  useEffect(() => {
    if (!id || skip || !endpoint) {
      // If no ID, or skipped, or no endpoint, do nothing
      return
    }

    // Determine if a fetch should be attempted
    let shouldFetch = false
    const isStale =
      !entity?._lastFetchedAt ||
      Date.now() - (entity._lastFetchedAt || 0) > STALE_THRESHOLD_MS

    if (forceRefresh) {
      shouldFetch = true
    } else {
      switch (fetchPolicy) {
        case 'network-only':
          shouldFetch = true
          break
        case 'cache-and-network':
          shouldFetch = true // Always fetch, UI uses cache if available
          break
        case 'cache-first':
          if (!entity || isStale) {
            shouldFetch = true
          }
          break
        case 'cache-only':
          if (!entity) {
            // Optionally, if entity must exist and be fresh for cache-only:
            // if (!entity || isStale) { console.warn(`Cache-only: Entity ${entityType}:${id} not found or stale.`); }
            // For now, cache-only means "don't fetch if missing" rather than "error if missing".
          }
          break
        default:
          if (!entity || isStale) {
            // Default to cache-first like behavior
            shouldFetch = true
          }
      }
    }

    if (shouldFetch) {
      // The condition inside fetchEntityByIdIfNeededThunk already prevents duplicate inflight requests
      // for the same entity ID and type.
      console.log(
        `[useEntity] Attempting fetch for ${entityType}:${id}, Policy: ${fetchPolicy}, Stale: ${isStale}, Force: ${forceRefresh}`
      )
      dispatch(
        fetchEntityByIdIfNeededThunk({
          entityType: entityType as string, // Cast for safety if entityType is a broader keyof
          id,
          endpoint,
          schema,
          fetchPolicy, // Pass policy for thunk to also respect if it has more nuanced logic
          forceRefresh // Pass forceRefresh to thunk
        })
      )
    }
  }, [
    dispatch,
    entityType,
    id,
    schema,
    endpoint, // Memoized endpoint
    fetchPolicy,
    forceRefresh,
    skip,
    entity?._lastFetchedAt, // Re-check if lastFetchedAt changes (e.g. from another source)
    entity === undefined // Re-check if entity presence changes from defined to undefined
  ])

  // isLoading primarily reflects the direct fetch attempt by this hook or related thunk.
  // If fetchPolicy is cache-and-network and 'entity' is present, isLoading might be true
  // while the background fetch happens.
  return { data: entity, isLoading, error }
}

```
src/hooks/useFloatingTabBarHeight.ts
```typescript
import { useSafeAreaInsets } from 'react-native-safe-area-context'

const TAB_BAR_DESIGN_HEIGHT = 70
const TAB_BAR_BOTTOM_MARGIN = 15

export function useFloatingTabBarHeight(): number {
  const insets = useSafeAreaInsets()
  return TAB_BAR_DESIGN_HEIGHT + Math.max(insets.bottom, TAB_BAR_BOTTOM_MARGIN)
}

```
src/hooks/useProtectedRoute.ts
```typescript
import { useEffect } from 'react'
import { useSelector } from 'react-redux'
import { useRouter, usePathname } from 'expo-router'
import {
  selectIsAuthenticated,
  selectAuthStatus,
  selectInitialAuthChecked
} from '@features/auth/authSelectors'

/**
 * Hook to protect a route. If the user is not authenticated
 * (after the initial auth check is complete), it redirects
 * them to the login screen within the (auth) group,
 * including a redirect query parameter.
 */
export function useProtectedRoute() {
  const router = useRouter()
  const pathname = usePathname() // Get the current path (will be like /main/profile)
  const isAuthenticated = useSelector(selectIsAuthenticated)
  const authStatus = useSelector(selectAuthStatus)
  const initialAuthChecked = useSelector(selectInitialAuthChecked)

  useEffect(() => {
    if (!initialAuthChecked || authStatus === 'loading') {
      // Wait for init check or loading
      return
    }
    if (!isAuthenticated) {
      // If not authenticated after check
      router.replace(`/(auth)/login?redirect=${encodeURIComponent(pathname)}`)
    }
  }, [isAuthenticated, authStatus, initialAuthChecked, router, pathname])

  return {
    isLoading: !initialAuthChecked || authStatus === 'loading',
    isAuthenticated: isAuthenticated
  }
}

```
src/hooks/useRefresh.ts
```typescript
// src/hooks/useRefresh.ts
import { useState, useCallback } from 'react'
import { useDispatch } from 'react-redux'
import { AppDispatch } from '@store/store' // Your AppDispatch type

// Define the type for the action creator function passed to the hook
// It should be a function that returns a Promise (typically wrapping a dispatched thunk)
type RefreshActionCreator = () => Promise<any>

/**
 * Custom hook to manage pull-to-refresh state and execution.
 *
 * @param onRefreshAction - An async function (usually wrapping a Redux thunk dispatch)
 *                          that performs the data refetching. It MUST return a Promise.
 * @returns A tuple containing:
 *          - isRefreshing (boolean): Whether the refresh is currently active.
 *          - handleRefresh (function): The callback function to pass to RefreshControl's onRefresh prop.
 */
export const useRefresh = (
  onRefreshAction: RefreshActionCreator
): [boolean, () => Promise<void>] => {
  const [isRefreshing, setIsRefreshing] = useState(false)
  const dispatch = useDispatch<AppDispatch>() // Although dispatch isn't directly used here,
  // the action passed often uses it.

  const handleRefresh = useCallback(async () => {
    console.log('Pull-to-refresh triggered')
    setIsRefreshing(true)
    try {
      // Execute the passed-in refresh action function
      await onRefreshAction()
      console.log('Refresh action completed successfully.')
      // Optionally add a small delay if UI updates need time
      // await new Promise(resolve => setTimeout(resolve, 300));
    } catch (error) {
      console.error('Error during refresh action:', error)
      // Optionally show a toast or other feedback about the error
    } finally {
      setIsRefreshing(false)
      console.log('Refresh state set to false.')
    }
  }, [onRefreshAction]) // Dependency array includes the action creator

  return [isRefreshing, handleRefresh]
}

```
src/hooks/useRequireAuthAction.ts
```typescript
import { useSelector } from 'react-redux'
import { useRouter, usePathname } from 'expo-router'
import { useCallback } from 'react'
import { selectIsAuthenticated } from '@features/auth/authSelectors'
import { showPlatformAlert } from '@lib/platformAlert'

/**
 * Hook to guard actions that require authentication.
 * If the user is authenticated, it returns the provided callback.
 * If not authenticated, it shows an alert and then redirects the user
 * to the login screen (in the auth group) with a redirect query parameter
 * pointing back to the current page within the main group.
 *
 * @param actionCallback The function to execute if the user is authenticated.
 * @param message Optional message to show before redirecting.
 * @returns A function that either executes the action or triggers the login redirect.
 */
export function useRequireAuthAction<T extends (...args: any[]) => any>(
  actionCallback: T,
  message: string = 'You need to be logged in to perform this action.'
): (...args: Parameters<T>) => void {
  const isAuthenticated = useSelector(selectIsAuthenticated)
  const router = useRouter()
  const pathname = usePathname() // Get the current path (e.g., /main/reader/123)

  const guardedAction = useCallback(
    (...args: Parameters<T>) => {
      if (isAuthenticated) {
        actionCallback(...args)
      } else {
        showPlatformAlert('Authentication Required', message, [
          { text: 'Cancel', style: 'cancel' },
          {
            text: 'Login',
            onPress: () => {
              console.log(
                `[useRequireAuthAction] Redirecting to login from ${pathname}`
              )
              // Redirect to login within the auth group, passing the current path
              router.push(
                `/(auth)/login?redirect=${encodeURIComponent(pathname)}`
              )
            }
          }
        ])
      }
    },
    [isAuthenticated, actionCallback, router, pathname, message]
  )

  return guardedAction
}

```
src/hooks/useResponsiveDimensions.ts
```typescript
import { useWindowDimensions } from 'react-native'

const MOBILE_BREAKPOINT = 768 // Example breakpoint for mobile/desktop distinction

export const useResponsiveDimensions = () => {
  const { width, height } = useWindowDimensions()
  const isMobile = width < MOBILE_BREAKPOINT
  const isDesktop = !isMobile

  return {
    width,
    height,
    isMobile,
    isDesktop
    // Add more specific breakpoints if needed (e.g., isTablet)
  }
}

```
src/hooks/useThemeColor.ts
```typescript
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from "@constants/Colors";
import { useColorScheme } from "@hooks/useColorScheme";

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? "light";
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}


```
src/lib/ApiError.ts
```typescript
/**
 * Custom error class for API-related errors.
 * It includes the HTTP status code and any data returned in the error response body.
 */
export class ApiError extends Error {
  status?: number
  data?: any // Parsed error response body from the API

  constructor(message: string, status?: number, data?: any) {
    super(message) // Pass message to the base Error class constructor
    this.name = 'ApiError' // Set the error name (useful for instanceof checks)
    this.status = status
    this.data = data

    // This line is needed to restore the prototype chain in ES5
    // It's generally good practice for custom errors extending built-in ones.
    Object.setPrototypeOf(this, ApiError.prototype)
  }
}

```
src/lib/api.d.ts
```typescript
export type ApiStatusType = 'idle' | 'loading' | 'succeeded' | 'failed'

```
src/lib/api.ts
```typescript
// src/lib/api.ts
import { store, AppDispatch } from '@store/store' // store is needed for isInitialized check
import * as authActions from '@features/auth/authActions'
// No longer importing authSelectors here for tokens
import * as Device from 'expo-device'
import { Platform } from 'react-native'
import * as tokenStorage from '@lib/tokenStorage'
import * as secureStorage from './secureStorage'
import { ApiError } from './ApiError'
import { API_URL } from './apiRoot'

// --- Auth Initialization State Management ---
let _isAuthInitialized = false
let _authInitializationPromise: Promise<void> | null = null
const _requestQueue: Array<{
  resolve: (value: any) => void
  reject: (reason?: any) => void
  url: string
  options: RequestInit
  dispatch: AppDispatch
}> = []

const DEVICE_TOKEN_KEY = 'kielo_device_token'
let _deviceToken: string | null = null

/**
 * Called by initializeAuthThunk when it completes (successfully or not).
 * This will process any queued API requests.
 */
export const signalAuthInitialized = () => {
  console.log(
    'Auth has been initialized (or initialization attempt completed). Processing request queue.'
  )
  _isAuthInitialized = true
  _processRequestQueue()
}

// This function is for initializeAuthThunk to await if needed,
// though direct signaling is often better.
// Not strictly necessary if signalAuthInitialized is reliably called.
const ensureAuthInitialized = (): Promise<void> => {
  if (_isAuthInitialized) {
    return Promise.resolve()
  }
  if (!_authInitializationPromise) {
    // This promise should ideally be the one returned by initializeAuthThunk,
    // or a new one that gets resolved by signalAuthInitialized.
    // For simplicity, let's create a new promise that signalAuthInitialized resolves.
    _authInitializationPromise = new Promise(resolve => {
      const check = () => {
        if (_isAuthInitialized) {
          resolve()
        } else {
          setTimeout(check, 100) // Check every 100ms
        }
      }
      check()
    })
  }
  return _authInitializationPromise
}

const _processRequestQueue = async () => {
  while (_requestQueue.length > 0) {
    const queuedRequest = _requestQueue.shift()
    if (queuedRequest) {
      console.log('Processing queued request for:', queuedRequest.url)
      try {
        // Re-call the internal _executeRequest function for queued items
        const result = await _executeRequestAndReturnResponse(
          queuedRequest.url,
          queuedRequest.options,
          queuedRequest.dispatch,
          false // A queued request is not an initial retry for 401
        )
        queuedRequest.resolve(result.body) // Resolve with the body
      } catch (error) {
        queuedRequest.reject(error)
      }
    }
  }
}

export const initializeDeviceToken = async (): Promise<string | null> => {
  if (_deviceToken) return _deviceToken

  try {
    const storedToken = await secureStorage.getSecureItem(DEVICE_TOKEN_KEY)
    if (storedToken) {
      _deviceToken = storedToken
      return _deviceToken
    }

    if (Platform.OS === 'web') {
      _deviceToken =
        'web-' +
        Date.now().toString(36) +
        Math.random().toString(36).substring(2)
    } else {
      const identifier =
        Device.osInternalBuildId ||
        Device.osInstallationId ||
        Device.deviceName ||
        `native-${Date.now()}`
      const generatedToken = identifier.replace(/[^a-zA-Z0-9_-]/g, '')
      _deviceToken = generatedToken
    }

    await secureStorage.setSecureItem(DEVICE_TOKEN_KEY, _deviceToken)
    console.log('Generated and Stored New Device Token:', _deviceToken)
    return _deviceToken
  } catch (error) {
    console.error('Error initializing device token:', error)
    _deviceToken = 'error-fallback-' + Math.random().toString(36).substring(2)
    return _deviceToken
  }
}

// Getter for the device token, ensures initialization has been attempted.
// This should ideally be called after initializeDeviceToken has run at least once.
export const getDeviceToken = (): string | null => {
  return _deviceToken
}

// --- Token Refresh Manager ---
const tokenRefresher = {
  isRefreshing: false,
  hasFailedRecently: false, // Indicates if a refresh attempt failed and we should not retry immediately
  promise: null as Promise<string | null> | null,

  resetFailure() {
    this.hasFailedRecently = false // Call this when user logs in successfully or app restarts
  },

  async refresh(dispatch: AppDispatch): Promise<string | null> {
    // Actual refresh logic will be moved here
    // For now, just outlining the structure
    return null
  }
}

// Optional: Expose a way to reset the refresh failure flag, e.g., on successful login
export const resetTokenRefreshFailure = () => {
  tokenRefresher.resetFailure()
}

const handleRefreshToken = async (
  token: string | null,
  dispatch: AppDispatch
): Promise<string | null> => {
  // Use the tokenRefresher state
  if (tokenRefresher.hasFailedRecently) {
    console.warn(
      'Token refresh previously failed, not attempting again immediately.'
    )
    return null
  }

  if (!tokenRefresher.isRefreshing) {
    tokenRefresher.isRefreshing = true
    // tokenRefresher.hasFailedRecently = false; // Reset this at the start of an attempt

    const currentRefreshToken = (await tokenStorage.getStoredTokens())
      .refreshToken
    if (!currentRefreshToken) {
      tokenRefresher.isRefreshing = false
      return null
    }
    console.log('Attempting to refresh token...')
    tokenRefresher.promise = (async () => {
      try {
        const currentDeviceToken = getDeviceToken()
        if (!currentDeviceToken) {
          // This should ideally not happen if initialized at startup
          console.warn(
            "Device token not available for token refresh. Using 'missing'."
          )
        }

        const response = await fetch(`${API_URL}/auth/refresh`, {
          // Now always use the initialized token
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${token}`,
            ...(currentDeviceToken && { 'X-Device-Token': currentDeviceToken })
          },
          body: JSON.stringify({ refresh_token: currentRefreshToken })
        })
        if (!response.ok) {
          throw new Error(`Refresh failed: ${response.status}`)
        }
        const data: {
          access_token: string
          refresh_token?: string
          expires_in: number
        } = await response.json()
        const newAccessToken = data.access_token
        const newRefreshToken = data.refresh_token
        const newExpiresAt = Date.now() + data.expires_in * 1000
        const finalRefreshToken = newRefreshToken || currentRefreshToken
        dispatch(
          authActions.setRefreshedTokens({
            accessToken: newAccessToken,
            refreshToken: finalRefreshToken,
            expiresAt: newExpiresAt
          })
        )
        await tokenStorage.setStoredTokens(
          newAccessToken,
          finalRefreshToken,
          newExpiresAt
        )
        console.log('Token refreshed successfully.')
        tokenRefresher.isRefreshing = false
        tokenRefresher.promise = null
        tokenRefresher.hasFailedRecently = false // Successful refresh, clear failure flag
        return newAccessToken
      } catch (error) {
        console.error('Failed to refresh token:', JSON.stringify(error))
        tokenRefresher.isRefreshing = false
        tokenRefresher.hasFailedRecently = true // Mark that refresh failed
        tokenRefresher.promise = null
        dispatch(authActions.logoutUser())
        return null
      }
    })()
    return tokenRefresher.promise
  } else {
    console.log('Refresh already in progress, waiting...')
    return tokenRefresher.promise
  }
}

// --- NEW ---
// Renamed from _executeRequest to reflect it returns the raw response and parsed body
const _executeRequestAndReturnResponse = async <T>(
  url: string,
  options: RequestInit = {},
  dispatch: AppDispatch,
  isRetry: boolean = false
): Promise<{ response: Response; body: T }> => {
  if (!API_URL) throw new Error('API base URL not configured.')
  const currentDeviceToken = getDeviceToken()
  if (!currentDeviceToken) {
    console.warn('Device token not yet initialized when making API request.')
  }

  const storedTokenData = await tokenStorage.getStoredTokens()
  let token = storedTokenData.token
  const expiresAt = storedTokenData.expiresAt
  const bufferSeconds = 60

  if (token && expiresAt && expiresAt - bufferSeconds * 1000 < Date.now()) {
    console.log(
      `Token for ${url} expired or nearing expiry, attempting refresh...`
    )
    token = await handleRefreshToken(token, dispatch)
    if (!token && !url.includes('/auth/')) {
      console.warn(
        `Authentication token refresh failed or token is null for ${url}.`
      )
    }
  }

  const headers: HeadersInit = {
    ...options.headers,
    'Content-Type': 'application/json',
    'X-Device-Token': currentDeviceToken || 'uninitialized'
  }
  if (token) {
    headers['Authorization'] = `Bearer ${token}`
  }

  try {
    const response = await fetch(`${API_URL}${url}`, { ...options, headers })

    if (!response.ok) {
      if (
        response.status === 401 &&
        !isRetry &&
        !url.includes('/auth/refresh')
      ) {
        console.log(`Received 401 for ${url}, attempting token refresh...`)
        const newToken = await handleRefreshToken(token, dispatch)
        if (newToken) {
          console.log(
            `Refresh successful after 401 for ${url}, retrying original request...`
          )
          return _executeRequestAndReturnResponse<T>(
            url,
            options,
            dispatch,
            true
          )
        } else {
          console.warn(
            `Token refresh failed after 401 for ${url}. Original request will likely fail.`
          )
        }
      }

      let errorData
      try {
        errorData = await response.json()
      } catch (e) {
        errorData = await response.text()
      }
      const errorMessage =
        typeof errorData === 'string'
          ? errorData
          : errorData?.message ||
            errorData?.error ||
            `HTTP error! status: ${response.status}`
      throw new ApiError(errorMessage, response.status, errorData)
    }

    // --- MODIFIED ---
    // Handle body parsing here and return both response and body
    let body: T
    if (response.status === 204) {
      body = null as T
    } else {
      const contentType = response.headers.get('content-type')
      if (contentType?.includes('application/json')) {
        body = (await response.json()) as T
      } else {
        body = (await response.text()) as any as T
      }
    }
    return { response, body }
  } catch (error: any) {
    console.error(
      `Error during _executeRequestAndReturnResponse to ${url}:`,
      error.message
    )
    if (!(error instanceof ApiError)) {
      throw new ApiError(
        error.message || 'A network or execution error occurred.',
        undefined,
        error
      )
    } else {
      throw error
    }
  }
}

// --- MODIFIED ---
// Request function now returns the full object from the executor
const requestWithResponse = async <T>(
  url: string,
  options: RequestInit = {},
  dispatch: AppDispatch
): Promise<{ response: Response; body: T }> => {
  const authState = store.getState().auth
  const initialCheckDone = authState.initialAuthChecked
  const isCurrentlyLoadingAuth = authState.status === 'loading'

  if (
    !initialCheckDone ||
    (isCurrentlyLoadingAuth && !url.startsWith('/auth/'))
  ) {
    console.log(
      `Auth not yet initialized or loading. Queuing request for: ${url}`
    )
    // Queueing needs to be adapted to return the response object as well
    return new Promise((resolve, reject) => {
      // The queueing logic would need adjustment if a queued request
      // itself needs to return the raw response. For now, assuming
      // polling thunks won't be called before auth is initialized.
      // Or we adapt the queue processing. Let's simplify and assume this for now.
      _requestQueue.push({
        resolve: (val: { body: T }) =>
          resolve({ response: new Response(), body: val.body }), // Mock response for queue
        reject,
        url,
        options,
        dispatch
      })
    })
  }

  return _executeRequestAndReturnResponse(url, options, dispatch)
}

// --- MODIFIED ---
// Original request function now wraps the new one to maintain backward compatibility
const request = async <T>(
  url: string,
  options: RequestInit = {},
  dispatch: AppDispatch
): Promise<T> => {
  const { body } = await requestWithResponse<T>(url, options, dispatch)
  return body
}

export const apiClient = {
  get: <T>(url: string, dispatch: AppDispatch): Promise<T> =>
    request<T>(url, { method: 'GET' }, dispatch),
  // --- NEW METHOD ---
  getWithResponse: <T>(
    url: string,
    dispatch: AppDispatch
  ): Promise<{ response: Response; body: T }> =>
    requestWithResponse<T>(url, { method: 'GET' }, dispatch),
  post: <T>(url: string, data: any, dispatch: AppDispatch): Promise<T> =>
    request<T>(url, { method: 'POST', body: JSON.stringify(data) }, dispatch),
  put: <T>(url: string, data: any, dispatch: AppDispatch): Promise<T> =>
    request<T>(url, { method: 'PUT', body: JSON.stringify(data) }, dispatch),
  delete: <T>(url: string, dispatch: AppDispatch): Promise<T> =>
    request<T>(url, { method: 'DELETE' }, dispatch)
}

```
src/lib/apiRoot.ts
```typescript
import Constants from 'expo-constants'
import { Platform } from 'react-native'

const BACKEND_PORT = 8080

/**
 * Gets the base URL for your API depending on the platform and environment.
 * - Web: Uses localhost.
 * - Native (Expo Go/Dev Build): Tries to use the developer machine's local IP.
 * - Native (Production Build): Falls back to localhost (requires separate config/env var setup for prod).
 */
const getDevApiUrl = (): string => {
  const localhost = `http://localhost:${BACKEND_PORT}/api/v1`

  if (Platform.OS === 'web') {
    return localhost
  }

  try {
    const debuggerHost = Constants.manifest2?.extra?.expoGo?.debuggerHost

    if (debuggerHost) {
      const ipAddress = debuggerHost.split(':')[0]
      return `http://${ipAddress}:${BACKEND_PORT}/api/v1`
    }
  } catch (error) {
    console.error('Error getting debugger host:', error)
  }

  console.warn(
    'Could not automatically determine local IP for native development. Falling back to localhost.' +
      ' This might not work on device/simulator unless reverse tunneling is set up.' +
      ' Ensure your backend port is correct and your device is on the same network.'
  )
  return localhost
}

const API_URL = __DEV__ ? getDevApiUrl() : process.env.EXPO_PUBLIC_API_BASE_URL

console.log(`Using API URL: ${API_URL} (__DEV__ = ${__DEV__})`)

export { API_URL }

```
src/lib/appStorage.ts
```typescript
import { Platform } from 'react-native'
import AsyncStorage from '@react-native-async-storage/async-storage'

/**
 * Stores a non-sensitive item persistently. Uses AsyncStorage on native, localStorage on web.
 * @param key The key for the item.
 * @param value The string value to store.
 */
export const setAppItem = async (key: string, value: string): Promise<void> => {
  try {
    if (Platform.OS === 'web') {
      localStorage.setItem(key, value)
    } else {
      await AsyncStorage.setItem(key, value)
    }
  } catch (error) {
    console.error(`Error setting app item for key "${key}":`, error)
  }
}

/**
 * Retrieves a non-sensitive persistent item.
 * @param key The key of the item to retrieve.
 * @returns The stored string value, or null if not found or on error.
 */
export const getAppItem = async (key: string): Promise<string | null> => {
  try {
    if (Platform.OS === 'web') {
      return localStorage.getItem(key)
    } else {
      return await AsyncStorage.getItem(key)
    }
  } catch (error) {
    console.error(`Error getting app item for key "${key}":`, error)
    return null
  }
}

/**
 * Deletes a non-sensitive persistent item.
 * @param key The key of the item to delete.
 */
export const deleteAppItem = async (key: string): Promise<void> => {
  try {
    if (Platform.OS === 'web') {
      localStorage.removeItem(key)
    } else {
      await AsyncStorage.removeItem(key)
    }
  } catch (error) {
    console.error(`Error deleting app item for key "${key}":`, error)
  }
}

```
src/lib/debugToast.ts
```typescript
// src/lib/debugToast.ts
import Toast from 'react-native-toast-message'

type ToastType = 'success' | 'error' | 'info'

/**
 * Shows a short debug toast message globally.
 * Intended for temporary debugging of authentication flows.
 *
 * @param type - 'success', 'error', or 'info'
 * @param title - The main title of the toast
 * @param message - Optional longer message body
 */
export const showAuthDebugToast = (
  type: ToastType,
  title: string,
  message?: string
) => {
  console.log(
    `[AuthDebugToast - ${type.toUpperCase()}] ${title}${
      message ? `: ${message}` : ''
    }`
  ) // Also log to console

  // Ensure Toast is called on the main thread if triggered from background tasks (less likely here but good practice)
  // setTimeout(() => { // Often not needed if called from React components/hooks/thunks
  Toast.show({
    type: type, // 'success', 'error', 'info'
    text1: title,
    text2: message,
    position: 'bottom', // Or 'top'
    visibilityTime: 4000, // 4 seconds
    autoHide: true,
    bottomOffset: 60 // Adjust if needed
  })
  // }, 0);
}

```
src/lib/mediaUtils.ts
```typescript
// src/lib/mediaUtils.ts
// src/lib/mediaUtils.ts
import { MediaMetadata } from '@features/media/types' // Adjust path if needed

type ImageSizeProp = 'thumb' | 'medium' | 'large' // Size prop used by components
type ImageFormat = 'webp' | 'avif' | 'jpeg' // Note: avif is in spec, jpeg is fallback

/**
 * Constructs the full URL for a given variant.
 * @param metadata - The media metadata object.
 * @param variantPath - The path of the variant file.
 * @returns The full URL string or null if inputs are invalid.
 */
const constructMediaUrl = (
  metadata: MediaMetadata | undefined | null,
  variantPath: string | undefined | null
): string | null => {
  if (!metadata || !variantPath) {
    return null
  }
  // serve_base_url already includes /processed/{media_id}/
  return `${metadata.serve_base_url}${variantPath}`
}

/**
 * Selects the best available image variant URL from metadata for raster images.
 * Prioritizes formats and falls back gracefully.
 *
 * @param metadata - The media metadata object.
 * @param preferredSizeProp - The desired size ('thumb', 'medium', 'large').
 * @param preferredFormat - The preferred image format ('avif', 'webp', 'jpeg').
 * @returns The full URL string or null if no suitable variant found.
 */
export const getBestImageUrl = (
  metadata: MediaMetadata | undefined | null,
  preferredSizeProp: ImageSizeProp = 'medium',
  preferredFormat: ImageFormat = 'avif'
): string | null => {
  if (
    !metadata ||
    (metadata.media_type !== 'Image' && metadata.media_type !== 'SVG') || // SVG previews are raster
    metadata.processing_status !== 'Completed' ||
    !metadata.variants
  ) {
    return null
  }

  // Map prop size to variant key prefix
  const sizePrefixMap: Record<ImageSizeProp, ('thumb' | 'mid')[]> = {
    thumb: ['thumb'],
    medium: ['mid', 'thumb'], // Fallback for medium
    large: ['mid', 'thumb'] // Fallback for large (use 'mid' as largest raster example)
  }

  const sizePrefixesToTry = sizePrefixMap[preferredSizeProp]
  const formatKeys: ImageFormat[] = [preferredFormat, 'webp', 'jpeg'] // Define format priority

  for (const prefix of sizePrefixesToTry) {
    for (const format of formatKeys) {
      // For SVG, the preview is always webp and typically corresponds to 'mid' or 'thumb' size implicitly
      const variantKey =
        metadata.media_type === 'SVG' ? 'preview_webp' : `${prefix}_${format}`
      const variant = metadata.variants[variantKey]
      if (variant?.path) {
        return constructMediaUrl(metadata, variant.path)
      }
    }
  }

  // Fallback for SVG if preview_webp wasn't found with specific size_format construction
  if (metadata.media_type === 'SVG' && metadata.variants['preview_webp']) {
    return constructMediaUrl(metadata, metadata.variants['preview_webp'].path)
  }

  console.warn(
    `No suitable image variant found for media ${metadata.media_id} (type: ${metadata.media_type}) with preferences size=${preferredSizeProp}, format=${preferredFormat}`
  )
  return null
}

/**
 * Gets the URL for a static preview image (typically 'preview_webp').
 * Used for GIF, SVG, and Video.
 *
 * @param metadata - The media metadata object.
 * @returns The full URL string or null.
 */
export const getStaticPreviewUrl = (
  metadata: MediaMetadata | undefined | null
): string | null => {
  if (
    !metadata ||
    metadata.processing_status !== 'Completed' ||
    !metadata.variants
  ) {
    return null
  }
  const variant = metadata.variants['preview_webp']
  return variant?.path ? constructMediaUrl(metadata, variant.path) : null
}

/**
 * Gets the best video URL for a GIF, prioritizing specified codecs.
 *
 * @param metadata - The media metadata object, must be of type 'GIF'.
 * @param preferredCodecs - Array of preferred video codecs ('av1', 'vp9').
 * @returns The full URL string or null.
 */
export const getGifAsVideoUrl = (
  metadata: MediaMetadata | undefined | null,
  preferredCodecs: ('av1' | 'vp9')[] = ['av1', 'vp9']
): string | null => {
  if (
    !metadata ||
    metadata.media_type !== 'GIF' ||
    metadata.processing_status !== 'Completed' ||
    !metadata.variants
  ) {
    return null
  }

  for (const codec of preferredCodecs) {
    const variantKey = `main_${codec}` // e.g., "main_av1", "main_vp9"
    const variant = metadata.variants[variantKey]
    if (variant?.path) {
      return constructMediaUrl(metadata, variant.path)
    }
  }
  return null
}

/**
 * Gets the URL for the main SVG variant.
 *
 * @param metadata - The media metadata object, must be of type 'SVG'.
 * @returns The full URL string or null.
 */
export const getSvgUrl = (
  metadata: MediaMetadata | undefined | null
): string | null => {
  if (
    !metadata ||
    metadata.media_type !== 'SVG' ||
    metadata.processing_status !== 'Completed' ||
    !metadata.variants
  ) {
    return null
  }
  const variant = metadata.variants['main_svg']
  return variant?.path ? constructMediaUrl(metadata, variant.path) : null
}

/**
 * Gets the best video URL for a Video, prioritizing specified codecs.
 *
 * @param metadata - The media metadata object, must be of type 'Video'.
 * @param preferredCodecs - Array of preferred video codecs ('av1', 'vp9').
 * @returns The full URL string or null.
 */
export const getBestVideoUrl = (
  metadata: MediaMetadata | undefined | null,
  preferredCodecs: ('av1' | 'vp9')[] = ['av1', 'vp9']
): string | null => {
  if (
    !metadata ||
    metadata.media_type !== 'Video' ||
    metadata.processing_status !== 'Completed' ||
    !metadata.variants
  ) {
    return null
  }
  for (const codec of preferredCodecs) {
    const variantKey = `main_${codec}`
    const variant = metadata.variants[variantKey]
    if (variant?.path) {
      return constructMediaUrl(metadata, variant.path)
    }
  }
  return null
}

/**
 * Gets the best audio URL, prioritizing specified codecs.
 *
 * @param metadata - The media metadata object, must be of type 'Audio'.
 * @param preferredCodecs - Array of preferred audio codecs ('aac', 'mp3').
 * @returns The full URL string or null.
 */
export const getBestAudioUrl = (
  metadata: MediaMetadata | undefined | null,
  preferredCodecs: ('aac' | 'mp3')[] = ['aac', 'mp3']
): string | null => {
  if (
    !metadata ||
    metadata.media_type !== 'Audio' ||
    metadata.processing_status !== 'Completed' ||
    !metadata.variants
  ) {
    return null
  }
  for (const codec of preferredCodecs) {
    const variantKey = `main_${codec}` // e.g. "main_aac", "main_mp3"
    const variant = metadata.variants[variantKey]
    if (variant?.path) {
      return constructMediaUrl(metadata, variant.path)
    }
  }
  return null
}

/**
 * Gets the URL for the original file, used as a fallback if processing failed.
 *
 * @param metadata - The media metadata object.
 * @returns The full URL string or null.
 */
export const getOriginalFileUrl = (
  metadata: MediaMetadata | undefined | null
): string | null => {
  if (!metadata || !metadata.variants) {
    return null
  }
  // Only use if processing actually failed, otherwise prefer processed variants
  if (metadata.processing_status !== 'Failed') {
    // console.warn("getOriginalFileUrl called but processing status is not 'Failed'. This might not be the intended use.");
    // return null; // Or decide if you want to allow access to original even on success
  }
  const variant = metadata.variants['original']
  return variant?.path ? constructMediaUrl(metadata, variant.path) : null
}

```
src/lib/platformAlert.ts
```typescript
import { Alert, Platform } from 'react-native'
import type { AlertButton } from 'react-native'

/**
 * Shows a platform-appropriate alert.
 * On Web, uses window.alert for 0/1 button cases and window.confirm for 2-button cases.
 * Logs a warning for more than 2 buttons on web.
 * On Native, uses React Native's Alert.alert.
 *
 * @param title The alert title.
 * @param message Optional alert message.
 * @param buttons Optional array of alert buttons.
 * @param options Optional alert options (only effective on native).
 */
export const showPlatformAlert = (
  title: string,
  message?: string,
  buttons?: AlertButton[],
  options?: { cancelable?: boolean }
): void => {
  if (Platform.OS !== 'web') {
    Alert.alert(title, message, buttons, options)
    return
  }

  const effectiveMessage = `${title}${message ? '\n\n' + message : ''}`

  if (!buttons || buttons.length === 0 || buttons.length === 1) {
    window.alert(effectiveMessage)
    if (buttons && buttons.length === 1 && buttons[0].onPress) {
      buttons[0].onPress()
    }
    return
  }

  if (buttons.length === 2) {
    const cancelButton = buttons.find(b => b.style === 'cancel') || buttons[0]
    const confirmButton = cancelButton === buttons[0] ? buttons[1] : buttons[0]

    if (window.confirm(effectiveMessage)) {
      if (confirmButton.onPress) {
        confirmButton.onPress()
      }
    } else {
      if (cancelButton.onPress) {
        cancelButton.onPress()
      }
    }
    return
  }

  if (buttons.length > 2) {
    console.warn(
      `showPlatformAlert: Alerts with more than two buttons have limited functionality on web. Displaying basic alert for "${title}".`
    )
    window.alert(effectiveMessage)
    if (buttons[0].onPress) {
      console.log(
        `showPlatformAlert: Triggering action for button "${buttons[0].text}" as fallback.`
      )
      buttons[0].onPress()
    }
    return
  }
}

```
src/lib/secureStorage.ts
```typescript
import { Platform } from 'react-native'
import * as SecureStore from 'expo-secure-store'

const isAvailable = SecureStore.isAvailableAsync()

/**
 * Securely stores an item. Uses SecureStore on native if available, localStorage on web.
 * @param key The key for the item.
 * @param value The string value to store.
 */
export const setSecureItem = async (
  key: string,
  value: string
): Promise<void> => {
  try {
    if (Platform.OS === 'web') {
      localStorage.setItem(key, value)
    } else {
      if (await isAvailable) {
        await SecureStore.setItemAsync(key, value)
      } else {
        console.warn('SecureStore not available on this device.')
      }
    }
  } catch (error) {
    console.error(`Error setting secure item for key "${key}":`, error)
  }
}

/**
 * Retrieves a securely stored item.
 * @param key The key of the item to retrieve.
 * @returns The stored string value, or null if not found or on error.
 */
export const getSecureItem = async (key: string): Promise<string | null> => {
  try {
    if (Platform.OS === 'web') {
      return localStorage.getItem(key)
    } else {
      if (await isAvailable) {
        return await SecureStore.getItemAsync(key)
      } else {
        console.warn('SecureStore not available on this device.')
        return null
      }
    }
  } catch (error) {
    console.error(`Error getting secure item for key "${key}":`, error)
    return null
  }
}

/**
 * Deletes a securely stored item.
 * @param key The key of the item to delete.
 */
export const deleteSecureItem = async (key: string): Promise<void> => {
  try {
    if (Platform.OS === 'web') {
      localStorage.removeItem(key)
    } else {
      if (await isAvailable) {
        await SecureStore.deleteItemAsync(key)
      } else {
        console.warn('SecureStore not available on this device.')
      }
    }
  } catch (error) {
    console.error(`Error deleting secure item for key "${key}":`, error)
  }
}

```
src/lib/tokenStorage.ts
```typescript
import * as secureStorage from './secureStorage'

const ACCESS_TOKEN_KEY = 'kielo_access_token'
const REFRESH_TOKEN_KEY = 'kielo_refresh_token'
const EXPIRY_KEY = 'kielo_token_expiry'

export interface StoredTokenInfo {
  token: string | null
  refreshToken: string | null
  expiresAt: number | null
}

/**
 * Retrieves authentication tokens using the secure storage utility.
 */
export const getStoredTokens = async (): Promise<StoredTokenInfo> => {
  try {
    const [token, refreshToken, expiresAtStr] = await Promise.all([
      secureStorage.getSecureItem(ACCESS_TOKEN_KEY),
      secureStorage.getSecureItem(REFRESH_TOKEN_KEY),
      secureStorage.getSecureItem(EXPIRY_KEY)
    ])
    const expiresAt = expiresAtStr ? parseInt(expiresAtStr, 10) : null
    return {
      token,
      refreshToken,
      expiresAt: expiresAt && !isNaN(expiresAt) ? expiresAt : null
    }
  } catch (error) {
    console.error('Error processing stored tokens:', error)
    return { token: null, refreshToken: null, expiresAt: null }
  }
}

/**
 * Stores authentication tokens using the secure storage utility.
 * @param token Access Token
 * @param refreshToken Refresh Token
 * @param expiresAt Unix timestamp (milliseconds) for access token expiry
 */
export const setStoredTokens = async (
  token: string,
  refreshToken: string,
  expiresAt: number
): Promise<void> => {
  try {
    await Promise.all([
      secureStorage.setSecureItem(ACCESS_TOKEN_KEY, token),
      secureStorage.setSecureItem(REFRESH_TOKEN_KEY, refreshToken),
      secureStorage.setSecureItem(EXPIRY_KEY, expiresAt.toString())
    ])
  } catch (error) {
    console.error('Error saving tokens via secureStorage:', error)
  }
}

/**
 * Removes authentication tokens using the secure storage utility.
 */
export const removeStoredTokens = async (): Promise<void> => {
  try {
    await Promise.all([
      secureStorage.deleteSecureItem(ACCESS_TOKEN_KEY),
      secureStorage.deleteSecureItem(REFRESH_TOKEN_KEY),
      secureStorage.deleteSecureItem(EXPIRY_KEY)
    ])
  } catch (error) {
    console.error('Error removing tokens via secureStorage:', error)
  }
}

```
src/assets/svgs/home.tsx
```
import React from 'react'
import { Svg, Path } from 'react-native-svg'

export function HomeIcon(props: React.ComponentProps<typeof Svg>) {
  return (
    <Svg viewBox="0 0 20 20" fill="currentColor" {...props}>
      <Path d="M10.707 2.293a1 1 0 0 0-1.414 0l-7 7a1 1 0 0 0 1.414 1.414L4 10.414V17a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-6.586l.293.293a1 1 0 0 0 1.414-1.414z" />
    </Svg>
  )
}

```
src/assets/svgs/horizontal-ellepsis-circle.tsx
```
import React from 'react'
import { Svg, Path } from 'react-native-svg'

export function CircleEllipsisIcon(props: React.ComponentProps<typeof Svg>) {
  return (
    <Svg viewBox="0 0 20 20" fill="currentColor" {...props}>
      <Path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16M7 9H5v2h2zm8 0h-2v2h2zM9 9h2v2H9z"
      />
    </Svg>
  )
}

```
src/assets/svgs/open-book.tsx
```
import React from 'react'
import { Svg, Path } from 'react-native-svg'

export function BookOpenIcon(props: React.ComponentProps<typeof Svg>) {
  return (
    <Svg viewBox="0 0 20 20" fill="currentColor" {...props}>
      <Path d="M9 4.804A8 8 0 0 0 5.5 4c-1.255 0-2.443.29-3.5.804v10A8 8 0 0 1 5.5 14c1.669 0 3.218.51 4.5 1.385A7.96 7.96 0 0 1 14.5 14c1.255 0 2.443.29 3.5.804v-10A8 8 0 0 0 14.5 4c-1.255 0-2.443.29-3.5.804V12a1 1 0 1 1-2 0z" />
    </Svg>
  )
}

```
src/assets/svgs/streak-flame.tsx
```
import React from 'react';
import { Svg, Path } from 'react-native-svg';

export function FlameIcon(props: React.ComponentProps<typeof Svg>) {
  return (
    <Svg
      viewBox="0 0 20 20"
      fill="currentColor"
      {...props}
    >
      <Path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M12.395 2.553a1 1 0 0 0-1.45-.385c-.345.23-.614.558-.822.88-.214.33-.403.713-.57 1.116-.334.804-.614 1.768-.84 2.734a31 31 0 0 0-.613 3.58 2.64 2.64 0 0 1-.945-1.067c-.328-.68-.398-1.534-.398-2.654A1 1 0 0 0 5.05 6.05 6.98 6.98 0 0 0 3 11a7 7 0 1 0 11.95-4.95c-.592-.591-.98-.985-1.348-1.467-.363-.476-.724-1.063-1.207-2.03M12.12 15.12A3 3 0 0 1 7 13s.879.5 2.5.5c0-1 .5-4 1.25-4.5.5 1 .786 1.293 1.371 1.879A3 3 0 0 1 13 13a3 3 0 0 1-.879 2.121z"
      />
    </Svg>
  );
}
```
src/assets/ic-launcher/web/site.webmanifest
```
{
  "name": "MyWebSite",
  "short_name": "MySite",
  "icons": [
    {
      "src": "/web-app-manifest-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable"
    },
    {
      "src": "/web-app-manifest-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable"
    }
  ],
  "theme_color": "#ffffff",
  "background_color": "#ffffff",
  "display": "standalone"
}
```
src/entities/reducer.js
```javascript
// src/entities/reducer.js
import { mergeEntities, removeEntity } from './utils'
import { fetchSavedItemsThunk } from '@features/savedItems/savedItemsActions'
import {
  LOGIN_SUCCESS,
  SOCIAL_LOGIN_SUCCESS,
  INITIALIZE_AUTH_SUCCESS
} from '@features/auth/authActionTypes'
import { fetchEntityByIdIfNeededThunk } from '@features/entities/entityActions'
import { FETCH_ARTICLES_SUCCESS } from '@features/articles/articlesActionTypes' // Example list success
// Import other list success action types:
// import { FETCH_VOCABULARY_SUCCESS } from "@features/vocabulary/vocabularyActionTypes";

const FETCH_ENTITY_BY_ID_PENDING = 'entities/fetchByIdIfNeeded/pending'
const FETCH_ENTITY_BY_ID_FULFILLED = 'entities/fetchByIdIfNeeded/fulfilled'
const FETCH_ENTITY_BY_ID_REJECTED = 'entities/fetchByIdIfNeeded/rejected'

const initialEntityMetaState = {
  lastFetchedListAt: null, // Timestamp: last time a full list of this entity type was fetched
  lastFetchedById: {}, // { [id: string]: number } Timestamp: last time this specific entity ID was fetched/updated
  loadingById: {}, // { [id: string]: 'pending' | 'succeeded' | 'failed' | 'idle' }
  errorById: {} // { [id: string]: string | null }
}

const initialState = {
  articles: {},
  users: {},
  baseWords: {},
  // Add other entity types here as needed
  // IMPORTANT: Ensure any entityType string used in actions/thunks has a corresponding key in _meta
  _meta: {
    articles: { ...initialEntityMetaState },
    users: { ...initialEntityMetaState },
    baseWords: { ...initialEntityMetaState }
    // Ensure all entity types you normalize have an entry here
  }
}

export default function entities(state = initialState, action) {
  let nextState = state // Start with current state
  let entitiesToMerge = null
  let wasSingleEntityFetch = false
  let singleEntityMetaInfo = null // To hold { entityType, id, timestamp } for single fetches

  // --- Handle fetchEntityByIdIfNeededThunk lifecycle ---
  if (action.type === FETCH_ENTITY_BY_ID_PENDING) {
    // Or use fetchEntityByIdIfNeededThunk.pending.type later
    const { entityType, id } = action.meta.arg
    if (state._meta[entityType]) {
      nextState = {
        ...state,
        _meta: {
          ...state._meta,
          [entityType]: {
            ...state._meta[entityType],
            loadingById: {
              ...state._meta[entityType].loadingById,
              [id]: 'pending'
            },
            errorById: { ...state._meta[entityType].errorById, [id]: null }
          }
        }
      }
    }
  } else if (action.type === FETCH_ENTITY_BY_ID_FULFILLED) {
    // Or use .fulfilled.type
    const { entityType, id } = action.meta.arg
    if (action.payload && action.payload.entities) {
      // payload is { result, entities } or null
      entitiesToMerge = action.payload.entities // These entities already have _lastFetchedAt
      wasSingleEntityFetch = true
      singleEntityMetaInfo = { entityType, id, timestamp: Date.now() } // Use current time for fulfilled
    }
    if (state._meta[entityType]) {
      nextState = {
        ...nextState,
        _meta: {
          ...nextState._meta,
          [entityType]: {
            ...nextState._meta[entityType],
            loadingById: {
              ...nextState._meta[entityType].loadingById,
              [id]: 'succeeded'
            }
            // errorById[id] should be null from pending, or cleared if needed
          }
        }
      }
    }
  } else if (action.type === FETCH_ENTITY_BY_ID_REJECTED) {
    // Or use .rejected.type
    const { entityType, id } = action.meta.arg
    if (state._meta[entityType]) {
      nextState = {
        ...state,
        _meta: {
          ...state._meta,
          [entityType]: {
            ...state._meta[entityType],
            loadingById: {
              ...state._meta[entityType].loadingById,
              [id]: 'failed'
            },
            errorById: {
              ...state._meta[entityType].errorById,
              [id]: action.payload || action.error?.message || 'Failed'
            }
          }
        }
      }
    }
  }

  // --- Generic Entity Merging (from lists or other direct entity payloads) ---
  if (
    !entitiesToMerge &&
    action.response?.entities &&
    Object.keys(action.response.entities).length > 0
  ) {
    entitiesToMerge = action.response.entities // From createApiRequestThunk (pagination HOC)
  } else if (
    !entitiesToMerge &&
    [
      LOGIN_SUCCESS,
      SOCIAL_LOGIN_SUCCESS,
      INITIALIZE_AUTH_SUCCESS,
      fetchSavedItemsThunk.fulfilled.type
    ].includes(action.type) &&
    action.payload?.entities &&
    Object.keys(action.payload.entities).length > 0
  ) {
    entitiesToMerge = action.payload.entities // From custom thunks like auth, savedItems
  }

  if (entitiesToMerge) {
    let tempMetaUpdates = {} // Accumulate meta updates for entity types involved in this merge

    for (const [entityType, entityMap] of Object.entries(entitiesToMerge)) {
      if (
        nextState[entityType] !== undefined ||
        initialState[entityType] !== undefined
      ) {
        // Check if entity type is known
        // The entities in entityMap (from createApiRequestThunk or fetchEntityByIdIfNeededThunk)
        // should already have _lastFetchedAt set by the thunk before normalization.
        nextState = {
          ...nextState,
          [entityType]: mergeEntities(nextState[entityType] || {}, entityMap)
        }

        // Update lastFetchedListAt heuristically if not a single entity fetch.
        // More precise updates to lastFetchedListAt might come from pagination reducers or specific list actions.
        if (!wasSingleEntityFetch && nextState._meta[entityType]) {
          if (!tempMetaUpdates[entityType]) tempMetaUpdates[entityType] = {}
          tempMetaUpdates[entityType].lastFetchedListAt = Date.now()
        }
      } else {
        console.warn(
          `Entities Reducer: Received entities for unknown type "${entityType}". Ensure it's in initialState and _meta.`
        )
      }
    }

    // Apply accumulated meta updates
    if (Object.keys(tempMetaUpdates).length > 0) {
      let newOverallMeta = { ...nextState._meta }
      for (const entityType in tempMetaUpdates) {
        newOverallMeta[entityType] = {
          ...newOverallMeta[entityType],
          ...tempMetaUpdates[entityType]
        }
      }
      nextState = { ...nextState, _meta: newOverallMeta }
    }
  }

  // If it was a single entity fetch and successful (handled by fetchEntityByIdIfNeededThunk.fulfilled),
  // update its specific lastFetchedById for that entity.
  if (
    wasSingleEntityFetch &&
    singleEntityMetaInfo &&
    nextState._meta[singleEntityMetaInfo.entityType]
  ) {
    nextState = {
      ...nextState,
      _meta: {
        ...nextState._meta,
        [singleEntityMetaInfo.entityType]: {
          ...nextState._meta[singleEntityMetaInfo.entityType],
          lastFetchedById: {
            ...nextState._meta[singleEntityMetaInfo.entityType].lastFetchedById,
            [singleEntityMetaInfo.id]: singleEntityMetaInfo.timestamp
          }
        }
      }
    }
  }

  // --- Handle explicit removal ---
  // (Example: action from a withPaginationEntityAction HOC for DELETE)
  if (
    action.meta?.entityName &&
    action.meta?.itemId &&
    action.meta?.requestStatus === 'fulfilled' &&
    (action.meta?.verb === 'DELETE' || action.meta?.operation === 'delete')
  ) {
    const entityType = action.meta.entityName
    const itemIdsToRemove = Array.isArray(action.meta.itemId)
      ? action.meta.itemId
      : [action.meta.itemId]

    nextState = removeEntity(nextState, entityType, itemIdsToRemove) // removeEntity should only affect the main entity store part

    // Also clear _meta for the removed entities
    if (nextState._meta[entityType]) {
      const currentMetaForType = nextState._meta[entityType]
      const newLoadingById = { ...currentMetaForType.loadingById }
      const newErrorById = { ...currentMetaForType.errorById }
      const newLastFetchedById = { ...currentMetaForType.lastFetchedById }

      itemIdsToRemove.forEach(id => {
        delete newLoadingById[id]
        delete newErrorById[id]
        delete newLastFetchedById[id]
      })
      nextState = {
        ...nextState,
        _meta: {
          ...nextState._meta,
          [entityType]: {
            ...currentMetaForType,
            loadingById: newLoadingById,
            errorById: newErrorById,
            lastFetchedById: newLastFetchedById
          }
        }
      }
    }
  }
  return nextState
}

```
src/entities/types.d.ts
```typescript
export interface Entities {
  [id: string]: object;
}

export type EntitiesType = Entities;


```
src/entities/utils.ts
```typescript
export function mergeEntities(stateSlice = {}, newEntities = {}) {
  // Basic validation
  if (!newEntities || typeof newEntities !== 'object') return stateSlice

  const merged = { ...stateSlice }
  for (const [key, value] of Object.entries(newEntities)) {
    // If new entity has _lastFetchedAt, or if existing doesn't, take new one.
    // Otherwise, if both have it, take the newer one.
    const existingEntity = stateSlice[key] as any
    const newEntity = value as any
    const existingLastFetched = existingEntity?._lastFetchedAt
    const newLastFetched = newEntity?._lastFetchedAt

    merged[key] = { ...(existingEntity || {}), ...newEntity } // Spread new over old
    // Ensure the latest _lastFetchedAt is preserved or set
    if (
      newLastFetched &&
      (!existingLastFetched || newLastFetched > existingLastFetched)
    ) {
      ;(merged[key] as any)._lastFetchedAt = newLastFetched
    } else if (existingLastFetched && !(merged[key] as any)._lastFetchedAt) {
      // If new entity somehow didn't have it but old one did, keep old one.
      // This case should be rare if createApiRequestThunk always adds it.
      ;(merged[key] as any)._lastFetchedAt = existingLastFetched
    }
  }
  return merged
}

export function removeEntity(stateSlice = {}, entityName, itemId) {
  // Guard clauses for invalid input
  if (!stateSlice || !entityName || !itemId || !stateSlice[entityName]) {
    return stateSlice
  }

  const entityMap = { ...stateSlice[entityName] }
  const idsToRemove = Array.isArray(itemId) ? itemId : [itemId]

  // Use forEach for iteration
  idsToRemove.forEach(id => {
    if (id !== null && id !== undefined) {
      // Ensure ID is valid before deleting
      delete entityMap[id]
    }
  })

  return {
    ...stateSlice,
    [entityName]: entityMap
  }
}

```
src/entities/schemas/articleSchema.js
```javascript
import { schema } from 'normalizr'

const articleSchema = new schema.Entity(
  'articles',
  {},
  {
    idAttribute: 'id'
  }
)

articleSchema.define({})

export default new schema.Array(articleSchema)
export { articleSchema as ARTICLE_SCHEMA_SINGLE }

```
src/entities/schemas/baseWordSchema.js
```javascript
import { schema } from 'normalizr'

const baseWordSchema = new schema.Entity('baseWords', {}, { idAttribute: 'id' })

export default baseWordSchema

```
src/entities/schemas/index.js
```javascript
export {
  default as ARTICLE_ARRAY,
  ARTICLE_SCHEMA_SINGLE
} from './articleSchema'
export { default as BASE_WORD_SCHEMA } from './baseWordSchema'
export { default as SAVED_ITEM_ARRAY_SCHEMA } from './savedItemSchema'
export { default as USER_SCHEMA } from './userSchema'
export {
  default as USER_VOCABULARY_ENTRY_SCHEMA,
  USER_VOCABULARY_ENTRY_ARRAY_SCHEMA
} from './userVocabularyEntrySchema'

```
src/entities/schemas/savedItemSchema.js
```javascript
import { schema } from 'normalizr'
import { ARTICLE_SCHEMA_SINGLE } from '@entities/schemas'
import BASE_WORD_SCHEMA from './baseWordSchema'

const itemDetailSchema = new schema.Union(
  {
    ArticleVersion: ARTICLE_SCHEMA_SINGLE,
    BaseWord: BASE_WORD_SCHEMA
  },
  entity => {
    return entity.item_type
  }
)

const apiSavedItemSchema = new schema.Entity(
  'savedEntries',
  {
    item_details: itemDetailSchema
  },
  {
    idAttribute: value => `${value.item_type}-${value.item_id}`
  }
)

const savedItemArraySchema = new schema.Array(apiSavedItemSchema)

export default savedItemArraySchema

```
src/entities/schemas/userSchema.js
```javascript
import { schema } from 'normalizr'

const userSchema = new schema.Entity('users', {}, { idAttribute: 'id' })

export default userSchema

```
src/entities/schemas/userVocabularyEntrySchema.js
```javascript
// src/entities/schemas/baseWordSchema.js
import { schema } from 'normalizr'

const baseWordSchema = new schema.Entity(
  'baseWords',
  {},
  // Ensure this 'id' matches the unique ID field in your BaseWordSnippet/BaseWordDetail objects
  // that come from the API's item_details or vocabulary list.
  { idAttribute: 'id' } // Or 'base_word_id' if that's the field name
)

export default baseWordSchema

```
src/entities/transforms/index.js
```javascript

```
src/store/authTransform.ts
```typescript
// src/store/authTransform.ts
import { createTransform } from 'redux-persist'
import { AuthState } from '@features/auth/types' // Your AuthState type

// This transform will only save and load 'userId' and 'initialAuthChecked' from the auth state.
// 'status' and 'error' will be omitted during persistence and will revert to their
// initialSate values upon rehydration if not explicitly handled.
const AuthTransform = createTransform(
  // transform state on its way to being serialized and persisted.
  (inboundState: AuthState, key) => {
    // We only want to persist userId and initialAuthChecked
    return {
      userId: inboundState.userId,
      initialAuthChecked: inboundState.initialAuthChecked
      // status and error are omitted
    }
  },
  // transform state being rehydrated
  (outboundState: any, key) => {
    // When rehydrating, ensure status and error are reset or set to sensible defaults.
    // The authReducer's initialState will handle this if these fields are undefined.
    // So, just return the persisted parts. If you wanted to explicitly set them to
    // initial values here, you could.
    return {
      ...outboundState, // This will have userId and initialAuthChecked
      status: 'idle', // Explicitly reset status on rehydration
      error: null // Explicitly reset error on rehydration
    }
  },
  // define which reducer this transform is applied to
  { whitelist: ['auth'] }
)

export default AuthTransform

```
src/store/persistStorage.ts
```typescript
// src/store/persistStorage.ts
import { Storage } from 'redux-persist'
import { setAppItem, getAppItem, deleteAppItem } from '@lib/appStorage' // Your existing functions

const persistStorage: Storage = {
  setItem: (key, value) => {
    return setAppItem(key, value) // Already returns Promise<void>
  },
  getItem: key => {
    return getAppItem(key) // Already returns Promise<string | null>
  },
  removeItem: key => {
    return deleteAppItem(key) // Already returns Promise<void>
  }
}

export default persistStorage

```
src/store/rootReducer.ts
```typescript
import { combineReducers } from '@reduxjs/toolkit'
import authReducer from '@features/auth/authReducer'
import articlePaginationReducer from '@features/articles/articlesReducer'
import entitiesReducer from '@entities/reducer'
import mediaReducer from '@features/media/mediaSlice'
import savedItemsReducer from '@features/savedItems/savedItemsSlice'
import vocabularyReducer from '@features/vocabulary/vocabularySlice'
import readsReducer from '@features/reads/readsSlice'
import progressReducer from '@features/progress/progressSlice'
import achievementsReducer from '@features/achievements/achievementsSlice'
import reviewsReducer from '@features/reviews/reviewsSlice'
import lessonsReducer from '@features/lessons/lessonsSlice'
import challengesReducer from '@features/challenges/challengesSlice'

const pagination = combineReducers({
  articlePagination: articlePaginationReducer
})

const rootReducer = combineReducers({
  auth: authReducer,
  entities: entitiesReducer,
  media: mediaReducer,
  savedItems: savedItemsReducer,
  vocabulary: vocabularyReducer,
  reads: readsReducer,
  progress: progressReducer,
  achievements: achievementsReducer,
  reviews: reviewsReducer,
  lessons: lessonsReducer,
  challenges: challengesReducer,
  pagination
})

export default rootReducer

```
src/store/store.ts
```typescript
import { AnyAction, configureStore, ThunkAction } from '@reduxjs/toolkit'
import {
  persistStore,
  persistReducer,
  FLUSH,
  REHYDRATE,
  PAUSE,
  PERSIST,
  PURGE,
  REGISTER
} from 'redux-persist'
import rootReducer from './rootReducer'
import persistStorage from './persistStorage'
import AuthTransform from './authTransform'

const persistConfig = {
  key: 'root', // Key for the persisted state in storage
  storage: persistStorage, // Use your custom storage engine
  version: 1, // Optional: for migrations
  // Whitelist: specify which reducers you want to persist.
  // Useful for not persisting transient or large data.
  whitelist: [
    'auth',
    'entities' /* 'entities', 'pagination' (consider carefully) */
  ],
  // Blacklist: specify reducers you DO NOT want to persist.
  // blacklist: ['transientFeature'],
  transforms: [AuthTransform]
}

const persistedReducer = persistReducer(persistConfig, rootReducer)

export const store = configureStore({
  reducer: persistedReducer, // Use the persisted reducer
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware({
      serializableCheck: {
        // Ignore these action types from redux-persist
        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER]
      }
    })
})

export const persistor = persistStore(store)

export type RootState = ReturnType<typeof store.getState>
export type AppDispatch = typeof store.dispatch
export type AppThunk<ReturnType = void> = ThunkAction<
  ReturnType,
  RootState,
  unknown,
  AnyAction
>

```
